<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Data.SqlClient</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Data.OperationAbortedException">
            <summary>
        This exception is thrown when an ongoing operation is aborted by the user.
      </summary><remarks>
        This exception indicates that an operation has been aborted by the consumer of an API.  For example, if the event handler of the <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" /> event sets the <see cref="P:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs.Abort" />  property to <see langword="true" /> in the <see cref="T:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs" /> object passed to the handler, the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" /> method stops sending rows to the server and throws an <see cref="T:Microsoft.Data.OperationAbortedException" /> .
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlDbTypeExtensions">
            <summary>Extensions for SqlDbType.</summary><remarks>
        <format type="text/markdown">
          <![CDATA[  

## Remarks  
The <xref:Microsoft.Data.SqlDbTypeExtensions> class provides <xref:System.Data.SqlDbType> enums which will be added. These are meant to be used by applications which cannot leverage the enums in <xref:System.Data.SqlDbType> available in newer .NET runtime versions.

]]>
        </format>
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlDbTypeExtensions.Json">
            <SqlJson name="default">
      <summary>Gets the <see cref="T:System.Data.SqlDbType" /> enum value for the JSON datatype.</summary>
      <returns>
        <see cref="T:System.Data.SqlDbType" /> enum value for JSON datatype.
      </returns>
    </SqlJson>
        </member>
        <member name="T:Microsoft.Data.Sql.SqlNotificationRequest">
            <summary>
        Represents a request for notification for a given command.
      </summary><remarks>
        This class provides low-level access to the query notification services exposed by SQL Server 2005. For most applications the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> class provides a simpler way of using query notifications. However, if you need fine control over when notifications occur, or you need to customize the message data returned as part of a notification, the <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> class is the one to use.
      </remarks><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/query-notifications-sql-server">
        Using Query Notifications
      </seealso>
        </member>
        <member name="M:Microsoft.Data.Sql.SqlNotificationRequest.#ctor">
            <summary>
        Creates a new instance of the <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> class with default values.
      </summary><remarks>
        If the parameterless constructor is used to create a <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> object, that instance must have its <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.UserData" /> and <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.Options" /> properties initialized before assigning the object to a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object's <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Notification" /> property. The default values used by the constructor are <see langword="null" /> (<c>Nothing</c> in Visual Basic) for the <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.UserData" />, an empty string for the <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.Options" />, and zero for the <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.Timeout" />.
      </remarks><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/query-notifications-sql-server">
        Using Query Notifications
      </seealso>
        </member>
        <member name="M:Microsoft.Data.Sql.SqlNotificationRequest.#ctor(System.String,System.String,System.Int32)">
            <param name="userData">
        A string that contains an application-specific identifier for this notification. It is not used by the notifications infrastructure, but it allows you to associate notifications with the application state. The value indicated in this parameter is included in the Service Broker queue message.
      </param><param name="options">
        A string that contains the Service Broker service name where notification messages are posted, and it must include a database name or a Service Broker instance GUID that restricts the scope of the service name lookup to a particular database. For more information about the format of the <paramref name="options" /> parameter, see <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.Options" />.
      </param><param name="timeout">
        The time, in seconds, to wait for a notification message.
      </param><summary>
        Creates a new instance of the <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> class with a user-defined string that identifies a particular notification request, the name of a predefined SQL Server 2005 Service Broker service name, and the time-out period, measured in seconds.
      </summary><remarks>
        This constructor allows you to initialize a new <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> instance, providing your own identifier, the SQL Server 2005 Service Broker service name, and a time-out value.
      </remarks><exception cref="T:System.ArgumentNullException">
        The value of the <paramref name="options" /> parameter is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="options" /> or <paramref name="userData" /> parameter is longer than <see cref="F:System.UInt16.MaxValue" /> or the value in the <paramref name="timeout" /> parameter is less than zero.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/query-notifications-sql-server">
        Using Query Notifications
      </seealso>
        </member>
        <member name="P:Microsoft.Data.Sql.SqlNotificationRequest.Options">
            <summary>
        Gets or sets the SQL Server Service Broker service name where notification messages are posted.
      </summary><value>
        <see cref="T:System.String" /> that contains the SQL Server 2005 Service Broker service name where notification messages are posted and the database or service broker instance GUID to scope the server name lookup.
      </value><remarks>
        <para>
          The value of the <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.Options" /> property has the following format:
        </para>
        <code>
          service=&lt;service-name&gt;{;(local database=&lt;database&gt;|broker instance=&lt;broker instance&gt;)}
        </code>
        <para>
          For example, if you use the service "myservice" in the database "AdventureWorks" the format is:
        </para>
        <code>
          service=myservice;local database=AdventureWorks
        </code>
        <para>
          The SQL Server Service Broker service must be previously configured on the server. In addition, a Service Broker service and queue must be defined and security access granted as needed. See the SQL Server 2005 documentation for more information.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The value is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        The value is longer than <see cref="F:System.UInt16.MaxValue" />.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/query-notifications-sql-server">
        Using Query Notifications
      </seealso>
        </member>
        <member name="P:Microsoft.Data.Sql.SqlNotificationRequest.Timeout">
            <summary>
        Gets or sets a value that specifies how long SQL Server waits for a change to occur before the operation times out.
      </summary><value>
        A signed integer value that specifies, in seconds, how long SQL Server waits for a change to occur before the operation times out.
      </value><remarks>
        After the time-out period expires, the notification is sent even if no change takes place. The <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.Timeout" /> property defaults to the value set on the server.
      </remarks><exception cref="T:System.ArgumentOutOfRangeException">
        The value is less than zero.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/query-notifications-sql-server">
        Using Query Notifications
      </seealso>
        </member>
        <member name="P:Microsoft.Data.Sql.SqlNotificationRequest.UserData">
            <summary>
        Gets or sets an application-specific identifier for this notification.
      </summary><value>
        A <see cref="T:System.String" /> value of the application-specific identifier for this notification.
      </value><remarks>
        This value is not used by the notifications infrastructure. Instead, it is a mechanism that allows an application to associate notifications with application state. The value specified in the <see cref="P:Microsoft.Data.Sql.SqlNotificationRequest.UserData" /> property is included in the SQL Server 2005 queue message.
      </remarks><exception cref="T:System.ArgumentException">
        The value is longer than <see cref="F:System.UInt16.MaxValue" />.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/query-notifications-sql-server">
        Using Query Notifications
      </seealso>
        </member>
        <member name="T:Microsoft.Data.Sql.SqlDataSourceEnumerator">
            <summary>
        Provides a mechanism for enumerating all available instances of SQL Server within the local network.
      </summary><remarks>
        SQL Server makes it possible for applications to determine the existence of its instances within the current network. The <see cref="T:Microsoft.Data.Sql.SqlDataSourceEnumerator" /> class exposes this information to the application developer, providing a <see cref="T:System.Data.DataTable" /> containing information about all the available servers. This returned table contains a list of server instances that matches the list provided when a user attempts to create a new connection, and on the <c>Connection Properties</c> dialog box, expands the drop-down list containing all the available servers.
      </remarks><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/enumerate-instances-sql-server">
        Enumerating Instances of SQL Server
      </seealso>
        </member>
        <member name="P:Microsoft.Data.Sql.SqlDataSourceEnumerator.Instance">
            <summary>
        Gets an instance of the <see cref="T:Microsoft.Data.Sql.SqlDataSourceEnumerator" /> , which can be used to retrieve information about available SQL Server instances.
      </summary><value>
        An instance of the <see cref="T:Microsoft.Data.Sql.SqlDataSourceEnumerator" /> used to retrieve information about available SQL Server instances.
      </value><remarks>
        <para>
          The <see cref="T:Microsoft.Data.Sql.SqlDataSourceEnumerator" /> class does not provide a constructor. Use the <see cref="P:Microsoft.Data.Sql.SqlDataSourceEnumerator.Instance" /> property to retrieve an instance of the class instead.
        </para>
        <!-- SqlDataSourceEnumeratorExample -->
        <code language="c#">
          using System;
          using Microsoft.Data.Sql;  
            
          class Program  
          {  
            static void Main()  
            {  
              // Retrieve the enumerator instance and then the data.  
              SqlDataSourceEnumerator instance =  
                SqlDataSourceEnumerator.Instance;  
              System.Data.DataTable table = instance.GetDataSources();  
            
              // Display the contents of the table.  
              DisplayData(table);  
            
              Console.WriteLine("Press any key to continue.");  
              Console.ReadKey();  
            }  
            
            private static void DisplayData(System.Data.DataTable table)  
            {  
              foreach (System.Data.DataRow row in table.Rows)  
              {  
                foreach (System.Data.DataColumn col in table.Columns)  
                {  
                  Console.WriteLine("{0} = {1}", col.ColumnName, row[col]);  
                }  
                Console.WriteLine("============================");  
              }  
            }  
          } 
        </code>
      </remarks><example>
        <para>
          The following console application displays a list of all the available SQL Server 2005 instances within the local network. This code uses the <see cref="M:System.Data.DataTable.Select" /> method to filter the rows in the table returned by the <see cref="M:Microsoft.Data.Sql.SqlDataSourceEnumerator.GetDataSources" /> method.
        </para>
        <!-- SqlDataSourceEnumeratorVersionExample -->
        <code language="c#">
          using System;
          using Microsoft.Data.Sql;  
            
          class Program  
          {  
            static void Main()  
            {  
              // Retrieve the enumerator instance, and  
              // then retrieve the data sources.  
              SqlDataSourceEnumerator instance = SqlDataSourceEnumerator.Instance;  
              System.Data.DataTable table = instance.GetDataSources();  
            
              // Filter the sources to just show SQL Server 2012 instances.  
              System.Data.DataRow[] rows = table.Select("Version LIKE '11%'");  
              foreach (System.Data.DataRow row in rows)  
              {  
                Console.WriteLine(row["ServerName"]);  
              }
              
              Console.WriteLine("Press any key to continue.");  
              Console.ReadKey();  
            }  
          } 
        </code>
      </example><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/enumerate-instances-sql-server">
        Enumerating Instances of SQL Server
      </seealso>  
        </member>
        <member name="M:Microsoft.Data.Sql.SqlDataSourceEnumerator.GetDataSources">
            <summary>
        Retrieves a <see cref="T:System.Data.DataTable" /> containing information about all visible SQL Server instances.
      </summary><returns>
        A <see cref="T:System.Data.DataTable" /> containing information about the visible SQL Server instances.
      </returns><remarks>
        <para>
          The table returned by this method contains the following columns, all of which contain strings:
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>Column</term>
              <description>Description</description>
            </listheader>
            <item>
              <term><b>ServerName</b></term>
              <description>Name of the server.</description>
            </item>
            <item>
              <term><b>InstanceName</b></term>
              <description>Name of the server instance. Blank if the server is running as the default instance.</description>
            </item>
            <item>
              <term><b>IsClustered</b></term>
              <description>Indicates whether the server is part of a cluster.</description>
            </item>
            <item>
              <term><b>Version</b></term>
              <description>
                Version of the server:
                <list type="bullet">
                  <item>10.0.xx for SQL Server 2008</item>
                  <item>10.50.x for SQL Server 2008 R2</item>
                  <item>11.0.xx for SQL Server 2012 </item>
                  <item>12.0.xx for SQL Server 2014</item>
                  <item>13.0.xx for SQL Server 2016</item>
                  <item>14.0.xx for SQL Server 2017</item>
                </list>
              </description>
            </item>
          </list>
          <note type="note">
            Due to the nature of the mechanism used by <see cref="T:Microsoft.Data.Sql.SqlDataSourceEnumerator" /> to locate data sources on a network, the method will not always return a complete list of the available servers, and the list might not be the same on every call. If you plan to use this function to let users select a server from a list, make sure that you always also supply an option to type in a name that is not in the list, in case the server enumeration does not return all the available servers. In addition, this method may take a significant amount of time to execute, so be careful about calling it when performance is critical.
          </note>
        </para>
      </remarks><example>
        <para>
          The following console application retrieves information about all the visible SQL Server instances and displays the information in the console window.
        </para>
        <!-- SqlDataSourceEnumeratorExample -->
        <code language="c#">
          using System;
          using Microsoft.Data.Sql;  
            
          class Program  
          {  
            static void Main()  
            {  
              // Retrieve the enumerator instance and then the data.  
              SqlDataSourceEnumerator instance = SqlDataSourceEnumerator.Instance;  
              System.Data.DataTable table = instance.GetDataSources();  
            
              // Display the contents of the table.  
              DisplayData(table);  
            
              Console.WriteLine("Press any key to continue.");  
              Console.ReadKey();  
            }  
            
            private static void DisplayData(System.Data.DataTable table)  
            {  
              foreach (System.Data.DataRow row in table.Rows)  
              {
                foreach (System.Data.DataColumn col in table.Columns)  
                {
                  Console.WriteLine("{0} = {1}", col.ColumnName, row[col]);  
                }  
                Console.WriteLine("============================");  
              }  
            }  
          } 
        </code>
      </example><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/enumerate-instances-sql-server">
        Enumerating Instances of SQL Server
      </seealso>      
        </member>
        <member name="T:Microsoft.Data.SqlTypes.SqlFileStream">
            <summary>
        Exposes SQL Server data that is stored with the FILESTREAM column attribute as a sequence of bytes.
      </summary><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> class is used to work with VARBINARY(MAX) data stored with the FILESTREAM attribute in a SQL Server 2008 database. You must install the .NET Framework 3.5 SP1 (or later) to use <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> to work with FILESTREAM data.
        </para>
        <para>
          Specifying the FILESTREAM attribute on a VARBINARY(MAX) column causes SQL Server to store the data in the local NTFS file system instead of in the database file. Transact-SQL statements provide data manipulation capabilities within the server, and Win32 file system interfaces provide streaming access to the data.
        </para>
        <note type="note">
          Individual files stored in a FILESTREAM column cannot be opened directly from the NTFS file system. Streaming FILESTREAM data works only in the context of a SQL Server transaction.
        </note>
        <para>
          The <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> class is derived from the <see cref="T:System.IO.Stream" /> class, which represents an abstraction of a sequence of bytes from some arbitrary data source such as a file or a block of memory. You can read from a FILESTREAM by transferring data from a stream into a data structure such as an array of bytes. You can write to a FILESTREAM by transferring the data from a data structure into a stream. You can also seek within the stream, which allows you to query and modify data at the current position within the stream.
        </para>
        <para>
          For conceptual documentation and code examples, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">FILESTREAM Data</see>.
        </para>
        <para>
          For documentation about setting up and configuring FILESTREAM data on SQL Server, see <see href="https://go.microsoft.com/fwlink/?LinkId=121499">Designing and Implementing FILESTREAM Storage</see> in SQL Server 2008 Books Online.
        </para>
      </remarks><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-data-type-mappings">
        SQL Server Data Type Mappings (ADO.NET)
      </seealso><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/sql-server-binary-large-value-data">
        SQL Server Binary and Large-Value Data (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess)">
            <param name="path">
        The logical path to the file. The path can be retrieved by using the Transact-SQL Pathname function on the underlying FILESTREAM column in the table.
      </param><param name="transactionContext">
        The transaction context for the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> object. Applications should return the byte array returned by calling the GET_FILESTREAM_TRANSACTION_CONTEXT method.
      </param><param name="access">
        <para>
          The access mode to use when opening the file. Supported <see cref="T:System.IO.FileAccess" /> enumeration values are <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, and <see cref="F:System.IO.FileAccess.ReadWrite" />.
        </para>
        <para>
          When using <see cref="F:System.IO.FileAccess.Read" />, the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> object can be used to read all the existing data.
        </para>
        <para>
          When using <see cref="F:System.IO.FileAccess.Write" />, <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> points to a zero byte file. Existing data will be overwritten when the object is closed and the transaction is committed.
        </para>
        <para>
          When using <see cref="F:System.IO.FileAccess.ReadWrite" />, the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> points to a file which has all the existing data in it. The handle is positioned at the beginning of the file. You can use one of the <see cref="M:System.IO.Stream.Seek" /> methods to move the handle position within the file to write or append new data.
        </para>         
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> class.
      </summary><remarks>
        <para>
          The following table lists the code access security (CAS) permissions that all callers in the stack must have to use the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> constructors.
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>File access</term>
              <description>Permission</description>
            </listheader>
            <item>
              <term>Read</term>
              <description><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></description>
            </item>
            <item>
              <term>Write</term>
              <description><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></description>
            </item>
            <item>
              <term>ReadWrite</term>
              <description>
                <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />
              </description>
            </item>
          </list>
        </para>
        <para>
          For more information about CAS, see <see href="https://learn.microsoft.com/dotnet/framework/data/adonet/code-access-security">Code Access Security and ADO.NET</see>.
        </para>
        <para>
          If an exception is thrown, any open transactions should be rolled back. Otherwise, data loss can occur.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        <paramref name="path" /> is a null reference, or <paramref name="transactionContext" /> is null.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters. <paramref name="path" /> begins with "\\\\.\\", for example "\\\\.\PHYSICALDRIVE0 ".
        </para>
        <para>
          The handle returned by the call to NTCreateFile is not of type FILE_TYPE_DISK. <paramref name="path" /> contains an unsupported value.
        </para>
      </exception><exception cref="T:System.IO.FileNotFoundException">
        The file cannot be found.
      </exception><exception cref="T:System.IO.IOException">
        An I/O error occurred.
      </exception><exception cref="T:System.Security.SecurityException">
        The caller does not have the required permission.
      </exception><exception cref="T:System.IO.DirectoryNotFoundException">
        The specified <paramref name="path" /> is invalid, such as being on an unmapped drive.
      </exception><exception cref="T:System.UnauthorizedAccessException">
        The access requested is not permitted by the operating system for the specified path. This occurs when Write or ReadWrite access is specified, and the file or directory is set for read-only access.
      </exception><exception cref="T:System.InvalidOperationException">
        NtCreateFile fails with error code set to ERROR_SHARING_VIOLATION.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess,System.IO.FileOptions,System.Int64)">
            <param name="path">
        The logical path to the file. The path can be retrieved by using the Transact-SQL Pathname function on the underlying FILESTREAM column in the table.
      </param><param name="transactionContext">
        The transaction context for the <see langword="SqlFileStream" /> object. When set to null, an implicit transaction will be used for the <see langword="SqlFileStream" /> object. Applications should return the byte array returned by calling the GET_FILESTREAM_TRANSACTION_CONTEXT method.
      </param><param name="access">
        The access mode to use when opening the file. Supported <see cref="T:System.IO.FileAccess" /> enumeration values are <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, and <see cref="F:System.IO.FileAccess.ReadWrite" />. When using <see langword="FileAccess.Read" />, the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> object can be used to read all the existing data.  When using <see langword="FileAccess.Write" />, <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> points to a zero byte file. Existing data will be overwritten when the object is closed and the transaction is committed.  When using <see langword="FileAccess.ReadWrite" />, the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> points to a file which has all the existing data in it. The handle is positioned at the beginning of the file. You can use one of the <see cref="M:System.IO.Stream.Seek" /> methods to move the handle position within the file to write or append new data.
      </param><param name="options">
        Specifies the option to use while opening the file. Supported <see cref="T:System.IO.FileOptions" /> values are <see cref="F:System.IO.FileOptions.Asynchronous" />, <see cref="F:System.IO.FileOptions.WriteThrough" />, <see cref="F:System.IO.FileOptions.SequentialScan" />, and <see cref="F:System.IO.FileOptions.RandomAccess" />.
      </param><param name="allocationSize">
        The allocation size to use while creating a file. If set to 0, the default value is used.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> class.
      </summary><remarks>
        <para>
          The following table lists the code access security (CAS) permissions that all callers in the stack must have to use the <c>SqlFileStream</c> constructors.
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>File access</term>
              <description>Permission</description>
            </listheader>
            <item>
              <term>Read</term>
              <description><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></description>
            </item>
            <item>
              <term>Write</term>
              <description><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></description>
            </item>
            <item>
              <term>ReadWrite</term>
              <description>
                <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />
              </description>
            </item>
          </list>
        </para>
        <para>
          For more information about CAS, see <see href="https://learn.microsoft.com/dotnet/framework/data/adonet/code-access-security">Code Access Security and ADO.NET</see>.
        </para>
        <para>
          If an exception is thrown, any open transactions should be rolled back. Otherwise, data loss can occur.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        <paramref name="path" /> is a null reference, or <paramref name="transactionContext" /> is null.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters. <paramref name="path" /> begins with "\\\\.\\", for example "\\\\.\PHYSICALDRIVE0 "
        </para>
        <para>
          The handle returned by call to NTCreateFile is not of type FILE_TYPE_DISK. <paramref name="options" /> contains an unsupported value.
        </para>
     </exception><exception cref="T:System.IO.FileNotFoundException">
        The file cannot be found.
      </exception><exception cref="T:System.IO.IOException">
        An I/O error occurred.
      </exception><exception cref="T:System.Security.SecurityException">
        The caller does not have the required permission.
      </exception><exception cref="T:System.IO.DirectoryNotFoundException">
        The specified <paramref name="path" /> is invalid, such as being on an unmapped drive.
      </exception><exception cref="T:System.UnauthorizedAccessException">
        The access requested is not permitted by the operating system for the specified path. This occurs when Write or ReadWrite access is specified, and the file or directory is set for read-only access.
      </exception><exception cref="T:System.InvalidOperationException">
        NtCreateFile fails with error code set to ERROR_SHARING_VIOLATION.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.Name">
            <summary>
        Gets the logical path of the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> passed to the constructor.
      </summary><value>
        A string value indicating the name of the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" />.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.TransactionContext">
            <summary>
        Gets or sets the transaction context for this <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> object.
      </summary><value>
        The <b>TransactionContext</b> array that was passed to the constructor for this <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" /> object.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.CanRead">
            <summary>
        Gets a value indicating whether the current stream supports reading.
      </summary><value>
        <see langword="true" /> if the current stream supports reading; otherwise, <see langword="false" />.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.CanSeek">
            <summary>
        Gets a value indicating whether the current stream supports seeking.
      </summary><value>
        <see langword="true" /> if the current stream supports seeking; otherwise, <see langword="false" />.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.CanTimeout">
            <summary>
        Gets a value indicating whether the current stream can time out.
      </summary><value>
        <see langword="true" /> if the current stream can time out; otherwise, <see langword="false" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.CanWrite">
            <summary>
        Gets a value indicating whether the current stream supports writing.
      </summary><value>
        <see langword="true" /> if the current stream supports writing; otherwise, <see langword="false" />.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.Length">
            <summary>
        Gets a value indicating the length of the current stream in bytes.
      </summary><value>
        An <see cref="T:System.Int64" /> indicating the length of the current stream in bytes.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.Position">
            <summary>
        Gets or sets the position within the current stream.
      </summary><value>
        The current position within the <see cref="T:Microsoft.Data.SqlTypes.SqlFileStream" />.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.ReadTimeout">
            <summary>
        Gets or sets a value, in milliseconds, that determines how long the stream will attempt to read before timing out.
      </summary><value>
        A value, in milliseconds, that determines how long the stream will attempt to read before timing out.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlFileStream.WriteTimeout">
            <summary>
        Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out.
      </summary><value>
        A value, in milliseconds, that determines how long the stream will attempt to write before timing out.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.Flush">
            <summary>
        Clears all buffers for this stream and causes any buffered data to be written to the underlying device.
      </summary><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <param name="buffer">
        The buffer to read the data into.
      </param><param name="offset">
        The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.
      </param><param name="count">
        The maximum number of bytes to read.
      </param><param name="callback">
        An optional asynchronous callback, to be called when the read is complete.
      </param><param name="state">
        A user-provided object that distinguishes this particular asynchronous read request from other requests
      </param><summary>
        Begins an asynchronous read operation.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that represents the asynchronous read, which could still be pending.
      </returns><remarks>
        Use the <see cref="P:Microsoft.Data.SqlTypes.SqlFileStream.CanRead" /> property to determine whether the current instance supports reading.
      </remarks><exception cref="T:System.NotSupportedException">
        Reading data is not supported on the stream.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.EndRead(System.IAsyncResult)">
            <param name="asyncResult">
        The reference to the pending asynchronous request to finish.
      </param><summary>
        Waits for the pending asynchronous read to complete.
      </summary><returns>
        The number of bytes read from the stream, between zero (0) and the number of bytes you requested. Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.
      </returns><exception cref="T:System.ArgumentException">
        The <see cref="T:System.IAsyncResult" /> object did not come from the corresponding <see cref="M:Microsoft.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <param name="buffer">
        The buffer to write data from.
      </param><param name="offset">
        The byte offset in <paramref name="buffer" /> from which to begin writing.
      </param><param name="count">
        The maximum number of bytes to write.
      </param><param name="callback">
        An optional asynchronous callback, to be called when the write is complete.
      </param><param name="state">
        A user-provided object that distinguishes this particular asynchronous write request from other requests.
      </param><summary>
        Begins an asynchronous write operation.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that represents the asynchronous write, which could still be pending.
      </returns><remarks>
        Use the <see cref="P:Microsoft.Data.SqlTypes.SqlFileStream.CanWrite" /> property to determine whether the current instance supports writing.
      </remarks><exception cref="T:System.NotSupportedException">
        Writing data is not supported on the stream.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.EndWrite(System.IAsyncResult)">
            <param name="asyncResult">
        A reference to the outstanding asynchronous I/O request.
      </param><summary>
        Ends an asynchronous write operation.
      </summary><exception cref="T:System.ArgumentException">
        The <see cref="T:System.IAsyncResult" /> object did not come from the corresponding <see cref="M:Microsoft.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <param name="offset">
        A byte offset relative to the <paramref name="origin" /> parameter
      </param><param name="origin">
        A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position
      </param><summary>
        Sets the position within the current stream.
      </summary><returns>
        The new position within the current stream.
      </returns><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.SetLength(System.Int64)">
            <param name="value">
        The desired length of the current stream in bytes.
      </param><summary>
        Sets the length of the current stream.
      </summary><remarks>
        Use the <see cref="P:Microsoft.Data.SqlTypes.SqlFileStream.CanRead" /> property to determine whether the current instance supports reading.
      </remarks><exception cref="T:System.NotSupportedException">
        The object does not support reading of data.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.Read(System.Byte[],System.Int32,System.Int32)">
            <param name="buffer">
        An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.
      </param><param name="offset">
        The zero-based byte offset in buffer at which to begin storing the data read from the current stream.
      </param><param name="count">
        The maximum number of bytes to be read from the current stream.
      </param><summary>
        Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
      </summary><returns>
        The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
      </returns><remarks>
        Use the <see cref="P:Microsoft.Data.SqlTypes.SqlFileStream.CanRead" /> property to determine whether the current instance supports writing.
      </remarks><exception cref="T:System.NotSupportedException">
        The object does not support reading of data.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.ReadByte">
            <summary>
        Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
      </summary><returns>
        The unsigned byte cast to an <see cref="T:System.Int32" />, or -1 if at the end of the stream.
      </returns><remarks>
        Use the <see cref="P:Microsoft.Data.SqlTypes.SqlFileStream.CanRead" /> property to determine whether the current instance supports reading.
      </remarks><exception cref="T:System.NotSupportedException">
        The object does not support reading of data.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.Write(System.Byte[],System.Int32,System.Int32)">
            <param name="buffer">
        An array of bytes. This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream.
      </param><param name="offset">
        The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.
      </param><param name="count">
        The number of bytes to be written to the current stream.
      </param><summary>
        Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
      </summary><remarks>
        Use the <see cref="P:Microsoft.Data.SqlTypes.SqlFileStream.CanWrite" /> property to determine whether the current instance supports writing.
      </remarks><exception cref="T:System.NotSupportedException">
        The object does not support writing of data.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlFileStream.WriteByte(System.Byte)">
            <param name="value">
        The byte to write to the stream.
      </param><summary>
        Writes a byte to the current position in the stream and advances the position within the stream by one byte.
      </summary><remarks>
        Use the <see cref="P:Microsoft.Data.SqlTypes.SqlFileStream.CanWrite" /> property to determine whether the current instance supports writing.
      </remarks><exception cref="T:System.NotSupportedException">
        The object does not support writing of data.
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/sql/filestream-data">
        FILESTREAM Data in SQL Server 2008 (ADO.NET)
      </seealso>
        </member>
        <member name="T:Microsoft.Data.SqlTypes.SqlJson">
            <summary>Represents the JSON datatype in SQL Server.</summary>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlJson.#ctor">
            <summary>Parameterless constructor. Initializes a new instance of the SqlJson class which represents a null JSON value.</summary>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlJson.#ctor(System.String)">
            <param name="jsonString" /><summary>Takes a <see cref="T:System.String" /> as input and initializes a new instance of the SqlJson class.</summary>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlJson.#ctor(System.Text.Json.JsonDocument)">
            <param name="jsonDoc" /><summary>Takes a <see cref="T:System.Text.Json.JsonDocument" /> as input and initializes a new instance of the SqlJson class.</summary>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlJson.IsNull">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlJson.Null">
            <summary>Represents a null instance of the <see cref="T:Microsoft.Data.SqlTypes.SqlJson" /> type.</summary>
        </member>
        <member name="P:Microsoft.Data.SqlTypes.SqlJson.Value">
            <summary>Gets the string representation of the Json content of this <see cref="T:Microsoft.Data.SqlTypes.SqlJson" /> instance.</summary>
        </member>
        <member name="M:Microsoft.Data.SqlTypes.SqlJson.GetSqlJson(System.Int32)">
            <param name="i" /><summary>Retrieves the column at ordinal as a <see cref="T:Microsoft.Data.SqlTypes.SqlJson" />.</summary><returns>A <see cref="T:Microsoft.Data.SqlTypes.SqlJson" /> object representing the column at the given ordinal.</returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider">
            <summary>
        This class implements <see cref="T:Microsoft.Data.SqlClient.SqlAuthenticationProvider" /> and is used for active directory federated authentication mechanisms.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.#ctor">
            <summary>
        Initializes the <see cref="T:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider" /> class.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.#ctor(System.String)">
            <param name="applicationClientId">
        Client Application Id to be used for acquiring an access token for federated authentication. The driver uses its own application client id by default.
      </param><summary>
        Initializes the <see cref="T:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider" /> class with the provided application client id.
      </summary><example>
        The following example demonstrates providing a user-defined application client id to SqlClient for the "Active Directory Interactive" authentication method:
        <code language="c#">
          using System;
          using Microsoft.Data.SqlClient;

          namespace CustomAuthenticationProviderExamples
          {
            public class Program
            {
              public static void Main()
              {
                // Supported for all authentication modes supported by ActiveDirectoryAuthenticationProvider
                ActiveDirectoryAuthenticationProvider provider = new ActiveDirectoryAuthenticationProvider("&lt;application_client_id&gt;");
                if (provider.IsSupported(SqlAuthenticationMethod.ActiveDirectoryInteractive))
                {
                  SqlAuthenticationProvider.SetProvider(SqlAuthenticationMethod.ActiveDirectoryInteractive, provider);
                }

                using (SqlConnection sqlConnection = new SqlConnection("Server=&lt;myserver&gt;.database.windows.net;Authentication=Active Directory Interactive;Database=&gt;db&lt;;"))
                {
                  sqlConnection.Open();
                  Console.WriteLine("Connected successfully!");
                }
              }
            }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.ClearUserTokenCache">
            <summary>
        Clears cached user tokens from the token provider.
      </summary><remarks>
        This will cause interactive authentication prompts to appear again if tokens were previously being obtained from the cache.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.#ctor(System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task},System.String)">
            <param name="deviceCodeFlowCallbackMethod">
        The callback method to be used with 'Active Directory Device Code Flow' authentication.
      </param><param name="applicationClientId">
        (Optional) Client Application Id to be used for acquiring an access token for federated authentication. The driver uses its own application client id by default.
      </param><summary>
        Initializes the <see cref="T:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider" /> class with the provided device code flow callback method and application client id.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.AcquireTokenAsync(Microsoft.Data.SqlClient.SqlAuthenticationParameters)">
            <param name="parameters">
        The Active Directory authentication parameters passed to authentication providers.
      </param><summary>
        Acquires a security token from the authority.
      </summary><returns>
        Represents an asynchronous operation that returns the authentication token.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.SetDeviceCodeFlowCallback(System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})">
            <param name="deviceCodeFlowCallbackMethod">
        The callback method to be used with 'Active Directory Device Code Flow' authentication.
      </param><summary>
        Sets the callback method, overriding the default implementation that processes the result for 'Active Directory Device Code Flow' authentication.
      </summary><example>
        The following example demonstrates providing a custom device flow callback to SqlClient for the Device Code Flow authentication method:
        <code language="c#">
          using System;
          using System.Threading.Tasks;
          using Microsoft.Identity.Client;
          using Microsoft.Data.SqlClient;

          namespace CustomAuthenticationProviderExamples
          {
            public class Program
            {
              public static void Main()
              {
                SqlAuthenticationProvider authProvider = new ActiveDirectoryAuthenticationProvider(CustomDeviceFlowCallback);
                SqlAuthenticationProvider.SetProvider(SqlAuthenticationMethod.ActiveDirectoryDeviceCodeFlow, authProvider);
                using (SqlConnection sqlConnection = new SqlConnection("Server=&lt;myserver&gt;.database.windows.net;Authentication=Active Directory Device Code Flow;Database=&lt;db&gt;;"))
                {
                  sqlConnection.Open();
                  Console.WriteLine("Connected successfully!");
                }
              }

              private static Task CustomDeviceFlowCallback(DeviceCodeResult result)
              {
                // Provide custom logic to process result information and read device code.
                Console.WriteLine(result.Message);
                return Task.FromResult(0);
              }
            }
          }

        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.SetAcquireAuthorizationCodeAsyncCallback(System.Func{System.Uri,System.Uri,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Uri}})">
            <param name="acquireAuthorizationCodeAsyncCallback">
        The callback method to be called by MSAL.NET to delegate the Web user interface with the Secure Token Service (STS).
      </param><summary>
        Sets a callback method which is invoked with a custom Web UI instance that will let the user sign-in with Azure Active Directory, present consent if needed, and get back the authorization code. Applicable when working with Active Directory Interactive authentication.
      </summary><remarks>
        The "authorizationUri" is crafted to leverage PKCE in order to protect the token from a man in the middle attack. Only MSAL.NET can redeem the code. In the event of cancellation, the implementer should return <see cref="T:System.OperationCanceledException" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.IsSupported(Microsoft.Data.SqlClient.SqlAuthenticationMethod)">
            <param name="authentication">The authentication method.</param><summary>Indicates whether the specified authentication method is supported.</summary><returns>
        <see langword="true" /> if the specified authentication method is supported; otherwise, <see langword="false" />.
      </returns><remarks>
        The supported authentication modes with <see cref="T:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider" /> are:
        <list type="bullet">
          <item>Active Directory Password</item>
          <item>Active Directory Integrated</item>
          <item>Active Directory Interactive</item>
          <item>Active Directory Service Principal</item>
          <item>Active Directory Device Code Flow</item>
          <item>Active Directory Managed Identity</item>
          <item>Active Directory MSI</item>
          <item>Active Directory Default</item>
        </list>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.BeforeLoad(Microsoft.Data.SqlClient.SqlAuthenticationMethod)">
            <param name="authentication">
        The authentication method.
      </param><summary>
        This method is called immediately before the provider is added to authentication provider registry.
      </summary><remarks>
        Avoid performing long-waiting tasks in this method, since it can block other threads from accessing the provider registry.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.ActiveDirectoryAuthenticationProvider.BeforeUnload(Microsoft.Data.SqlClient.SqlAuthenticationMethod)">
            <param name="authentication">
        The authentication method.
      </param><summary>
        This method is called immediately before the provider is removed from the authentication provider registry.
      </summary><remarks>
        For example, this method is called when a different provider with the same authentication method overrides this provider in the authentication provider registry. Avoid performing long-waiting task in this method, since it can block other threads from accessing the provider registry.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.ApplicationIntent">
            <summary>
        Specifies a value for <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ApplicationIntent" />. Possible values are <see cref="F:Microsoft.Data.SqlClient.ApplicationIntent.ReadWrite" /> and <see cref="F:Microsoft.Data.SqlClient.ApplicationIntent.ReadOnly" />.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.ApplicationIntent.ReadOnly">
            <summary>
        The application workload type when connecting to a server is read only.
      </summary><returns>1</returns><value>1</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.ApplicationIntent.ReadWrite">
            <summary>
        The application workload type when connecting to a server is read write.
      </summary><returns>0</returns><value>0</value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.PoolBlockingPeriod">
            <summary>Specifies a value for the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.PoolBlockingPeriod" /> property.</summary><remarks>To be added.</remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.PoolBlockingPeriod.Auto">
            <summary>Blocking period OFF for Azure SQL servers, but ON for all other SQL servers.</summary><value>0</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.PoolBlockingPeriod.AlwaysBlock">
            <summary>Blocking period ON for all SQL servers including Azure SQL servers.</summary><value>1</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.PoolBlockingPeriod.NeverBlock">
            <summary>Blocking period OFF for all SQL servers, including Azure SQL servers.</summary><value>2</value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.OnChangeEventHandler">
            <OnChangeEventHandler>
      <param name="sender">The source of the event.</param>
      <param name="e">
        A <see cref="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs" /> object that contains the event data.
      </param>
      <summary>
        Handles the <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" /> event that is fired when a notification is received for any of the commands associated with a <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object.
      </summary>
      <remarks>
        The <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" /> event does not necessarily imply a change in the data. Other circumstances, such as time-out expired and failure to set the notification request, also generate <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" />.
      </remarks>
    </OnChangeEventHandler>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SortOrder">
            <summary>Specifies how rows of data are sorted.</summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SortOrder.Unspecified">
            <summary>The default. No sort order is specified.</summary><value>-1</value><returns>-1</returns>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SortOrder.Ascending">
            <summary>Rows are sorted in ascending order.</summary><value>0</value><returns>0</returns>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SortOrder.Descending">
            <summary>Rows are sorted in descending order.</summary><value>1</value><returns>1</returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlAuthenticationInitializer">
            <summary>
        Called during the opening of the first <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance to specify an Authentication connection string attribute.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationInitializer.#ctor">
            <summary>
        Default constructor to instantiate the <see cref="T:Microsoft.Data.SqlClient.SqlAuthenticationInitializer" /> class.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationInitializer.Initialize">
            <summary>
        When overridden in a derived class, initializes the authentication initializer. This method is called immediately after the <see cref="M:Microsoft.Data.SqlClient.SqlAuthenticationInitializer.#ctor" /> constructor during the opening of the first <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance to specify an Authentication connection string attribute.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlAuthenticationMethod">
            <summary>Describes the different SQL authentication methods that can be used by a client connecting to Azure SQL Database. For details, see <see href="https://learn.microsoft.com/azure/azure-sql/database/authentication-aad-overview">Use Microsoft Entra Authentication</see>.</summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.NotSpecified">
            <summary>The authentication method is not specified.</summary><value>0</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.SqlPassword">
            <summary>The authentication method uses Sql Password. Use Sql Password to connect to a SQL Database using SQL Server authentication.</summary><value>1</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryPassword">
            <summary>The authentication method uses Active Directory Password. Use Active Directory Password to connect to a SQL Database using a Microsoft Entra principal name and password.</summary><value>2</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryIntegrated">
            <summary>The authentication method uses Active Directory Integrated. Use Active Directory Integrated to connect to a SQL Database using integrated Windows authentication.</summary><value>3</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryInteractive">
            <summary>The authentication method uses Active Directory Interactive. Use Active Directory Interactive to connect to a SQL Database with an interactive authentication flow.</summary><value>4</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryServicePrincipal">
            <summary>The authentication method uses Active Directory Service Principal. Use Active Directory Service Principal to connect to a SQL Database using the client ID and secret of a service principal identity.</summary><value>5</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryDeviceCodeFlow">
            <summary>The authentication method uses Active Directory Device Code Flow. Use Active Directory Device Code Flow to connect to a SQL Database from devices and operating systems that do not provide a Web browser, using another device to perform interactive authentication.</summary><value>6</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryManagedIdentity">
            <summary>The authentication method uses Active Directory Managed Identity. Use System Assigned or User Assigned Managed Identity to connect to SQL Database from Azure client environments that have enabled support for Managed Identity. For User Assigned Managed Identity, 'User Id' or 'UID' is required to be set to the "client ID" of the user identity.</summary><value>7</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryMSI">
            <summary>Alias for "Active Directory Managed Identity" authentication method. Use System Assigned or User Assigned Managed Identity to connect to SQL Database from Azure client environments that have enabled support for Managed Identity. For User Assigned Managed Identity, 'User Id' or 'UID' is required to be set to the "client ID" of the user identity.</summary><value>8</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryDefault">
            <summary>The authentication method uses Active Directory Default. Use this mode to connect to a SQL Database using multiple non-interactive authentication methods tried sequentially to acquire an access token. This method does not fallback to the "Active Directory Interactive" authentication method.</summary><value>9</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlAuthenticationMethod.ActiveDirectoryWorkloadIdentity">
            <summary>The authentication method uses Active Directory Workload Identity. Use a federated User Assigned Managed Identity to connect to SQL Database from Azure client environments that have enabled support for Workload Identity. The 'User Id' or 'UID' is required to be set to the "client ID" of the user identity.</summary><value>10</value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlAuthenticationParameters">
            <summary>
        Represents AD authentication parameters passed by a driver to authentication providers.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationParameters.#ctor(Microsoft.Data.SqlClient.SqlAuthenticationMethod,System.String,System.String,System.String,System.String,System.String,System.String,System.Guid,System.Int32)">
            <param name="authenticationMethod">One of the enumeration values that specifies the authentication method.</param><param name="serverName">The server name.</param><param name="databaseName">The database name.</param><param name="resource">The resource URI.</param><param name="authority">The authority URI.</param><param name="userId">The user login name/ID.</param><param name="password">The user password.</param><param name="connectionId">The connection ID.</param><param name="connectionTimeout">The connection timeout value in seconds.</param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlAuthenticationParameters" /> class using the specified authentication method, server name, database name, resource URI, authority URI, user login name/ID, user password, connection ID and connection timeout value.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.AuthenticationMethod">
            <summary>Gets the authentication method.</summary><value>The authentication method.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.Authority">
            <summary>Gets the authority URI.</summary><value>The authority URI.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.ConnectionId">
            <summary>Gets the connection ID.</summary><value>The connection ID.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.DatabaseName">
            <summary>Gets the database name.</summary><value>The database name.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.Password">
            <summary>Gets the user password.</summary><value>The user password.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.Resource">
            <summary>The resource URIs.</summary><value>The resource URI.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.ServerName">
            <summary>Gets the server name.</summary><value>The server name.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.UserId">
            <summary>Gets the user login name/ID.</summary><value>The user login name/ID.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationParameters.ConnectionTimeout">
            <summary>Gets the connection timeout value.</summary><value>The connection timeout value to be passed to Cancellation Token Source.</value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlAuthenticationProvider">
            <summary>Defines the core behavior of authentication providers and provides a base class for derived classes.</summary><remarks>
        Derived classes must provide a parameterless constructor if they can be instantiated from the app.config file.
      </remarks><example>
        The following example demonstrates implementing a custom SqlAuthenticationProvider and providing the same to SqlClient for overriding Device Code Flow authentication mode:
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Linq;
          using System.Threading.Tasks;
          using Microsoft.Data.SqlClient;
          using Microsoft.Identity.Client;

          namespace CustomAuthenticationProviderExamples
          {
              /// &lt;summary&gt;
              /// Example demonstrating creating a custom device code flow authentication provider and attaching it to the driver.
              /// This is helpful for applications that wish to override the Callback for the Device Code Result implemented by the SqlClient driver.
              /// &lt;/summary&gt;
              public class CustomDeviceCodeFlowAzureAuthenticationProvider : SqlAuthenticationProvider
              {
                  private const string ClientId = "my-client-id";
                  private const string ClientName = "My Application Name";
                  private const string DefaultScopeSuffix = "/.default";

                  // Maintain a copy of the PublicClientApplication object to cache the underlying access tokens it provides
                  private static IPublicClientApplication pcApplication;

                  public override async Task&lt;SqlAuthenticationToken&gt; AcquireTokenAsync(SqlAuthenticationParameters parameters)
                  {
                      string[] scopes = [ parameters.Resource.EndsWith(DefaultScopeSuffix) ? parameters.Resource : parameters.Resource + DefaultScopeSuffix ];

                      IPublicClientApplication app = pcApplication;
                      if (app == null)
                      {
                          pcApplication = app = PublicClientApplicationBuilder.Create(ClientId)
                              .WithAuthority(parameters.Authority)
                              .WithClientName(ClientName)
                              .WithRedirectUri("https://login.microsoftonline.com/common/oauth2/nativeclient")
                              .Build();
                      }

                      AuthenticationResult result;
                      using CancellationTokenSource connectionTimeoutCancellation = new CancellationTokenSource(TimeSpan.FromSeconds(parameters.ConnectionTimeout));

                      try
                      {
                          IEnumerable&lt;IAccount&gt; accounts = await app.GetAccountsAsync();
                          result = await app.AcquireTokenSilent(scopes, accounts.FirstOrDefault())
                              .ExecuteAsync(connectionTimeoutCancellation.Token);
                      }
                      catch (MsalUiRequiredException)
                      {
                          result = await app.AcquireTokenWithDeviceCode(scopes, deviceCodeResult =&gt; CustomDeviceFlowCallback(deviceCodeResult))
                              .ExecuteAsync(connectionTimeoutCancellation.Token);
                      }

                      return new SqlAuthenticationToken(result.AccessToken, result.ExpiresOn);
                  }

                  public override bool IsSupported(SqlAuthenticationMethod authenticationMethod) =&gt;
                      authenticationMethod.Equals(SqlAuthenticationMethod.ActiveDirectoryDeviceCodeFlow);

                  private Task CustomDeviceFlowCallback(DeviceCodeResult result)
                  {
                      Console.WriteLine(result.Message);
                      return Task.CompletedTask;
                  }
              }

              public class Program
              {
                  public static void Main()
                  {
                      // Register our custom authentication provider class to override Active Directory Device Code Flow
                      SqlAuthenticationProvider.SetProvider(SqlAuthenticationMethod.ActiveDirectoryDeviceCodeFlow, new CustomDeviceCodeFlowAzureAuthenticationProvider());
                      using (SqlConnection sqlConnection = new SqlConnection("Server=&lt;myserver&gt;.database.windows.net;Authentication=Active Directory Device Code Flow;Database=&lt;db&gt;;"))
                      {
                          sqlConnection.Open();
                          Console.WriteLine("Connected successfully!");
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationProvider.#ctor">
            <summary>
        Called from constructors in derived classes to initialize the <see cref="T:Microsoft.Data.SqlClient.SqlAuthenticationProvider" /> class.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationProvider.AcquireTokenAsync(Microsoft.Data.SqlClient.SqlAuthenticationParameters)">
            <param name="parameters">The Active Directory authentication parameters passed by the driver to authentication providers.</param><summary>Acquires a security token from the authority.</summary><returns>Represents an asynchronous operation that returns the AD authentication token.</returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationProvider.BeforeLoad(Microsoft.Data.SqlClient.SqlAuthenticationMethod)">
            <param name="authenticationMethod">The authentication method.</param><summary>This method is called immediately before the provider is added to the SQL authentication provider registry.</summary><remarks>
        Avoid performing long-waiting tasks in this method, since it can block other threads from accessing the provider registry.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationProvider.BeforeUnload(Microsoft.Data.SqlClient.SqlAuthenticationMethod)">
            <param name="authenticationMethod">The authentication method.</param><summary>This method is called immediately before the provider is removed from the SQL authentication provider registry.</summary><remarks>
        For example, this method is called when a different provider with the same authentication method overrides this provider in the SQL authentication provider registry. Avoid performing long-waiting task in this method, since it can block other threads from accessing the provider registry.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationProvider.GetProvider(Microsoft.Data.SqlClient.SqlAuthenticationMethod)">
            <param name="authenticationMethod">The authentication method.</param><summary>Gets an authentication provider by method.</summary><returns>The authentication provider or <see langword="null" /> if not found.</returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationProvider.IsSupported(Microsoft.Data.SqlClient.SqlAuthenticationMethod)">
            <param name="authenticationMethod">The authentication method.</param><summary>Indicates whether the specified authentication method is supported.</summary><returns>
        <see langword="true" /> if the specified authentication method is supported; otherwise, <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationProvider.SetProvider(Microsoft.Data.SqlClient.SqlAuthenticationMethod,Microsoft.Data.SqlClient.SqlAuthenticationProvider)">
            <param name="authenticationMethod">The authentication method.</param><param name="provider">The authentication provider.</param><summary>Sets an authentication provider by method.</summary><returns>
        <see langword="true" /> if the operation succeeded; otherwise, <see langword="false" /> (for example, the existing provider disallows overriding).
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlAuthenticationToken">
            <summary>Represents an authentication token.</summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlAuthenticationToken.#ctor(System.String,System.DateTimeOffset)">
            <param name="accessToken">The access token.</param><param name="expiresOn">The token expiration time.</param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlAuthenticationToken" /> class.
      </summary><exception cref="T:System.ArgumentNullException">
        The <paramref name="accessToken" /> parameter is <see langword="null" /> or empty.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationToken.AccessToken">
            <summary>Gets the token string.</summary><value>The token string.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlAuthenticationToken.ExpiresOn">
            <summary>Gets the token expiration time.</summary><value>The token expiration time.</value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBulkCopy">
            <summary>
        Lets you efficiently bulk load a SQL Server table with data from another source.
      </summary><remarks>
        Microsoft SQL Server includes a popular command-prompt utility named <b>bcp</b> for moving data from one table to another, whether on a single server or between servers. The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class lets you write managed code solutions that provide similar functionality. There are other ways to load data into a SQL Server table (INSERT statements, for example), but <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> offers a significant performance advantage over them. The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class can be used to write data only to SQL Server tables. However, the data source is not limited to SQL Server; any data source can be used, as long as the data can be loaded to a <see cref="T:System.Data.DataTable" /> instance or read with a <see cref="T:System.Data.IDataReader" /> instance. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> will fail when bulk loading a <see cref="T:System.Data.DataTable" /> column of type <see cref="T:System.Data.SqlTypes.SqlDateTime" /> into a SQL Server column whose type is one of the date/time types added in SQL Server 2008.
      </remarks><example>
        The following console application demonstrates how to load data using the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class. In this example, a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is used to copy data from the <b>Production.Product</b> table in the SQL Server <b>AdventureWorks</b> database to a similar table in the same database.
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();

                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);

                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();

                      // Open the destination connection. In the real world you would
                      // not use SqlBulkCopy to move data from one table to the other
                      // in the same database. This is for demonstration purposes only.
                      using (SqlConnection destinationConnection = new SqlConnection(connectionString))
                      {
                          destinationConnection.Open();

                          // Set up the bulk copy object.
                          // Note that the column positions in the source
                          // data reader match the column positions in
                          // the destination table so there is no need to
                          // map columns.
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(destinationConnection))
                          {
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";

                              try
                              {
                                  // Write from the source to the destination.
                                  bulkCopy.WriteToServer(reader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  // Close the SqlDataReader. The SqlBulkCopy
                                  // object is automatically closed at the end
                                  // of the using block.
                                  reader.Close();
                              }
                          }

                          // Perform a final count on the destination
                          // table to see how many rows were added.
                          long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                          Console.WriteLine("Ending row count = {0}", countEnd);
                          Console.WriteLine("{0} rows were added.", countEnd - countStart);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }

              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(Microsoft.Data.SqlClient.SqlConnection)">
            <param name="connection">
        The already open <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance that will be used to perform the bulk copy operation. If your connection string does not use <see langword="Integrated Security = true" />, you can use <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class using the specified open instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />.
      </summary><remarks>
        Because the connection is already open when the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance is initialized, the connection remains open after the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance is closed. If the <c>connection</c> argument is null, an <see cref="T:System.ArgumentNullException" /> is thrown.    
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data using a connection that is already open. In this example, a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is used to copy data from the <b>Production.Product</b> table in the SQL Server <b>AdventureWorks</b> database to a similar table in the same database. This example is for demonstration purposes only. You would not use <c>SqlBulkCopy</c> to move data from one table to another in the same database in a production application. Note that the source data does not have to be located on SQL Server; you can use any data source that can be read to an <see cref="T:System.Data.IDataReader" /> or loaded to a <see cref="T:System.Data.DataTable" />.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();

                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);

                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();

                      // Open the destination connection. In the real world you would
                      // not use SqlBulkCopy to move data from one table to the other
                      // in the same database. This is for demonstration purposes only.
                      using (SqlConnection destinationConnection = new SqlConnection(connectionString))
                      {
                          destinationConnection.Open();

                          // Set up the bulk copy object.
                          // Note that the column positions in the source
                          // data reader match the column positions in
                          // the destination table so there is no need to
                          // map columns.
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(destinationConnection))
                          {
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";

                              try
                              {
                                  // Write from the source to the destination.
                                  bulkCopy.WriteToServer(reader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  // Close the SqlDataReader. The SqlBulkCopy
                                  // object is automatically closed at the end
                                  // of the using block.
                                  reader.Close();
                              }
                          }

                          // Perform a final count on the destination
                          // table to see how many rows were added.
                          long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                          Console.WriteLine("Ending row count = {0}", countEnd);
                          Console.WriteLine("{0} rows were added.", countEnd - countStart);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }

              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlBulkCopyOptions,Microsoft.Data.SqlClient.SqlTransaction)">
            <param name="connection">
        The already open <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance that will be used to perform the bulk copy. If your connection string does not use <see langword="Integrated Security = true" />, you can use <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.
      </param><param name="copyOptions">
        A combination of values from the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyOptions" /> enumeration that determines which data source rows are copied to the destination table.
      </param><param name="externalTransaction">
        An existing <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> instance under which the bulk copy will occur.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class using the supplied existing open instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance behaves according to options supplied in the <paramref name="copyOptions" /> parameter. If a non-null <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> is supplied, the copy operations will be performed within that transaction.
      </summary><remarks>
        If options include <see cref="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction" /> and the <paramref name="externalTransaction" /> argument is not <see langword="null" />, an <b>InvalidArgumentException</b> is thrown.
      </remarks><example>
        For examples demonstrating how to use <c>SqlBulkCopy</c> in a transaction, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/transaction-bulk-copy-operations">Transaction and Bulk Copy Operations</see>.
      </example><related type="Article" href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-operations-sql-server">
        Performing Bulk Copy Operations
      </related><related type="Article" href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </related>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(System.String)">
            <param name="connectionString">
        <para>
          The string defining the connection that will be opened for use by the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance.  
        </para>
        <para>
          If your connection string does not use <see langword="Integrated Security = true" />, you can use <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(Microsoft.Data.SqlClient.SqlConnection)" /> or <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlBulkCopyOptions,Microsoft.Data.SqlClient.SqlTransaction)" /> and <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string. 
        </para>
      </param><summary>
        Initializes and opens a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> based on the supplied <paramref name="connectionString" />. The constructor uses the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> to initialize a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class.
      </summary><remarks>
        The connection is automatically closed at the end of the bulk copy operation. If <paramref name="connectionString" /> is <see langword="null" /> , an <see cref="T:System.ArgumentNullException" /> is thrown. If <paramref name="connectionString" /> is an empty string, an <see cref="T:System.ArgumentException" /> is thrown.
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data by using a connection specified as a string. The connection is automatically closed when the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance is closed. In this example, the source data is first read from a SQL Server table to a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance. The source data does not have to be located on SQL Server; you can use any data source that can be read to an <see cref="T:System.Data.IDataReader" /> or loaded to a <see cref="T:System.Data.DataTable" />.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
          
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();

                  // Perform an initial count on the destination table.
                  SqlCommand commandRowCount = new SqlCommand(
                      "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                      sourceConnection);
                  long countStart = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);

                  // Get data from the source table as a SqlDataReader.
                  SqlCommand commandSourceData = new SqlCommand(
                      "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                      sourceConnection);
                  SqlDataReader reader = commandSourceData.ExecuteReader();

                  // Set up the bulk copy object using a connection string.
                  // In the real world you would not use SqlBulkCopy to move
                  // data from one table to the other in the same database.
                  using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                  {
                      bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";

                      try
                      {
                          // Write from the source to the destination.
                          bulkCopy.WriteToServer(reader);
                      }
                      catch (Exception ex)
                      {
                          Console.WriteLine(ex.Message);
                      }
                      finally
                      {
                          // Close the SqlDataReader. The SqlBulkCopy
                          // object is automatically closed at the end
                          // of the using block.
                          reader.Close();
                      }
                  }

                  // Perform a final count on the destination
                  // table to see how many rows were added.
                  long countEnd = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                  Console.WriteLine("Ending row count = {0}", countEnd);
                  Console.WriteLine("{0} rows were added.", countEnd - countStart);
                  Console.WriteLine("Press Enter to finish.");
                  Console.ReadLine();
              }
          }

          private static string GetConnectionString()
          {
              // To avoid storing the sourceConnection string in your code,
              // you can retrieve it from a configuration file.
              return "Data Source=(local); " +
                     " Integrated Security=true;" +
                     "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        If <paramref name="connectionString" /> is an empty string, an <see cref="T:System.ArgumentException" /> is thrown.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(System.String,Microsoft.Data.SqlClient.SqlBulkCopyOptions)">
            <param name="connectionString">
        The string defining the connection that will be opened for use by the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance. If your connection string does not use <see langword="Integrated Security = true" />, you can use <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(Microsoft.Data.SqlClient.SqlConnection)" /> or <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.#ctor(Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlBulkCopyOptions,Microsoft.Data.SqlClient.SqlTransaction)" /> and <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.
      </param><param name="copyOptions">
        A combination of values from the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyOptions" /> enumeration that determines which data source rows are copied to the destination table.
      </param><summary>
        Initializes and opens a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> based on the supplied <paramref name="connectionString" />. The constructor uses that <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> to initialize a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class. The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance behaves according to options supplied in the <paramref name="copyOptions" /> parameter.
      </summary><remarks>
        You can obtain detailed information about all the bulk copy options in the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyOptions" /> topic.
      </remarks><example>
        <para>
          The following console application demonstrates how to perform a bulk load by using a connection specified as a string. An option is set to use the value in the identity column of the source table when you load the destination table. In this example, the source data is first read from a SQL Server table to a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance. The source table and destination table each include an Identity column. By default, a new value for the <b>Identity</b> column is generated in the destination table for each row added. In this example, an option is set when the connection is opened that forces the bulk load process to use the <b>Identity</b> values from the source table instead. To see how the option changes the way the bulk load works, run the sample with the <b>dbo.BulkCopyDemoMatchingColumns</b> table empty. All rows load from the source. Then run the sample again without emptying the table. An exception is thrown and the code writes a message to the console notifying you that rows weren't added because of primary key constraint violations.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();

                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);

                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();

                      // Create the SqlBulkCopy object using a connection string
                      // and the KeepIdentity option.
                      // In the real world you would not use SqlBulkCopy to move
                      // data from one table to the other in the same database.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString, SqlBulkCopyOptions.KeepIdentity))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";
            
                          try
                          {
                              // Write from the source to the destination.
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
            
                      // Perform a final count on the destination
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }

              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize">
            <summary>
        Number of rows in each batch. At the end of each batch, the rows in the batch are sent to the server.
      </summary><value>
        The integer value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" /> property, or zero if no value has been set.
      </value><remarks>
        <para>
          A batch is complete when <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" /> rows have been processed or there are no more rows to send to the destination data source.
        </para>
        <para>
          Zero (the default) indicates that each <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> operation is a single batch.
        </para>
        <para>
          If the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance has been declared without the <see cref="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction" /> option in effect, rows are sent to the server <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" /> rows at a time, but no transaction-related action is taken. If <see cref="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction" /> is in effect, each batch of rows is inserted as a separate transaction.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" /> property can be set at any time. If a bulk copy is already in progress, the current batch is sized according to the previous batch size. Subsequent batches use the new size. If the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" /> is initially zero and changed while a <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> operation is already in progress, that operation loads the data as a single batch. Any subsequent <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> operations on the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance use the new <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" />.
        </para>
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data in batches of 50 rows. For an example illustrating how <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" /> works with a transaction, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/transaction-bulk-copy-operations">Transaction and Bulk Copy Operations</see>.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
        
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
            
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();
        
                      // Create the SqlBulkCopy object using a connection string.
                      // In the real world you would not use SqlBulkCopy to move
                      // data from one table to the other in the same database.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";
                
                          // Set the BatchSize.
                          bulkCopy.BatchSize = 50;
                
                          try
                          {
                              // Write from the source to the destination.
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
            
                          // Perform a final count on the destination
                          // table to see how many rows were added.
                          long countEnd = System.Convert.ToInt32(
                              commandRowCount.ExecuteScalar());
                          Console.WriteLine("Ending row count = {0}", countEnd);
                          Console.WriteLine("{0} rows were added.", countEnd - countStart);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
    
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.BulkCopyTimeout">
            <summary>
        Number of seconds for the operation to complete before it times out.
      </summary><value>
        The integer value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BulkCopyTimeout" /> property. The default is 30 seconds. A value of 0 indicates no limit; the bulk copy will wait indefinitely.
      </value><remarks>
        If the operation does time out, the transaction is not committed and all copied rows are removed from the destination table.
      </remarks><example>
        <para>
          The following console application demonstrates how to modify the time-out to 60 seconds when bulk loading data. In this example, the source data is first read from a SQL Server table to a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance. The source data does not have to be located on SQL Server; you can use any data source that can be read to an <see cref="T:System.Data.IDataReader" /> or loaded to a <see cref="T:System.Data.DataTable" />.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
        
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection =
                  new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
            
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
            
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection); 
                      SqlDataReader reader = commandSourceData.ExecuteReader();
            
                      // Create the SqlBulkCopy object using a connection string.
                      // In the real world you would not use SqlBulkCopy to move
                      // data from one table to the other in the same database.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                          "dbo.BulkCopyDemoMatchingColumns";
                
                          // Set the timeout.
                          bulkCopy.BulkCopyTimeout = 60;
                
                          try
                          {
                              // Write from the source to the destination.
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
            
                      // Perform a final count on the destination
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
    
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.EnableStreaming">
            <summary>
        Enables or disables a <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object to stream data from an <see cref="T:System.Data.IDataReader" /> object
      </summary><value>
        <see langword="true" /> if a <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object can stream data from an <see cref="T:System.Data.IDataReader" /> object; otherwise, false. The default is <see langword="false" />.
      </value><remarks>
        <para>
          When <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.EnableStreaming" /> is <see langword="true" />, <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> reads from an <see cref="T:System.Data.IDataReader" /> object using <see cref="F:System.Data.CommandBehavior.SequentialAccess" />, optimizing memory usage by using the <see cref="T:System.Data.IDataReader" /> streaming capabilities. Streaming is only applicable to max data types (i.e. VARBINARY(MAX), VARCHAR(MAX), NVARCHAR(MAX), and XML). When <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.EnableStreaming" /> is set to <see langword="false" />, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class loads all the data returned by the <see cref="T:System.Data.IDataReader" /> object into memory before sending it to the server.
        </para>
        <note type="note">
          The main advantage of enabling streaming is reducing memory usage during bulk copy of max data types.
        </note>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings">
            <summary>
        Returns a collection of <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> items. Column mappings define the relationships between columns in the data source and columns in the destination.
      </summary><value>
        A collection of column mappings. By default, it is an empty collection.
      </value><remarks>
        <para>
          If the data source and the destination table have the same number of columns, and the ordinal position of each source column within the data source matches the ordinal position of the corresponding destination column, the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection is unnecessary. However, if the column counts differ, or the ordinal positions are not consistent, you must use <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> to make sure that data is copied into the correct columns.
        </para>
        <para>
          During the execution of a bulk copy operation, this collection can be accessed, but it cannot be changed. Any attempt to change it will throw an <see cref="T:System.InvalidOperationException" />.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnOrderHints">
            <summary>
        Returns a collection of <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> items. Column order hints describe the sort order of columns in the clustered index of the destination table.
      </summary><value>
        A collection of column order hints. By default, it is an empty collection.
      </value><remarks>
        SqlBulkCopy's performance is improved if the data being imported is sorted according to the clustered index on the table, if any.  If the data is sorted in an order that differs from the order of a clustered index key or if there is no clustered index on the table, the order hint is ignored.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName">
            <summary>
        Name of the destination table on the server.
      </summary><value>
        The string value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property, or null if none as been supplied.
      </value><remarks>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> has not been set when <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> is called, an <see cref="T:System.ArgumentNullException" /> is thrown. If <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> is modified while a <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> operation is running, the change does not affect the current operation. The new <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> value is used the next time a <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method is called. 
        </para>
        <para>
          <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> is a three-part name (<c>&lt;database&gt;.&lt;owningschema&gt;.&lt;name&gt;</c>). You can qualify the table name with its database and owning schema if you choose. However, if the table name uses an underscore ("_") or any other special characters, you must escape the name using surrounding brackets as in (<c>[&lt;database&gt;.&lt;owningschema&gt;.&lt;name_01&gt;]</c>).
        </para>
        <para>
          You can bulk-copy data to a temporary table by using a value such as <c>tempdb..#table</c> or <c>tempdb.&lt;owner&gt;.#table</c> for the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property.
        </para>
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data using a connection that is already open. The destination table is a table in the <b>AdventureWorks</b> database.
        </para>
        <para>
          In this example, the connection is first used to read data from a SQL Server table to a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance. The source data does not have to be located on SQL Server; you can use any data source that can be read to an <see cref="T:System.Data.IDataReader" /> or loaded to a <see cref="T:System.Data.DataTable" />.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();

                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);

                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();

                      // Open the destination connection. In the real world you would
                      // not use SqlBulkCopy to move data from one table to the other
                      // in the same database. This is for demonstration purposes only.
                      using (SqlConnection destinationConnection = new SqlConnection(connectionString))
                      {
                          destinationConnection.Open();

                          // Set up the bulk copy object.
                          // Note that the column positions in the source
                          // data reader match the column positions in
                          // the destination table so there is no need to
                          // map columns.
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(destinationConnection))
                          {
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";

                              try
                              {
                                  // Write from the source to the destination.
                                  bulkCopy.WriteToServer(reader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  // Close the SqlDataReader. The SqlBulkCopy
                                  // object is automatically closed at the end
                                  // of the using block.
                                  reader.Close();
                              }
                          }

                          // Perform a final count on the destination
                          // table to see how many rows were added.
                          long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                          Console.WriteLine("Ending row count = {0}", countEnd);
                          Console.WriteLine("{0} rows were added.", countEnd - countStart);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }

              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter">
            <summary>
        Defines the number of rows to be processed before generating a notification event.
      </summary><value>
        The integer value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> property, or zero if the property has not been set.
      </value><remarks>
        <para>
          This property is designed for user interface components that illustrate the progress of a bulk copy operation. It indicates the number of rows to be processed before generating a notification event. The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> property can be set at any time, even while a bulk copy operation is underway. Changes made during a bulk copy operation take effect after the next notification. The new setting applies to all subsequent operations on the same instance.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> is set to a number less than zero, an <see cref="T:System.ArgumentOutOfRangeException" /> is thrown.
        </para>
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data using a connection that is already open. The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> property is set so that the event handler is called after every 50 rows copied to the table.
        </para>
        <para>
          In this example, the connection is first used to read data from a SQL Server table to a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance. Then a second connection is opened to bulk copy the data. Note that the source data does not have to be located on SQL Server; you can use any data source that can be read to an <see cref="T:System.Data.IDataReader" /> or loaded to a <see cref="T:System.Data.DataTable" />.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>. 
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
        
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("NotifyAfter Sample");
                      Console.WriteLine("Starting row count = {0}", countStart);
        
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();
        
                      // Create the SqlBulkCopy object using a connection string.
                      // In the real world you would not use SqlBulkCopy to move
                      // data from one table to the other in the same database.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";
                
                          // Set up the event handler to notify after 50 rows.
                          bulkCopy.SqlRowsCopied += new SqlRowsCopiedEventHandler(OnSqlRowsCopied);
                          bulkCopy.NotifyAfter = 50;
                
                          try
                          {
                              // Write from the source to the destination.
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
        
                      // Perform a final count on the destination
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                      }
                  }
        
              private static void OnSqlRowsCopied(object sender, SqlRowsCopiedEventArgs e)
              {
                  Console.WriteLine("Copied {0} so far...", e.RowsCopied);
              }
            
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.RowsCopied">
            <summary>
        The number of rows processed in the ongoing bulk copy operation.
      </summary><value>
        The integer value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.RowsCopied" /> property.
      </value><remarks>
        <para>
          This value is incremented during the <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" /> event and does not imply that this number of rows has been sent to the server or committed.
        </para>
        <para>
          This value can be accessed during or after the execution of a bulk copy operation.
        </para>
        <para>
          This value will wrap around and become negative if the number of rows exceeds int.MaxValue. Consider using the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.RowsCopied64" /> property.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopy.RowsCopied64">
            <summary>
        The number of rows processed in the ongoing bulk copy operation.
      </summary><value>
        The long value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.RowsCopied64" /> property.
      </value><remarks>
        <para>
          This value is incremented during the <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" /> event and does not imply that this number of rows has been sent to the server or committed.
        </para>
        <para>
          This value can be accessed during or after the execution of a bulk copy operation.
        </para>
      </remarks>
        </member>
        <member name="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied">
            <summary>
        Occurs every time that the number of rows specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> property have been processed.
      </summary><remarks>
        <para>
          Note that the settings of <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> and <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.BatchSize" /> are independent. Receipt of a <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" /> event does not imply that any rows have been sent to the server or committed.
        </para>
        <para>
          You cannot call <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.Close" /> or <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> from this event. Doing this will cause an <see cref="T:System.InvalidOperationException" /> being thrown, and the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object state will not change. If the user wants to cancel the operation from the event, the <see cref="P:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs.Abort" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs" /> can be used. (See <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/transaction-bulk-copy-operations">Transaction and Bulk Copy Operations</see> for examples that use the <see cref="P:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs.Abort" /> property.)
        </para>
        <para>
          No action, such as transaction activity, is supported in the connection during the execution of the bulk copy operation, and it is recommended that you not use the same connection used during the <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" /> event. However, you can open a different connection.
        </para>
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data using a connection that is already open. The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> property is set so that the event handler is called after every 50 rows copied to the table.
        </para>
        <para>
          In this example, the connection is first used to read data from a SQL Server table to a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance. Note that the source data does not have to be located on SQL Server; you can use any data source that can be read to an <see cref="T:System.Data.IDataReader" /> or loaded to a <see cref="T:System.Data.DataTable" />.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
        
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("NotifyAfter Sample");
                      Console.WriteLine("Starting row count = {0}", countStart);
        
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();
        
                      // Create the SqlBulkCopy object using a connection string.
                      // In the real world you would not use SqlBulkCopy to move
                      // data from one table to the other in the same database.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";
                
                          // Set up the event handler to notify after 50 rows.
                          bulkCopy.SqlRowsCopied += new SqlRowsCopiedEventHandler(OnSqlRowsCopied);
                          bulkCopy.NotifyAfter = 50;
                
                          try
                          {
                              // Write from the source to the destination.
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
        
                      // Perform a final count on the destination
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                      }
                  }
        
              private static void OnSqlRowsCopied(object sender, SqlRowsCopiedEventArgs e)
              {
                  Console.WriteLine("Copied {0} so far...", e.RowsCopied);
              }
            
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.Close">
            <summary>
        Closes the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance.
      </summary><remarks>
        After you call <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.Close" /> on the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object, no other operation will succeed. Calls to the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method will throw an <see cref="T:System.InvalidOperationException" />. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.Close" /> method from the <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" /> event causes an <see cref="T:System.InvalidOperationException" /> to be thrown. Note that open <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instances are closed implicitly at the end of a <c>using</c> block.
      </remarks><example>
        <para>
          The following example uses the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to add sales orders and their associated details to two destination tables. Because the <b>AdventureWorks</b> sales order tables are large, the sample reads only orders placed by a certain account number and bulk copies those orders and details to the destination tables. The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.Close" /> method is used only after both bulk copy operations are complete.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
            
                      // Empty the destination tables.
                      SqlCommand deleteHeader = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      deleteHeader.ExecuteNonQuery();
                      SqlCommand deleteDetail = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      deleteDetail.ExecuteNonQuery();
            
                      // Perform an initial count on the destination
                      // table with matching columns.
                      SqlCommand countRowHeader = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      long countStartHeader = System.Convert.ToInt32(
                      countRowHeader.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Header table = {0}",
                          countStartHeader);
            
                      // Perform an initial count on the destination
                      // table with different column positions.
                      SqlCommand countRowDetail = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      long countStartDetail = System.Convert.ToInt32(
                          countRowDetail.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Detail table = {0}",
                          countStartDetail);
            
                      // Get data from the source table as a SqlDataReader.
                      // The Sales.SalesOrderHeader and Sales.SalesOrderDetail
                      // tables are quite large and could easily cause a timeout
                      // if all data from the tables is added to the destination.
                      // To keep the example simple and quick, a parameter is
                      // used to select only orders for a particular account
                      // as the source for the bulk insert.
                      SqlCommand headerData = new SqlCommand(
                          "SELECT [SalesOrderID], [OrderDate], " +
                          "[AccountNumber] FROM [Sales].[SalesOrderHeader] " +
                          "WHERE [AccountNumber] = @accountNumber;",
                          connection);
                      SqlParameter parameterAccount = new SqlParameter();
                      parameterAccount.ParameterName = "@accountNumber";
                      parameterAccount.SqlDbType = SqlDbType.NVarChar;
                      parameterAccount.Direction = ParameterDirection.Input;
                      parameterAccount.Value = "10-4020-000034";
                      headerData.Parameters.Add(parameterAccount);
                      SqlDataReader readerHeader = headerData.ExecuteReader();
            
                      // Get the Detail data in a separate connection.
                      using (SqlConnection connection2 = new SqlConnection(connectionString))
                      {
                          connection2.Open();
                          SqlCommand sourceDetailData = new SqlCommand(
                              "SELECT [Sales].[SalesOrderDetail].[SalesOrderID], [SalesOrderDetailID], " +
                              "[OrderQty], [ProductID], [UnitPrice] FROM [Sales].[SalesOrderDetail] " +
                              "INNER JOIN [Sales].[SalesOrderHeader] ON [Sales].[SalesOrderDetail]." +
                              "[SalesOrderID] = [Sales].[SalesOrderHeader].[SalesOrderID] " +
                              "WHERE [AccountNumber] = @accountNumber;",
                              connection2);
                
                          SqlParameter accountDetail = new SqlParameter();
                          accountDetail.ParameterName = "@accountNumber";
                          accountDetail.SqlDbType = SqlDbType.NVarChar;
                          accountDetail.Direction = ParameterDirection.Input;
                          accountDetail.Value = "10-4020-000034";
                          sourceDetailData.Parameters.Add(accountDetail);
                          SqlDataReader readerDetail = sourceDetailData.ExecuteReader();
                
                          // Create the SqlBulkCopy object.
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                          {
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderHeader";
                
                              // Write readerHeader to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerHeader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerHeader.Close();
                              }
                
                              // Set up a different destination and
                              // map columns.
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderDetail";
                    
                              // Write readerDetail to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerDetail);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerDetail.Close();
                              }
                          }
                
                          // Perform a final count on the destination
                          // tables to see how many rows were added.
                          long countEndHeader = System.Convert.ToInt32(
                              countRowHeader.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Header table.",
                          countEndHeader - countStartHeader);
                          
                          long countEndDetail = System.Convert.ToInt32(
                              countRowDetail.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Detail table.",
                          countEndDetail - countStartDetail);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
    
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.System#IDisposable#Dispose">
            <summary>
        Releases all resources used by the current instance of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> class.
      </summary><remarks>
        <para>
          Call <c>Dispose</c> when you are finished using the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" />. The <c>Dispose</c> method leaves the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> in an unusable state. After calling <c>Dispose</c>, you must release all references to the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> so the garbage collector can reclaim the memory that the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> was occupying.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/dotnet/standard/garbage-collection/unmanaged">Cleaning Up Unmanaged Resources</see> and <see href="https://learn.microsoft.com/dotnet/standard/garbage-collection/implementing-dispose">Implementing a Dispose Method</see>.
        </para>
        <note type="note">
          Always call <c>Dispose</c> before you release your last reference to the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" />. Otherwise, the resources it is using will not be freed until the garbage collector calls the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object's <c>Finalize</c> method.
        </note>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.Common.DbDataReader)">
            <param name="reader">
        A <see cref="T:System.Data.Common.DbDataReader" /> whose rows will be copied to the destination table.
      </param><summary>
        Copies all rows from the supplied <see cref="T:System.Data.Common.DbDataReader" /> array to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><exception cref="T:System.InvalidOperationException">
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)">
            <param name="table">
        A <see cref="T:System.Data.DataTable" /> whose rows will be copied to the destination table.
      </param><summary>
        Copies all rows in the supplied <see cref="T:System.Data.DataTable" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><remarks>
        <para>
          All rows in the <see cref="T:System.Data.DataTable" /> are copied to the destination table except those that have been deleted.
        </para>
        <para>
          While the bulk copy operation is in progress, the associated destination <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is busy serving it, and no other operations can be performed on the connection.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection maps from the <see cref="T:System.Data.DataTable" /> columns to the destination database table.
        </para>
      </remarks><example>
        <para>
          The following Console application demonstrates how to bulk load data from a <see cref="T:System.Data.DataTable" />. The destination table is a table in the <b>AdventureWorks</b> database.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          In this example, a <see cref="T:System.Data.DataTable" /> is created at run time and is the source of the <c>SqlBulkCopy</c> operation.
        </para>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          connection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Create a table with some rows. 
                      DataTable newProducts = MakeTable();
          
                      // Create the SqlBulkCopy object. 
                      // Note that the column positions in the source DataTable 
                      // match the column positions in the destination table so 
                      // there is no need to map columns. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connection))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";
          
                          try
                          {
                              // Write from the source to the destination.
                              bulkCopy.WriteToServer(newProducts);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static DataTable MakeTable()
              {
                  // Create a new DataTable named NewProducts.
                  DataTable newProducts = new DataTable("NewProducts");
          
                  // Add three column objects to the table. 
                  DataColumn productID = new DataColumn();
                  productID.DataType = System.Type.GetType("System.Int32");
                  productID.ColumnName = "ProductID";
                  productID.AutoIncrement = true;
                  newProducts.Columns.Add(productID);
          
                  DataColumn productName = new DataColumn();
                  productName.DataType = System.Type.GetType("System.String");
                  productName.ColumnName = "Name";
                  newProducts.Columns.Add(productName);
          
                  DataColumn productNumber = new DataColumn();
                  productNumber.DataType = System.Type.GetType("System.String");
                  productNumber.ColumnName = "ProductNumber";
                  newProducts.Columns.Add(productNumber);
          
                  // Create an array for DataColumn objects.
                  DataColumn[] keys = new DataColumn[1];
                  keys[0] = productID;
                  newProducts.PrimaryKey = keys;
          
                  // Add some new rows to the collection. 
                  DataRow row = newProducts.NewRow();
                  row["Name"] = "CC-101-WH";
                  row["ProductNumber"] = "Cyclocomputer - White";
          
                  newProducts.Rows.Add(row);
                  row = newProducts.NewRow();
                  row["Name"] = "CC-101-BK";
                  row["ProductNumber"] = "Cyclocomputer - Black";
          
                  newProducts.Rows.Add(row);
                  row = newProducts.NewRow();
                  row["Name"] = "CC-101-ST";
                  row["ProductNumber"] = "Cyclocomputer - Stainless";
                  newProducts.Rows.Add(row);
                  newProducts.AcceptChanges();
          
                  // Return the new DataTable. 
                  return newProducts;
              }
            
              private static string GetConnectionString() 
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.
      </exception><related type="Article" href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-operations-sql-server">
        Performing Bulk Copy Operations
      </related><related type="Article" href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </related>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)">
            <param name="table">
        A <see cref="T:System.Data.DataTable" /> whose rows will be copied to the destination table.
      </param><param name="rowState">
        A value from the <see cref="T:System.Data.DataRowState" /> enumeration. Only rows matching the row state are copied to the destination.
      </param><summary>
        Copies only rows that match the supplied row state in the supplied <see cref="T:System.Data.DataTable" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><remarks>
        <para>
          Only rows in the <see cref="T:System.Data.DataTable" /> that are in the states indicated in the <paramref name="rowState" /> argument and have not been deleted are copied to the destination table.
        </para>
        <note type="note">
          If <see cref="F:System.Data.DataRowState.Deleted" /> is specified, any <see cref="F:System.Data.DataRowState.Unchanged" />, <see cref="F:System.Data.DataRowState.Added" />, and <see cref="F:System.Data.DataRowState.Modified" /> rows will also be copied to the server. No exception will be raised.
        </note>
        <para>
          While the bulk copy operation is in progress, the associated destination <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is busy serving it, and no other operations can be performed on the connection.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection maps from the <see cref="T:System.Data.DataTable" /> columns to the destination database table.
        </para>
      </remarks><example>
        <para>
          The following Console application demonstrates how to bulk load only the rows in a <see cref="T:System.Data.DataTable" /> that match a specified state. In this case, only unchanged rows are added. The destination table is a table in the <b>AdventureWorks</b> database.
        </para>
        <para>
          In this example, a <see cref="T:System.Data.DataTable" /> is created at run time and three rows are added to it. Before the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method is executed, one of the rows is edited. The <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method is called with a <see cref="F:System.Data.DataRowState.Unchanged" /> <paramref name="rowState" /> argument, so only the two unchanged rows are bulk copied to the destination.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>. This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </note>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          connection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Create a table with some rows. 
                      DataTable newProducts = MakeTable();
          
                      // Make a change to one of the rows in the DataTable.
                      DataRow row = newProducts.Rows[0];
                      row.BeginEdit();
                      row["Name"] = "AAA";
                      row.EndEdit();
          
                      // Create the SqlBulkCopy object. 
                      // Note that the column positions in the source DataTable 
                      // match the column positions in the destination table so 
                      // there is no need to map columns. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connection))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";
          
                          try
                          {
                              // Write unchanged rows from the source to the destination.
                              bulkCopy.WriteToServer(newProducts, DataRowState.Unchanged);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static DataTable MakeTable()
              {
                  // Create a new DataTable named NewProducts.
                  DataTable newProducts = new DataTable("NewProducts");
          
                  // Add three column objects to the table. 
                  DataColumn productID = new DataColumn();
                  productID.DataType = System.Type.GetType("System.Int32");
                  productID.ColumnName = "ProductID";
                  productID.AutoIncrement = true;
                  newProducts.Columns.Add(productID);
          
                  DataColumn productName = new DataColumn();
                  productName.DataType = System.Type.GetType("System.String");
                  productName.ColumnName = "Name";
                  newProducts.Columns.Add(productName);
          
                  DataColumn productNumber = new DataColumn();
                  productNumber.DataType = System.Type.GetType("System.String");
                  productNumber.ColumnName = "ProductNumber";
                  newProducts.Columns.Add(productNumber);
          
                  // Create an array for DataColumn objects.
                  DataColumn[] keys = new DataColumn[1];
                  keys[0] = productID;
                  newProducts.PrimaryKey = keys;
          
                  // Add some new rows to the collection. 
                  DataRow row = newProducts.NewRow();
                  row["Name"] = "CC-101-WH";
                  row["ProductNumber"] = "Cyclocomputer - White";
          
                  newProducts.Rows.Add(row);
                  row = newProducts.NewRow();
                  row["Name"] = "CC-101-BK";
                  row["ProductNumber"] = "Cyclocomputer - Black";
          
                  newProducts.Rows.Add(row);
                  row = newProducts.NewRow();
                  row["Name"] = "CC-101-ST";
                  row["ProductNumber"] = "Cyclocomputer - Stainless";
                  newProducts.Rows.Add(row);
                  newProducts.AcceptChanges();
          
                  // Return the new DataTable. 
                  return newProducts;
              }
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])">
            <param name="rows">
        An array of <see cref="T:System.Data.DataRow" /> objects that will be copied to the destination table.
      </param><summary>
        Copies all rows from the supplied <see cref="T:System.Data.DataRow" /> array to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><remarks>
        <para>
          While the bulk copy operation is in progress, the associated destination <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is busy serving it, and no other operations can be performed on the connection.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection maps from the <see cref="T:System.Data.DataRow" /> columns to the destination database table.
        </para>
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data from a <see cref="T:System.Data.DataRow" /> array. The destination table is a table in the <b>AdventureWorks</b> database.
        </para>
        <para>
          In this example, a <see cref="T:System.Data.DataTable" /> is created at run time. A single row is selected from the <see cref="T:System.Data.DataTable" /> to copy to the destination table.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>. This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </note>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                          connection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Create a table with some rows. 
                      DataTable newProducts = MakeTable();
          
                      // Get a reference to a single row in the table. 
                      DataRow[] rowArray = newProducts.Select("Name='CC-101-BK'");
          
                      // Create the SqlBulkCopy object. 
                      // Note that the column positions in the source DataTable 
                      // match the column positions in the destination table so 
                      // there is no need to map columns. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connection))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";
          
                          try
                          {
                              // Write the array of rows to the destination.
                              bulkCopy.WriteToServer(rowArray);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static DataTable MakeTable()
              {
                  // Create a new DataTable named NewProducts.
                  DataTable newProducts = new DataTable("NewProducts");
          
                  // Add three column objects to the table. 
                  DataColumn productID = new DataColumn();
                  productID.DataType = System.Type.GetType("System.Int32");
                  productID.ColumnName = "ProductID";
                  productID.AutoIncrement = true;
                  newProducts.Columns.Add(productID);
          
                  DataColumn productName = new DataColumn();
                  productName.DataType = System.Type.GetType("System.String");
                  productName.ColumnName = "Name";
                  newProducts.Columns.Add(productName);
          
                  DataColumn productNumber = new DataColumn();
                  productNumber.DataType = System.Type.GetType("System.String");
                  productNumber.ColumnName = "ProductNumber";
                  newProducts.Columns.Add(productNumber);
          
                  // Create an array for DataColumn objects.
                  DataColumn[] keys = new DataColumn[1];
                  keys[0] = productID;
                  newProducts.PrimaryKey = keys;
          
                  // Add some new rows to the collection. 
                  DataRow row = newProducts.NewRow();
                  row["Name"] = "CC-101-WH";
                  row["ProductNumber"] = "Cyclocomputer - White";
          
                  newProducts.Rows.Add(row);
                  row = newProducts.NewRow();
                  row["Name"] = "CC-101-BK";
                  row["ProductNumber"] = "Cyclocomputer - Black";
          
                  newProducts.Rows.Add(row);
                  row = newProducts.NewRow();
                  row["Name"] = "CC-101-ST";
                  row["ProductNumber"] = "Cyclocomputer - Stainless";
                  newProducts.Rows.Add(row);
                  newProducts.AcceptChanges();
          
                  // Return the new DataTable. 
                  return newProducts;
              }
            
              private static string GetConnectionString() 
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)">
            <param name="reader">
        A <see cref="T:System.Data.IDataReader" /> whose rows will be copied to the destination table.
      </param><summary>
        Copies all rows in the supplied <see cref="T:System.Data.IDataReader" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><remarks>
        <para>
          The copy operation starts at the next available row in the reader. Most of the time, the reader was just returned by <see cref="M:System.Data.IDbCommand.ExecuteReader" /> or a similar call, so the next available row is the first row. To process multiple results, call <see cref="M:System.Data.IDataReader.NextResult" /> on the data reader and call <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> again.
        </para>
        <para>
          Note that using <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> modifies the state of the reader. The method will call <see cref="M:System.Data.IDataReader.Read" /> until it returns false, the operation is aborted, or an error occurs. This means that the data reader will be in a different state, probably at the end of the result set, when the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> operation is complete.
        </para>
        <para>
          While the bulk copy operation is in progress, the associated destination <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is busy serving it, and no other operations can be performed on the connection.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection maps from the data reader columns to the destination database table.
        </para>
      </remarks><example>
        <para>
          The following console application demonstrates how to bulk load data from a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The destination table is a table in the <b>AdventureWorks</b> database.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>. 
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
          
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();

                  // Perform an initial count on the destination table.
                  SqlCommand commandRowCount = new SqlCommand(
                      "SELECT COUNT(*) FROM dbo.BulkCopyDemoMatchingColumns;",
                      sourceConnection);
                  long countStart = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);

                  // Get data from the source table as a SqlDataReader.
                  SqlCommand commandSourceData = new SqlCommand(
                      "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                      sourceConnection);
                  SqlDataReader reader = commandSourceData.ExecuteReader();

                  // Set up the bulk copy object using a connection string.
                  // In the real world you would not use SqlBulkCopy to move
                  // data from one table to the other in the same database.
                  using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                  {
                      bulkCopy.DestinationTableName = "dbo.BulkCopyDemoMatchingColumns";

                      try
                      {
                          // Write from the source to the destination.
                          bulkCopy.WriteToServer(reader);
                      }
                      catch (Exception ex)
                      {
                          Console.WriteLine(ex.Message);
                      }
                      finally
                      {
                          // Close the SqlDataReader. The SqlBulkCopy
                          // object is automatically closed at the end
                          // of the using block.
                          reader.Close();
                      }
                  }

                  // Perform a final count on the destination
                  // table to see how many rows were added.
                  long countEnd = System.Convert.ToInt32(
                      commandRowCount.ExecuteScalar());
                  Console.WriteLine("Ending row count = {0}", countEnd);
                  Console.WriteLine("{0} rows were added.", countEnd - countStart);
                  Console.WriteLine("Press Enter to finish.");
                  Console.ReadLine();
              }
          }

          private static string GetConnectionString()
          {
              // To avoid storing the sourceConnection string in your code,
              // you can retrieve it from a configuration file.
              return "Data Source=(local); " +
                     " Integrated Security=true;" +
                     "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader)">
            <param name="reader">
        A <see cref="T:System.Data.IDataReader" /> whose rows will be copied to the destination table.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />,
        which copies all rows in the supplied <see cref="T:System.Data.IDataReader" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>The <see cref="T:System.Data.IDataReader" /> was closed before the completed <see cref="T:System.Threading.Tasks.Task" /> returned.</item>
          <item>The <see cref="T:System.Data.IDataReader" /> 's associated connection was closed before the completed <see cref="T:System.Threading.Tasks.Task" /> returned.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader,System.Threading.CancellationToken)">
            <param name="reader">
        A <see cref="T:System.Data.Common.DbDataReader" /> whose rows will be copied to the destination table.
      </param><param name="cancellationToken">
        The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" /> value in this parameter makes this method equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader)" />.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.Common.DbDataReader)" />,
        which copies all rows from the supplied <see cref="T:System.Data.Common.DbDataReader" /> array to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
        The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])">
            <param name="rows">
        An array of <see cref="T:System.Data.DataRow" /> objects that will be copied to the destination table.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />,
        which copies all rows from the supplied <see cref="T:System.Data.DataRow" /> array to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> multiple times for the same instance before task completion. Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[],System.Threading.CancellationToken)">
            <param name="rows">
        An array of <see cref="T:System.Data.DataRow" /> objects that will be copied to the destination table.
      </param><param name="cancellationToken">
        The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" /> value in this parameter makes this method equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />,
        which copies all rows from the supplied <see cref="T:System.Data.DataRow" /> array to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
        The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)">
            <param name="table">
        A <see cref="T:System.Data.DataTable" /> whose rows will be copied to the destination table.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />,
        which copies all rows in the supplied <see cref="T:System.Data.DataTable" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)">
            <param name="table">
        A <see cref="T:System.Data.DataTable" /> whose rows will be copied to the destination table.
      </param><param name="rowState">
        A value from the <see cref="T:System.Data.DataRowState" /> enumeration. Only rows matching the row state are copied to the destination.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />,
        which copies only rows that match the supplied row state in the supplied <see cref="T:System.Data.DataTable" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState,System.Threading.CancellationToken)">
            <param name="table">
        A <see cref="T:System.Data.DataTable" /> whose rows will be copied to the destination table.
      </param><param name="rowState">
        A value from the <see cref="T:System.Data.DataRowState" /> enumeration. Only rows matching the row state are copied to the destination.
      </param><param name="cancellationToken">
        The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" /> value in this parameter makes this method equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />,
        which copies only rows that match the supplied row state in the supplied <see cref="T:System.Data.DataTable" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
        The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Threading.CancellationToken)">
            <param name="table">
        A <see cref="T:System.Data.DataTable" /> whose rows will be copied to the destination table.
      </param><param name="cancellationToken">
        The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" /> value in this parameter makes this method equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />,
        which copies all rows in the supplied <see cref="T:System.Data.DataTable" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
        The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)">
            <param name="reader">
        A <see cref="T:System.Data.IDataReader" /> whose rows will be copied to the destination table.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />,
        which copies all rows in the supplied <see cref="T:System.Data.IDataReader" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>The <see cref="T:System.Data.IDataReader" /> was closed before the completed <see cref="T:System.Threading.Tasks.Task" /> returned.</item>
          <item>The <see cref="T:System.Data.IDataReader" /> 's associated connection was closed before the completed <see cref="T:System.Threading.Tasks.Task" /> returned.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader,System.Threading.CancellationToken)">
            <param name="reader">
        A <see cref="T:System.Data.IDataReader" /> whose rows will be copied to the destination table.
      </param><param name="cancellationToken">
        The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" /> value in this parameter makes this method equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />.
      </param><summary>
        The asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />,
        which copies all rows in the supplied <see cref="T:System.Data.IDataReader" /> to a destination table specified by the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object.
        The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> multiple times for the same instance before task completion.</item>
          <item>Calling <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> and <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" /> for the same instance before task completion.</item>
          <item>The connection drops or is closed during <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> execution.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object was closed during the method execution.</item>
          <item>Returned in the task object, there was a connection pool timeout.</item>
          <item>Returned in the task object, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object is closed before method execution.</item>
          <item>The <see cref="T:System.Data.IDataReader" /> was closed before the completed <see cref="T:System.Threading.Tasks.Task" /> returned.</item>
          <item>The <see cref="T:System.Data.IDataReader" /> 's associated connection was closed before the completed <see cref="T:System.Threading.Tasks.Task" /> returned.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> did not specify a valid destination column name.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Returned in the task object, any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping">
            <summary>
        Defines the mapping between a column in a <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance's data source and a column in the instance's destination table.
      </summary><remarks>
        <para>
          Column mappings define the mapping between data source and the target table.
        </para>
        <para>
          If mappings are not defined - that is, the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection is empty - the columns are mapped implicitly based on ordinal position. For this to work, source and target schemas must match. If they do not, an <see cref="T:System.InvalidOperationException" /> will be thrown.
        </para>
        <para>
          If the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection is not empty, not every column present in the data source has to be specified. Those not mapped by the collection are ignored.
        </para>
        <para>
          You can refer to source and target columns by either name or ordinal. You can also mix by-name and by-ordinal column references in the same mappings collection.
        </para>
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b>
          sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, and each destination column is in the same ordinal position as its corresponding source column, the column names do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using<b>SqlBulkCopy</b>only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMapping -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings by name.
                          SqlBulkCopyColumnMapping mapID =
                              new SqlBulkCopyColumnMapping("ProductID", "ProdID");
                          bulkCopy.ColumnMappings.Add(mapID);
          
                          SqlBulkCopyColumnMapping mapName =
                              new SqlBulkCopyColumnMapping("Name", "ProdName");
                          bulkCopy.ColumnMappings.Add(mapName);
          
                          SqlBulkCopyColumnMapping mapNumber =
                              new SqlBulkCopyColumnMapping("ProductNumber", "ProdNum");
                          bulkCopy.ColumnMappings.Add(mapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.#ctor">
            <summary>
        Parameterless constructor that initializes a new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object.
      </summary><remarks>
        If you use this constructor, you must then define the source for the mapping using the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceColumn" /> property or the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceOrdinal" /> property, and define the destination for the mapping using the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationColumn" /> property or the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationOrdinal" /> property.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b>  sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMapping -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings by name.
                          SqlBulkCopyColumnMapping mapID =
                              new SqlBulkCopyColumnMapping("ProductID", "ProdID");
                          bulkCopy.ColumnMappings.Add(mapID);
          
                          SqlBulkCopyColumnMapping mapName =
                              new SqlBulkCopyColumnMapping("Name", "ProdName");
                          bulkCopy.ColumnMappings.Add(mapName);
          
                          SqlBulkCopyColumnMapping mapNumber =
                              new SqlBulkCopyColumnMapping("ProductNumber", "ProdNum");
                          bulkCopy.ColumnMappings.Add(mapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.#ctor(System.Int32,System.Int32)">
            <param name="sourceColumnOrdinal">
        The ordinal position of the source column within the data source.
      </param><param name="destinationOrdinal">
        The ordinal position of the destination column within the destination table.
      </param><summary>
        Creates a new column mapping, using column ordinals to refer to source and destination columns.
      </summary><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b>  sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy based on the ordinal positions of the columns.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingOrdinal -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection =
                             new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy =
                                 new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings by ordinal.
                          SqlBulkCopyColumnMapping columnMapID =
                              new SqlBulkCopyColumnMapping(0, 0);
                          bulkCopy.ColumnMappings.Add(columnMapID);
          
                          SqlBulkCopyColumnMapping columnMapName =
                              new SqlBulkCopyColumnMapping(1, 2);
                          bulkCopy.ColumnMappings.Add(columnMapName);
          
                          SqlBulkCopyColumnMapping columnMapNumber =
                              new SqlBulkCopyColumnMapping(2, 1);
                          bulkCopy.ColumnMappings.Add(columnMapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.#ctor(System.Int32,System.String)">
            <param name="sourceColumnOrdinal">
        The ordinal position of the source column within the data source.
      </param><param name="destinationColumn">
        The name of the destination column within the destination table.
      </param><summary>
        Creates a new column mapping, using a column ordinal to refer to the source column and a column name for the target column.
      </summary><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingOrdinalName -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings by ordinal and name.
                          SqlBulkCopyColumnMapping columnMapID =
                              new SqlBulkCopyColumnMapping(0, "ProdID");
                          bulkCopy.ColumnMappings.Add(columnMapID);
          
                          SqlBulkCopyColumnMapping columnMapName =
                              new SqlBulkCopyColumnMapping(1, "ProdName");
                          bulkCopy.ColumnMappings.Add(columnMapName);
          
                          SqlBulkCopyColumnMapping columnMapNumber =
                              new SqlBulkCopyColumnMapping(2, "ProdNum");
                          bulkCopy.ColumnMappings.Add(columnMapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }          
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.#ctor(System.String,System.Int32)">
            <param name="sourceColumn">
        The name of the source column within the data source.
      </param><param name="destinationOrdinal">
        The ordinal position of the destination column within the destination table.
      </param><summary>
        Creates a new column mapping, using a column name to refer to the source column and a column ordinal for the target column.
      </summary><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingNameOrdinal -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings by name and ordinal.
                          SqlBulkCopyColumnMapping columnMapID =
                              new SqlBulkCopyColumnMapping("ProductID", 0);
                          bulkCopy.ColumnMappings.Add(columnMapID);
          
                          SqlBulkCopyColumnMapping columnMapName =
                              new SqlBulkCopyColumnMapping("Name", 2);
                          bulkCopy.ColumnMappings.Add(columnMapName);
          
                          SqlBulkCopyColumnMapping columnMapNumber =
                              new SqlBulkCopyColumnMapping("ProductNumber", 1);
                          bulkCopy.ColumnMappings.Add(columnMapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString() 
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.#ctor(System.String,System.String)">
            <param name="sourceColumn">
        The name of the source column within the data source.
      </param><param name="destinationColumn">
        The name of the destination column within the destination table.
      </param><summary>
        Creates a new column mapping, using column names to refer to source and destination columns.
      </summary><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b>  sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMapping -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, ProductNumber FROM Production.Product;",
                          sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName = "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings by name.
                          SqlBulkCopyColumnMapping mapID =
                              new SqlBulkCopyColumnMapping("ProductID", "ProdID");
                          bulkCopy.ColumnMappings.Add(mapID);
          
                          SqlBulkCopyColumnMapping mapName =
                              new SqlBulkCopyColumnMapping("Name", "ProdName");
                          bulkCopy.ColumnMappings.Add(mapName);
          
                          SqlBulkCopyColumnMapping mapNumber =
                              new SqlBulkCopyColumnMapping("ProductNumber", "ProdNum");
                          bulkCopy.ColumnMappings.Add(mapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationColumn">
            <summary>
        Name of the column being mapped in the destination database table.
      </summary><value>
        The string value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationColumn" /> property.
      </value><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationColumn" /> and <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationOrdinal" /> properties are mutually exclusive. The last value set takes precedence.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b>  sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingDestinationColumn -->
        <code language="c#">
            using System;
            using System.Data;
            using Microsoft.Data.SqlClient;
            
            class Program
            {
                static void Main()
                {
                    string connectionString = GetConnectionString();
                    // Open a sourceConnection to the AdventureWorks database.
                    using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                    {
                        sourceConnection.Open();
            
                        // Perform an initial count on the destination table.
                        SqlCommand commandRowCount = new SqlCommand(
                            "SELECT COUNT(*) FROM " +
                            "dbo.BulkCopyDemoDifferentColumns;",
                            sourceConnection);
                        long countStart = System.Convert.ToInt32(
                            commandRowCount.ExecuteScalar());
                        Console.WriteLine("Starting row count = {0}", countStart);
            
                        // Get data from the source table as a SqlDataReader.
                        SqlCommand commandSourceData = new SqlCommand(
                            "SELECT ProductID, Name, " +
                            "ProductNumber " +
                            "FROM Production.Product;", sourceConnection);
                        SqlDataReader reader =
                            commandSourceData.ExecuteReader();
            
                        // Set up the bulk copy object.
                        using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                        {
                            bulkCopy.DestinationTableName =
                                "dbo.BulkCopyDemoDifferentColumns";
            
                            // Set up the column mappings source and destination.
                            SqlBulkCopyColumnMapping mapID = new SqlBulkCopyColumnMapping();
                            mapID.SourceColumn = "ProductID";
                            mapID.DestinationColumn = "ProdID";
                            bulkCopy.ColumnMappings.Add(mapID);
            
                            SqlBulkCopyColumnMapping mapName = new SqlBulkCopyColumnMapping();
                            mapName.SourceColumn = "Name";
                            mapName.DestinationColumn = "ProdName";
                            bulkCopy.ColumnMappings.Add(mapName);
            
                            SqlBulkCopyColumnMapping mapNumber = new SqlBulkCopyColumnMapping();
                            mapNumber.SourceColumn = "ProductNumber";
                            mapNumber.DestinationColumn = "ProdNum";
                            bulkCopy.ColumnMappings.Add(mapNumber);
            
                            // Write from the source to the destination.
                            try
                            {
                                bulkCopy.WriteToServer(reader);
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex.Message);
                            }
                            finally
                            {
                                // Close the SqlDataReader. The SqlBulkCopy
                                // object is automatically closed at the end
                                // of the using block.
                                reader.Close();
                            }
                        }
            
                        // Perform a final count on the destination 
                        // table to see how many rows were added.
                        long countEnd = System.Convert.ToInt32(
                            commandRowCount.ExecuteScalar());
                        Console.WriteLine("Ending row count = {0}", countEnd);
                        Console.WriteLine("{0} rows were added.", countEnd - countStart);
                        Console.WriteLine("Press Enter to finish.");
                        Console.ReadLine();
                    }
                }
            
                private static string GetConnectionString()
                {
                    // To avoid storing the sourceConnection string in your code,
                    // you can retrieve it from a configuration file.
                    return "Data Source=(local); " +
                        " Integrated Security=true;" +
                        "Initial Catalog=AdventureWorks;";
                }
            }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationOrdinal">
            <summary>
        Ordinal value of the destination column within the destination table.
      </summary><value>
        The integer value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationOrdinal" /> property, or -1 if the property has not been set.
      </value><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationColumn" /> and <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationOrdinal" /> properties are mutually exclusive. The last value set takes precedence.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingDestinationOrdinal -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings source and destination.
                          SqlBulkCopyColumnMapping mapID = new SqlBulkCopyColumnMapping();
                          mapID.SourceOrdinal = 0;
                          mapID.DestinationOrdinal = 0;
                          bulkCopy.ColumnMappings.Add(mapID);
          
                          SqlBulkCopyColumnMapping mapName = new SqlBulkCopyColumnMapping();
                          mapName.SourceOrdinal = 1;
                          mapName.DestinationOrdinal = 2;
                          bulkCopy.ColumnMappings.Add(mapName);
          
                          SqlBulkCopyColumnMapping mapNumber = new SqlBulkCopyColumnMapping();
                          mapNumber.SourceOrdinal = 2;
                          mapNumber.DestinationOrdinal = 1;
                          bulkCopy.ColumnMappings.Add(mapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                      " Integrated Security=true;" +
                      "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceColumn">
            <summary>
        Name of the column being mapped in the data source.
      </summary><value>
        The string value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceColumn" /> property.
      </value><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceColumn" /> and <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceOrdinal " /> properties are mutually exclusive. The last value set takes precedence.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingDestinationColumn -->
        <code language="c#">
            using System;
            using System.Data;
            using Microsoft.Data.SqlClient;
            
            class Program
            {
                static void Main()
                {
                    string connectionString = GetConnectionString();
                    // Open a sourceConnection to the AdventureWorks database.
                    using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                    {
                        sourceConnection.Open();
            
                        // Perform an initial count on the destination table.
                        SqlCommand commandRowCount = new SqlCommand(
                            "SELECT COUNT(*) FROM " +
                            "dbo.BulkCopyDemoDifferentColumns;",
                            sourceConnection);
                        long countStart = System.Convert.ToInt32(
                            commandRowCount.ExecuteScalar());
                        Console.WriteLine("Starting row count = {0}", countStart);
            
                        // Get data from the source table as a SqlDataReader.
                        SqlCommand commandSourceData = new SqlCommand(
                            "SELECT ProductID, Name, " +
                            "ProductNumber " +
                            "FROM Production.Product;", sourceConnection);
                        SqlDataReader reader =
                            commandSourceData.ExecuteReader();
            
                        // Set up the bulk copy object.
                        using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                        {
                            bulkCopy.DestinationTableName =
                                "dbo.BulkCopyDemoDifferentColumns";
            
                            // Set up the column mappings source and destination.
                            SqlBulkCopyColumnMapping mapID = new SqlBulkCopyColumnMapping();
                            mapID.SourceColumn = "ProductID";
                            mapID.DestinationColumn = "ProdID";
                            bulkCopy.ColumnMappings.Add(mapID);
            
                            SqlBulkCopyColumnMapping mapName = new SqlBulkCopyColumnMapping();
                            mapName.SourceColumn = "Name";
                            mapName.DestinationColumn = "ProdName";
                            bulkCopy.ColumnMappings.Add(mapName);
            
                            SqlBulkCopyColumnMapping mapNumber = new SqlBulkCopyColumnMapping();
                            mapNumber.SourceColumn = "ProductNumber";
                            mapNumber.DestinationColumn = "ProdNum";
                            bulkCopy.ColumnMappings.Add(mapNumber);
            
                            // Write from the source to the destination.
                            try
                            {
                                bulkCopy.WriteToServer(reader);
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex.Message);
                            }
                            finally
                            {
                                // Close the SqlDataReader. The SqlBulkCopy
                                // object is automatically closed at the end
                                // of the using block.
                                reader.Close();
                            }
                        }
            
                        // Perform a final count on the destination 
                        // table to see how many rows were added.
                        long countEnd = System.Convert.ToInt32(
                            commandRowCount.ExecuteScalar());
                        Console.WriteLine("Ending row count = {0}", countEnd);
                        Console.WriteLine("{0} rows were added.", countEnd - countStart);
                        Console.WriteLine("Press Enter to finish.");
                        Console.ReadLine();
                    }
                }
            
                private static string GetConnectionString()
                {
                    // To avoid storing the sourceConnection string in your code,
                    // you can retrieve it from a configuration file.
                    return "Data Source=(local); " +
                        " Integrated Security=true;" +
                        "Initial Catalog=AdventureWorks;";
                }
            }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceOrdinal">
            <summary>
        The ordinal position of the source column within the data source.
      </summary><value>
        The integer value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceOrdinal" /> property.
      </value><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceColumn" /> and <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping.SourceOrdinal" /> properties are mutually exclusive. The last value set takes precedence.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b>  sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingDestinationOrdinal -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings source and destination.
                          SqlBulkCopyColumnMapping mapID = new SqlBulkCopyColumnMapping();
                          mapID.SourceOrdinal = 0;
                          mapID.DestinationOrdinal = 0;
                          bulkCopy.ColumnMappings.Add(mapID);
          
                          SqlBulkCopyColumnMapping mapName = new SqlBulkCopyColumnMapping();
                          mapName.SourceOrdinal = 1;
                          mapName.DestinationOrdinal = 2;
                          bulkCopy.ColumnMappings.Add(mapName);
          
                          SqlBulkCopyColumnMapping mapNumber = new SqlBulkCopyColumnMapping();
                          mapNumber.SourceOrdinal = 2;
                          mapNumber.DestinationOrdinal = 1;
                          bulkCopy.ColumnMappings.Add(mapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                      " Integrated Security=true;" +
                      "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection">
            <summary>
        Collection of <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects that inherits from <see cref="T:System.Collections.CollectionBase" />.
      </summary><remarks>
        <para>
          Column mappings define the mapping between data source and the target table.
        </para>
        <para>
          If mappings are not defined - that is, the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection is empty - the columns are mapped implicitly based on ordinal position.  For this to work, source and target schemas must match. If they do not, an <see cref="T:System.InvalidOperationException" /> is thrown.
        </para>
        <para>
          If the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection is not empty, not every column present in the data source has to be specified. Those not mapped by the collection are ignored.
        </para>
        <para>
          You can refer to source and target columns by either name or ordinal. You can mix by-name and by-ordinal column references in the same mappings collection.
        </para>
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database.  Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> are added to the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection" /> for the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingCollection -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // The column order in the source doesn't match the order 
                          // in the destination, so ColumnMappings must be defined.
                          bulkCopy.ColumnMappings.Add("ProductID", "ProdID");
                          bulkCopy.ColumnMappings.Add("Name", "ProdName");
                          bulkCopy.ColumnMappings.Add("ProductNumber", "ProdNum");
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Item(System.Int32)">
            <param name="index">
        The zero-based index of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> to find.
      </param><summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object at the specified index.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object.
      </value>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Add(Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping)">
            <param name="bulkCopyColumnMapping">
        The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object that describes the mapping to be added to the collection.
      </param><summary>
        Adds the specified mapping to the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object.
      </returns><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database.  Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance,  it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMapping -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // Set up the column mappings by name.
                          SqlBulkCopyColumnMapping mapID =
                              new SqlBulkCopyColumnMapping("ProductID", "ProdID");
                          bulkCopy.ColumnMappings.Add(mapID);
          
                          SqlBulkCopyColumnMapping mapName =
                              new SqlBulkCopyColumnMapping("Name", "ProdName");
                          bulkCopy.ColumnMappings.Add(mapName);
          
                          SqlBulkCopyColumnMapping mapNumber =
                              new SqlBulkCopyColumnMapping("ProductNumber", "ProdNum");
                          bulkCopy.ColumnMappings.Add(mapNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Add(System.Int32,System.Int32)">
            <param name="sourceColumnIndex">
        The ordinal position of the source column within the data source.
      </param><param name="destinationColumnIndex">
        The ordinal position of the destination column within the destination table.
      </param><summary>
        Creates a new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> and adds it to the collection, using ordinals to specify both source and destination columns.
      </summary><returns>
        A column mapping.
      </returns><remarks>
        Mappings in a collection must be uniform: either all integer/integer pairs, all string/string pairs, all integer/string pairs, or all string/integer pairs. If you try to add a mapping that is different from others already in the collection, an <see cref="T:System.InvalidOperationException" /> is thrown.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database.  Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy using the ordinal position of the source and destination columns.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingCollectionOrdinal -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // The column order in the source doesn't match the order 
                          // in the destination, so ColumnMappings must be defined.
                          bulkCopy.ColumnMappings.Add(0, 0);
                          bulkCopy.ColumnMappings.Add(1, 2);
                          bulkCopy.ColumnMappings.Add(2, 1);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Add(System.Int32,System.String)">
            <param name="sourceColumnIndex">
        The ordinal position of the source column within the data source.
      </param><param name="destinationColumn">
        The name of the destination column within the destination table.
      </param><summary>
        Creates a new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> and adds it to the collection, using an ordinal for the source column and a string for the destination column.
      </summary><returns>
        A column mapping.
      </returns><remarks>
        Mappings in a collection must be uniform: either all integer/integer pairs, all string/string pairs, all integer/string pairs, or all string/integer pairs.  If you try to add a mapping that is different from others already in the collection, an <see cref="T:System.InvalidOperationException" /> is thrown.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingIndexColName -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // The column order in the source doesn't match the order 
                          // in the destination, so ColumnMappings must be defined.
                          bulkCopy.ColumnMappings.Add(0, 0);
                          bulkCopy.ColumnMappings.Add(1, 2);
                          bulkCopy.ColumnMappings.Add(2, 1);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Add(System.String,System.Int32)">
            <param name="sourceColumn">
        The name of the source column within the data source.
      </param><param name="destinationColumnIndex">
        The ordinal position of the destination column within the destination table.
      </param><summary>
        Creates a new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> and adds it to the collection, using a column name to describe the source column and an ordinal to specify the destination column.
      </summary><returns>
        A column mapping.
      </returns><remarks>
        Mappings in a collection must be uniform: either all integer/integer pairs, all string/string pairs, all integer/string pairs, or all string/integer pairs. If you try to add a mapping that is different from others already in the collection, an <see cref="T:System.InvalidOperationException" /> is thrown.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database.  Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> objects are used to create a column map for the bulk copy.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance,  it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingColNameIndex -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // The column order in the source doesn't match the order 
                          // in the destination, so ColumnMappings must be defined.
                          bulkCopy.ColumnMappings.Add(0, 0);
                          bulkCopy.ColumnMappings.Add(1, 2);
                          bulkCopy.ColumnMappings.Add(2, 1);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Add(System.String,System.String)">
            <param name="sourceColumn">
        The name of the source column within the data source.
      </param><param name="destinationColumn">
        The name of the destination column within the destination table.
      </param><summary>
        Creates a new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> and adds it to the collection, using column names to specify both source and destination columns.
      </summary><returns>
        A column mapping.
      </returns><remarks>
        Mappings in a collection must be uniform: either all integer/integer pairs, all string/string pairs, all integer/string pairs, or all string/integer pairs. If you try to add a mapping that is different from others already in the collection, an <see cref="T:System.InvalidOperationException" /> is thrown.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database.  Although the number of columns in the destination matches the number of columns in the source, the column names and ordinal positions do not match. The code creates a <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object by specifying the column names.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance,  it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingCollection -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoDifferentColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoDifferentColumns";
          
                          // The column order in the source doesn't match the order 
                          // in the destination, so ColumnMappings must be defined.
                          bulkCopy.ColumnMappings.Add("ProductID", "ProdID");
                          bulkCopy.ColumnMappings.Add("Name", "ProdName");
                          bulkCopy.ColumnMappings.Add("ProductNumber", "ProdNum");
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Clear">
            <summary>
        Clears the contents of the collection.
      </summary><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Clear" /> method is most commonly used when you use a single <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to process more than one bulk copy operation. If you create column mappings for one bulk copy operation, you must clear the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection" /> after the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method and before processing the next bulk copy.
        </para>
        <para>
          Performing several bulk copies using the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance will usually be more efficient from a performance point of view than using a separate <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> for each operation.
        </para>
      </remarks><example>
        <para>
          The following example performs two bulk copy operations. The first operation copies sales order header information, and the second copies sales order details. Although not strictly necessary in this example (because the ordinal positions of the source and destination columns do match), the example defines column mappings for each bulk copy operation. The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Clear" /> method must be used after the first bulk copy is performed and before the next bulk copy's column mappings are defined.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingOrdersDetails -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Empty the destination tables. 
                      SqlCommand deleteHeader = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      deleteHeader.ExecuteNonQuery();
                      SqlCommand deleteDetail = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      deleteDetail.ExecuteNonQuery();
          
                      // Perform an initial count on the destination
                      //  table with matching columns. 
                      SqlCommand countRowHeader = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      long countStartHeader = System.Convert.ToInt32(
                          countRowHeader.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Header table = {0}",
                          countStartHeader);
          
                      // Perform an initial count on the destination
                      // table with different column positions. 
                      SqlCommand countRowDetail = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      long countStartDetail = System.Convert.ToInt32(
                          countRowDetail.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Detail table = {0}",
                          countStartDetail);
          
                      // Get data from the source table as a SqlDataReader.
                      // The Sales.SalesOrderHeader and Sales.SalesOrderDetail
                      // tables are quite large and could easily cause a timeout
                      // if all data from the tables is added to the destination. 
                      // To keep the example simple and quick, a parameter is  
                      // used to select only orders for a particular account 
                      // as the source for the bulk insert. 
                      SqlCommand headerData = new SqlCommand(
                          "SELECT [SalesOrderID], [OrderDate], " +
                          "[AccountNumber] FROM [Sales].[SalesOrderHeader] " +
                          "WHERE [AccountNumber] = @accountNumber;",
                          connection);
                      SqlParameter parameterAccount = new SqlParameter();
                      parameterAccount.ParameterName = "@accountNumber";
                      parameterAccount.SqlDbType = SqlDbType.NVarChar;
                      parameterAccount.Direction = ParameterDirection.Input;
                      parameterAccount.Value = "10-4020-000034";
                      headerData.Parameters.Add(parameterAccount);
                      SqlDataReader readerHeader = headerData.ExecuteReader();
          
                      // Get the Detail data in a separate connection.
                      using (SqlConnection connection2 = new SqlConnection(connectionString))
                      {
                          connection2.Open();
                          SqlCommand sourceDetailData = new SqlCommand(
                              "SELECT [Sales].[SalesOrderDetail].[SalesOrderID], [SalesOrderDetailID], " +
                              "[OrderQty], [ProductID], [UnitPrice] FROM [Sales].[SalesOrderDetail] " +
                              "INNER JOIN [Sales].[SalesOrderHeader] ON [Sales].[SalesOrderDetail]." +
                              "[SalesOrderID] = [Sales].[SalesOrderHeader].[SalesOrderID] " +
                              "WHERE [AccountNumber] = @accountNumber;", connection2);
          
                          SqlParameter accountDetail = new SqlParameter();
                          accountDetail.ParameterName = "@accountNumber";
                          accountDetail.SqlDbType = SqlDbType.NVarChar;
                          accountDetail.Direction = ParameterDirection.Input;
                          accountDetail.Value = "10-4020-000034";
                          sourceDetailData.Parameters.Add(accountDetail);
                          SqlDataReader readerDetail = sourceDetailData.ExecuteReader();
          
                          // Create the SqlBulkCopy object. 
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                          {
                              bulkCopy.DestinationTableName =
                                  "dbo.BulkCopyDemoOrderHeader";
          
                              // Guarantee that columns are mapped correctly by
                              // defining the column mappings for the order.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("OrderDate", "OrderDate");
                              bulkCopy.ColumnMappings.Add("AccountNumber", "AccountNumber");
          
                              // Write readerHeader to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerHeader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerHeader.Close();
                              }
          
                              // Set up the order details destination. 
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderDetail";
          
                              // Clear the ColumnMappingCollection.
                              bulkCopy.ColumnMappings.Clear();
          
                              // Add order detail column mappings.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("SalesOrderDetailID", "SalesOrderDetailID");
                              bulkCopy.ColumnMappings.Add("OrderQty", "OrderQty");
                              bulkCopy.ColumnMappings.Add("ProductID", "ProductID");
                              bulkCopy.ColumnMappings.Add("UnitPrice", "UnitPrice");
          
                              // Write readerDetail to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerDetail);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerDetail.Close();
                              }
                          }
          
                          // Perform a final count on the destination
                          // tables to see how many rows were added. 
                          long countEndHeader = System.Convert.ToInt32(
                              countRowHeader.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Header table.",
                              countEndHeader - countStartHeader);
                          long countEndDetail = System.Convert.ToInt32(
                              countRowDetail.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Detail table.",
                              countEndDetail - countStartDetail);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
          
              private static string GetConnectionString() 
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Contains(Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping)">
            <param name="value">
        A valid <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object.
      </param><summary>
        Gets a value indicating whether a specified <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object exists in the collection.
      </summary><returns><see langword="true" /> if the specified mapping exists in the collection; otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.CopyTo(Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping[],System.Int32)">
            <param name="array">
        The one-dimensional <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> array that is the destination of the elements copied from <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />. The array must have zero-based indexing.
      </param><param name="index">
        The zero-based index in <paramref name="array" /> at which copying begins.
      </param><summary>
        Copies the elements of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection" /> to an array of <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> items, starting at a particular index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.IndexOf(Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping)">
            <param name="value">
        The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object for which to search.
      </param><summary>
        Gets the index of the specified <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object.
      </summary><returns>
        The zero-based index of the column mapping, or -1 if the column mapping is not found in the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Insert(System.Int32,Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping)">
            <param name="index">
        Integer value of the location within the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection" /> at which to insert the new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" />.
      </param><param name="value"><see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object to be inserted in the collection.</param><summary>
        Insert a new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> at the index specified.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Remove(Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping)">
            <param name="value"><see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object to be removed from the collection.</param><summary>
        Removes the specified <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> element from the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />.
      </summary><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Remove" /> method is most commonly used when you use a single <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to process more than one bulk copy operation. If you create column mappings for one bulk copy operation, you must remove mappings that no longer apply after the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method is called and before defining mapping for the next bulk copy. You can clear the entire collection by using the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Clear" /> method, or remove mappings individually using the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Remove" /> method or the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.RemoveAt" /> method.
        </para>
        <para>
          Performing several bulk copies using the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance will usually be more efficient from a performance point of view than using a separate <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> for each operation.
        </para>
      </remarks><example>
        <para>
          The following example performs two bulk copy operations. The first operation copies sales order header information, and the second copies sales order details.  Although not strictly necessary in this example (because the ordinal positions of the source and destination columns do match), the example defines column mappings for each bulk copy operation.  Both bulk copies include a mapping for the <b>SalesOrderID</b>, so rather than clearing the entire collection between bulk copy operations, the example removes all mappings except for the <b>SalesOrderID</b> mapping and then adds the appropriate mappings for the second bulk copy operation.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingRemove -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Empty the destination tables. 
                      SqlCommand deleteHeader = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      deleteHeader.ExecuteNonQuery();
                      SqlCommand deleteDetail = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      deleteDetail.ExecuteNonQuery();
          
                      // Perform an initial count on the destination
                      //  table with matching columns. 
                      SqlCommand countRowHeader = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      long countStartHeader = System.Convert.ToInt32(
                          countRowHeader.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Header table = {0}",
                          countStartHeader);
          
                      // Perform an initial count on the destination
                      // table with different column positions. 
                      SqlCommand countRowDetail = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      long countStartDetail = System.Convert.ToInt32(
                          countRowDetail.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Detail table = {0}",
                          countStartDetail);
          
                      // Get data from the source table as a SqlDataReader.
                      // The Sales.SalesOrderHeader and Sales.SalesOrderDetail
                      // tables are quite large and could easily cause a timeout
                      // if all data from the tables is added to the destination. 
                      // To keep the example simple and quick, a parameter is  
                      // used to select only orders for a particular account 
                      // as the source for the bulk insert. 
                      SqlCommand headerData = new SqlCommand(
                          "SELECT [SalesOrderID], [OrderDate], " +
                          "[AccountNumber] FROM [Sales].[SalesOrderHeader] " +
                          "WHERE [AccountNumber] = @accountNumber;",
                          connection);
                      SqlParameter parameterAccount = new SqlParameter();
                      parameterAccount.ParameterName = "@accountNumber";
                      parameterAccount.SqlDbType = SqlDbType.NVarChar;
                      parameterAccount.Direction = ParameterDirection.Input;
                      parameterAccount.Value = "10-4020-000034";
                      headerData.Parameters.Add(parameterAccount);
                      SqlDataReader readerHeader = headerData.ExecuteReader();
          
                      // Get the Detail data in a separate connection.
                      using (SqlConnection connection2 = new SqlConnection(connectionString))
                      {
                          connection2.Open();
                          SqlCommand sourceDetailData = new SqlCommand(
                              "SELECT [Sales].[SalesOrderDetail].[SalesOrderID], [SalesOrderDetailID], " +
                              "[OrderQty], [ProductID], [UnitPrice] FROM [Sales].[SalesOrderDetail] " +
                              "INNER JOIN [Sales].[SalesOrderHeader] ON [Sales].[SalesOrderDetail]." +
                              "[SalesOrderID] = [Sales].[SalesOrderHeader].[SalesOrderID] " +
                              "WHERE [AccountNumber] = @accountNumber;", connection2);
          
                          SqlParameter accountDetail = new SqlParameter();
                          accountDetail.ParameterName = "@accountNumber";
                          accountDetail.SqlDbType = SqlDbType.NVarChar;
                          accountDetail.Direction = ParameterDirection.Input;
                          accountDetail.Value = "10-4020-000034";
                          sourceDetailData.Parameters.Add(accountDetail);
                          SqlDataReader readerDetail = sourceDetailData.ExecuteReader();
          
                          // Create the SqlBulkCopy object. 
                          using (SqlBulkCopy bulkCopy =
                                     new SqlBulkCopy(connectionString))
                          {
                              bulkCopy.DestinationTableName =
                                  "dbo.BulkCopyDemoOrderHeader";
          
                              // Guarantee that columns are mapped correctly by
                              // defining the column mappings for the order.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("OrderDate", "OrderDate");
                              bulkCopy.ColumnMappings.Add("AccountNumber", "AccountNumber");
          
                              // Write readerHeader to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerHeader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerHeader.Close();
                              }
          
                              // Set up the order details destination. 
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderDetail";
          
                              // Clear the ColumnMappingCollection.
                              bulkCopy.ColumnMappings.Clear();
          
                              // Add order detail column mappings.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("SalesOrderDetailID", "SalesOrderDetailID");
                              bulkCopy.ColumnMappings.Add("OrderQty", "OrderQty");
                              bulkCopy.ColumnMappings.Add("ProductID", "ProductID");
                              bulkCopy.ColumnMappings.Add("UnitPrice", "UnitPrice");
          
                              // Write readerDetail to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerDetail);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerDetail.Close();
                              }
                          }
          
                          // Perform a final count on the destination
                          // tables to see how many rows were added. 
                          long countEndHeader = System.Convert.ToInt32(
                              countRowHeader.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Header table.",
                              countEndHeader - countStartHeader);
                          long countEndDetail = System.Convert.ToInt32(
                              countRowDetail.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Detail table.",
                              countEndDetail - countStartDetail);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
          
              private static string GetConnectionString() 
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.RemoveAt(System.Int32)">
            <param name="index">
        The zero-based index of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnMapping" /> object to be removed from the collection.
      </param><summary>
        Removes the mapping at the specified index from the collection.
      </summary><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.RemoveAt" /> method is most commonly used when you use a single <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to process more than one bulk copy operation. If you create column mappings for one bulk copy operation, you must remove mappings that no longer apply after the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method is called and before defining mapping for the next bulk copy. You can clear the entire collection by using the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Clear" /> method, or remove mappings individually using the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.Remove" /> method or the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnMappingCollection.RemoveAt" /> method.
        </para>
        <para>
          Performing several bulk copies using the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance will usually be more efficient from a performance point of view than using a separate <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> for each operation.
        </para>
      </remarks><example>
        <para>
          The following example performs two bulk copy operations. The first operation copies sales order header information, and the second copies sales order details.  Although not strictly necessary in this example (because the ordinal positions of the source and destination columns do match), the example defines column mappings for each bulk copy operation.  Both bulk copies include a mapping for the <b>SalesOrderID</b>, so rather than clearing the entire collection between bulk copy operations, the example removes all mappings except for the <b>SalesOrderID</b> mapping and then adds the appropriate mappings for the second bulk copy operation.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnMappingRemoveAt -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Empty the destination tables. 
                      SqlCommand deleteHeader = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      deleteHeader.ExecuteNonQuery();
                      SqlCommand deleteDetail = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      deleteDetail.ExecuteNonQuery();
          
                      // Perform an initial count on the destination
                      //  table with matching columns. 
                      SqlCommand countRowHeader = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      long countStartHeader = System.Convert.ToInt32(
                          countRowHeader.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Header table = {0}",
                          countStartHeader);
          
                      // Perform an initial count on the destination
                      // table with different column positions. 
                      SqlCommand countRowDetail = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      long countStartDetail = System.Convert.ToInt32(
                          countRowDetail.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Detail table = {0}",
                          countStartDetail);
          
                      // Get data from the source table as a SqlDataReader.
                      // The Sales.SalesOrderHeader and Sales.SalesOrderDetail
                      // tables are quite large and could easily cause a timeout
                      // if all data from the tables is added to the destination. 
                      // To keep the example simple and quick, a parameter is  
                      // used to select only orders for a particular account 
                      // as the source for the bulk insert. 
                      SqlCommand headerData = new SqlCommand(
                          "SELECT [SalesOrderID], [OrderDate], " +
                          "[AccountNumber] FROM [Sales].[SalesOrderHeader] " +
                          "WHERE [AccountNumber] = @accountNumber;",
                          connection);
                      SqlParameter parameterAccount = new SqlParameter();
                      parameterAccount.ParameterName = "@accountNumber";
                      parameterAccount.SqlDbType = SqlDbType.NVarChar;
                      parameterAccount.Direction = ParameterDirection.Input;
                      parameterAccount.Value = "10-4020-000034";
                      headerData.Parameters.Add(parameterAccount);
                      SqlDataReader readerHeader = headerData.ExecuteReader();
          
                      // Get the Detail data in a separate connection.
                      using (SqlConnection connection2 = new SqlConnection(connectionString))
                      {
                          connection2.Open();
                          SqlCommand sourceDetailData = new SqlCommand(
                              "SELECT [Sales].[SalesOrderDetail].[SalesOrderID], [SalesOrderDetailID], " +
                              "[OrderQty], [ProductID], [UnitPrice] FROM [Sales].[SalesOrderDetail] " +
                              "INNER JOIN [Sales].[SalesOrderHeader] ON [Sales].[SalesOrderDetail]." +
                              "[SalesOrderID] = [Sales].[SalesOrderHeader].[SalesOrderID] " +
                              "WHERE [AccountNumber] = @accountNumber;", connection2);
          
                          SqlParameter accountDetail = new SqlParameter();
                          accountDetail.ParameterName = "@accountNumber";
                          accountDetail.SqlDbType = SqlDbType.NVarChar;
                          accountDetail.Direction = ParameterDirection.Input;
                          accountDetail.Value = "10-4020-000034";
                          sourceDetailData.Parameters.Add(accountDetail);
                          SqlDataReader readerDetail = sourceDetailData.ExecuteReader();
          
                          // Create the SqlBulkCopy object. 
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                          {
                              bulkCopy.DestinationTableName =
                                  "dbo.BulkCopyDemoOrderHeader";
          
                              // Guarantee that columns are mapped correctly by
                              // defining the column mappings for the order.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("OrderDate", "OrderDate");
                              bulkCopy.ColumnMappings.Add("AccountNumber", "AccountNumber");
          
                              // Write readerHeader to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerHeader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerHeader.Close();
                              }
          
                              // Set up the order details destination. 
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderDetail";
          
                              // Rather than clearing mappings that are not necessary
                              // for the next bulk copy operation, the unneeded mappings
                              //  are removed with the RemoveAt method.
                              bulkCopy.ColumnMappings.RemoveAt(2);
                              bulkCopy.ColumnMappings.RemoveAt(1);
          
                              // Add order detail column mappings.
                              bulkCopy.ColumnMappings.Add("SalesOrderDetailID", "SalesOrderDetailID");
                              bulkCopy.ColumnMappings.Add("OrderQty", "OrderQty");
                              bulkCopy.ColumnMappings.Add("ProductID", "ProductID");
                              bulkCopy.ColumnMappings.Add("UnitPrice", "UnitPrice");
                              bulkCopy.WriteToServer(readerDetail);
          
                              // Write readerDetail to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerDetail);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerDetail.Close();
                              }
                          }
          
                          // Perform a final count on the destination
                          // tables to see how many rows were added. 
                          long countEndHeader = System.Convert.ToInt32(
                              countRowHeader.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Header table.",
                              countEndHeader - countStartHeader);
                          long countEndDetail = System.Convert.ToInt32(
                              countRowDetail.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Detail table.",
                              countEndDetail - countStartDetail);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint">
            <summary>
        Defines the sort order for a column in a <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance's destination table, according to the clustered index on the table.
      </summary><remarks>
        <para>
          Column order hints define the sort order of the column in the destination table.
        </para>
        <para>
          SqlBulkCopy's performance is improved if the data being imported is sorted according to the clustered index on the table, if any. If the data is sorted in an order that differs from the order of a clustered index key or if there is no clustered index on the table, the order hint is ignored.
        </para>
        <para>
          Order hints can be specified for any number of columns in the destination table. By default, the bulk insert operation assumes the data is unordered if no hints are provided.
        </para>
        <para>
          The column names supplied must be valid column names in the destination table. The order in which hints can be specified is arbitrary. A single column name cannot be specified more than once.
        </para>
        <para>
          If the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection is not empty, order hints can only be provided for valid destination columns which have been mapped.
        </para>
        <para>
          If a <see cref="T:Microsoft.Data.SqlClient.SortOrder" /> of Unspecified is given, an <see cref="T:System.ArgumentException" /> will be thrown.
        </para>
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database.  A SqlBulkCopyColumnOrderHint object is used to define the sort order for the ProductNumber destination column.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHint -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoMatchingColumns";
          
                          // Setup an order hint for the ProductNumber column.
                          SqlBulkCopyColumnOrderHint hintNumber =
                              new SqlBulkCopyColumnOrderHint("ProductNumber", SortOrder.Ascending);
                          bulkCopy.ColumnOrderHints.Add(hintNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString() 
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint.#ctor(System.String,Microsoft.Data.SqlClient.SortOrder)">
            <param name="column">
        The name of the destination column within the destination table.
      </param><param name="sortOrder">
        The sort order of the corresponding destination column.
      </param><summary>
        Creates a new column order hint for the specified destination column.
      </summary><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database.  A SqlBulkCopyColumnOrderHint object is used to define the sort order for the ProductNumber destination column.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHint -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoMatchingColumns";
          
                          // Setup an order hint for the ProductNumber column.
                          SqlBulkCopyColumnOrderHint hintNumber =
                              new SqlBulkCopyColumnOrderHint("ProductNumber", SortOrder.Ascending);
                          bulkCopy.ColumnOrderHints.Add(hintNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString() 
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint.Column">
            <summary>
        Name of the destination column in the destination table for which the hint is being provided.
      </summary><value>
        The string value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint.Column" /> property.
      </value><remarks>
        An <see cref="T:System.ArgumentException" /> will be thrown if a null or empty string is given.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. A SqlBulkCopyColumnOrderHint object is used to define the sort order for the ProductNumber destination column.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHintColumn -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoMatchingColumns";
          
                          // Setup an order hint for the ProductNumber column.
                          SqlBulkCopyColumnOrderHint hintNumber =
                              new SqlBulkCopyColumnOrderHint("number", SortOrder.Ascending);
                          hintNumber.Column = "ProductNumber";
                          bulkCopy.ColumnOrderHints.Add(hintNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value is null or empty.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint.SortOrder">
            <summary>
        The sort order of the destination column in the destination table.
      </summary><value>
        The SortOrder value of the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint.SortOrder" /> property.
      </value><remarks>
        An <see cref="T:System.ArgumentException" /> will be thrown if a <see cref="T:Microsoft.Data.SqlClient.SortOrder" /> of Unspecified is given.
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. A SqlBulkCopyColumnOrderHint object is used to define the sort order for the ProductNumber destination column.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHintSortOrder -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object.
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoMatchingColumns";
          
                          // Setup an order hint for the ProductNumber column.
                          SqlBulkCopyColumnOrderHint hintNumber =
                              new SqlBulkCopyColumnOrderHint("ProductNumber", SortOrder.Ascending);
                          hintNumber.SortOrder = SortOrder.Descending;
                          bulkCopy.ColumnOrderHints.Add(hintNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The sort order cannot be unspecified for a column order hint.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection">
            <summary>
        Collection of <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> objects that inherits from <see cref="T:System.Collections.CollectionBase" />.
      </summary><remarks>
        <para>
          Column order hints define the sort order of the column in the destination table.
        </para>
        <para>
          SqlBulkCopy's performance is improved if the data being imported is sorted according to the clustered index on the table, if any. If the data is sorted in an order that differs from the order of a clustered index key or if there is no clustered index on the table, the order hint is ignored.
        </para>
        <para>
          Order hints can be specified for any number of columns in the destination table. By default, the bulk insert operation assumes the data is unordered if no hints are provided.
        </para>
        <para>
          The column names supplied must be valid column names in the destination table. The order in which hints can be specified is arbitrary. A single column name cannot be specified more than once.
        </para>
        <para>
          If the <see cref="P:Microsoft.Data.SqlClient.SqlBulkCopy.ColumnMappings" /> collection is not empty, order hints can only be provided for valid destination columns which have been mapped.
        </para>
        <para>
          If a <see cref="T:Microsoft.Data.SqlClient.SortOrder" /> of Unspecified is given, an <see cref="T:System.ArgumentException" /> will be thrown.
        </para>
      </remarks><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" />s are added to the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" /> of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object to specify order hints for the bulk copy operation.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHintCollection -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoMatchingColumns";
          
                          // Specify the sort order for the ProductNumber column in 
                          // the destination table.
                          bulkCopy.ColumnOrderHints.Add("ProductNumber", SortOrder.Ascending);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Item(System.Int32)">
            <param name="index">
        The zero-based index of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> to find.
      </param><summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object at the specified index.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object.
      </value><exception cref="T:System.ArgumentOutOfRangeException">
        The index must be non-negative and less than the size of the collection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Add(Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint)">
            <param name="columnOrderHint">
        The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object that describes the order hint to be added to the collection.
      </param><summary>
        Adds the specified order hint to the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" />.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object.
      </returns><example>
        <para>
          The following example bulk copies data from a source table in the <b>AdventureWorks</b> sample database to a destination table in the same database. A SqlBulkCopyColumnOrderHint object is used to define the sort order for the <b>ProductNumber</b> destination column.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBukCopy_ColumnOrderHintCollectionAdd -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader =
                          commandSourceData.ExecuteReader();
          
                      // Set up the bulk copy object. 
                      using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoMatchingColumns";
          
                          // Specify the sort order for the ProductNumber column in 
                          // the destination table.
                          // Setup an order hint for the ProductNumber column.
                          SqlBulkCopyColumnOrderHint hintNumber =
                              new SqlBulkCopyColumnOrderHint("ProductNumber", SortOrder.Ascending);
                          bulkCopy.ColumnOrderHints.Add(hintNumber);
          
                          // Write from the source to the destination.
                          try
                          {
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value is null.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Add(System.String,Microsoft.Data.SqlClient.SortOrder)">
            <!-- No matching elements were found for the following include tag --><include file="../../../../doc/snippets/Microsoft.Data.SqlClient/SqlBulkCopyColumnOrderHintCollection.xml" path="docs/members[@name=&quot;SqlBulkCopyColumnOrderHintCollection&quot;]/Add[@name=&quot;columnStringAndsortOrderSortOrder&quot;]/*" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Clear">
            <summary>
        Clears the contents of the collection.
      </summary><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Clear" /> method is most commonly used when you use a single <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to process more than one bulk copy operation. If you create column order hints for one bulk copy operation, you must clear the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" /> after the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method and before processing the next bulk copy.
        </para>
        <para>
          Performing several bulk copies using the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance will usually be more efficient from a performance point of view than using a separate <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> for each operation.
        </para>
      </remarks><example>
        <para>
          The following example performs two bulk copy operations. The first operation copies sales order header information, and the second copies sales order details. The example defines a column order hint for each bulk copy operation. The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Clear" /> method must be used after the first bulk copy is performed and before the next bulk copy's order hint is defined.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHintCollectionClear -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Empty the destination tables. 
                      SqlCommand deleteHeader = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      deleteHeader.ExecuteNonQuery();
                      SqlCommand deleteDetail = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      deleteDetail.ExecuteNonQuery();
          
                      // Perform an initial count on the destination
                      //  table with matching columns. 
                      SqlCommand countRowHeader = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      long countStartHeader = System.Convert.ToInt32(
                          countRowHeader.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Header table = {0}",
                          countStartHeader);
          
                      // Perform an initial count on the destination
                      // table with different column positions. 
                      SqlCommand countRowDetail = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      long countStartDetail = System.Convert.ToInt32(
                          countRowDetail.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Detail table = {0}",
                          countStartDetail);
          
                      // Get data from the source table as a SqlDataReader.
                      // The Sales.SalesOrderHeader and Sales.SalesOrderDetail
                      // tables are quite large and could easily cause a timeout
                      // if all data from the tables is added to the destination. 
                      // To keep the example simple and quick, a parameter is  
                      // used to select only orders for a particular account 
                      // as the source for the bulk insert. 
                      SqlCommand headerData = new SqlCommand(
                          "SELECT [SalesOrderID], [OrderDate], " +
                          "[AccountNumber] FROM [Sales].[SalesOrderHeader] " +
                          "WHERE [AccountNumber] = @accountNumber;",
                          connection);
                      SqlParameter parameterAccount = new SqlParameter();
                      parameterAccount.ParameterName = "@accountNumber";
                      parameterAccount.SqlDbType = SqlDbType.NVarChar;
                      parameterAccount.Direction = ParameterDirection.Input;
                      parameterAccount.Value = "10-4020-000034";
                      headerData.Parameters.Add(parameterAccount);
                      SqlDataReader readerHeader = headerData.ExecuteReader();
          
                      // Get the Detail data in a separate connection.
                      using (SqlConnection connection2 = new SqlConnection(connectionString))
                      {
                          connection2.Open();
                          SqlCommand sourceDetailData = new SqlCommand(
                              "SELECT [Sales].[SalesOrderDetail].[SalesOrderID], [SalesOrderDetailID], " +
                              "[OrderQty], [ProductID], [UnitPrice] FROM [Sales].[SalesOrderDetail] " +
                              "INNER JOIN [Sales].[SalesOrderHeader] ON [Sales].[SalesOrderDetail]." +
                              "[SalesOrderID] = [Sales].[SalesOrderHeader].[SalesOrderID] " +
                              "WHERE [AccountNumber] = @accountNumber;", connection2);
          
                          SqlParameter accountDetail = new SqlParameter();
                          accountDetail.ParameterName = "@accountNumber";
                          accountDetail.SqlDbType = SqlDbType.NVarChar;
                          accountDetail.Direction = ParameterDirection.Input;
                          accountDetail.Value = "10-4020-000034";
                          sourceDetailData.Parameters.Add(accountDetail);
                          SqlDataReader readerDetail = sourceDetailData.ExecuteReader();
          
                          // Create the SqlBulkCopy object. 
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                          {
                              bulkCopy.DestinationTableName =
                                  "dbo.BulkCopyDemoOrderHeader";
          
                              // Guarantee that columns are mapped correctly by
                              // defining the column mappings for the order.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("OrderDate", "OrderDate");
                              bulkCopy.ColumnMappings.Add("AccountNumber", "AccountNumber");
          
                              // Add order hint for OrderDate column.
                              bulkCopy.ColumnOrderHints.Add("OrderDate", SortOrder.Ascending);
          
                              // Write readerHeader to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerHeader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerHeader.Close();
                              }
          
                              // Set up the order details destination. 
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderDetail";
          
                              // Clear the ColumnMappingCollection.
                              bulkCopy.ColumnMappings.Clear();
          
                              // Add order detail column mappings.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("SalesOrderDetailID", "SalesOrderDetailID");
                              bulkCopy.ColumnMappings.Add("OrderQty", "OrderQty");
                              bulkCopy.ColumnMappings.Add("ProductID", "ProductID");
                              bulkCopy.ColumnMappings.Add("UnitPrice", "UnitPrice");
          
                              // Clear the ColumnOrderHintCollection.
                              bulkCopy.ColumnOrderHints.Clear();
          
                              // Add order hint for SalesOrderID column.
                              bulkCopy.ColumnOrderHints.Add("SalesOrderID", SortOrder.Ascending);
          
                              // Write readerDetail to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerDetail);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerDetail.Close();
                              }
                          }
          
                          // Perform a final count on the destination
                          // tables to see how many rows were added. 
                          long countEndHeader = System.Convert.ToInt32(
                              countRowHeader.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Header table.",
                              countEndHeader - countStartHeader);
                          long countEndDetail = System.Convert.ToInt32(
                              countRowDetail.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Detail table.",
                              countEndDetail - countStartDetail);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file. 
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Contains(Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint)">
            <param name="value">
        A valid <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object.
      </param><summary>
        Gets a value indicating whether a specified <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object exists in the collection.
      </summary><returns>
        <see langword="true" /> if the specified column order hint exists in the collection; otherwise <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.CopyTo(Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint[],System.Int32)">
            <param name="array">
        The one-dimensional <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> array that is the destination of the elements copied from <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" />. The array must have zero-based indexing.
      </param><param name="index">
        The zero-based index in <paramref name="array" /> at which copying begins.
      </param><summary>
        Copies the elements of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" /> to an array of <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> items, starting at a particular index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.IndexOf(Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint)">
            <param name="value">
        The <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object for which to search.
      </param><summary>
        Gets the index of the specified <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object.
      </summary><returns>
        The zero-based index of the column order hint, or -1 if the column order hint is not found in the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Insert(System.Int32,Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint)">
            <param name="index">
        Integer value of the location within the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" /> at which to insert the new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" />.
      </param><param name="columnOrderHint">
        <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object to be inserted in the collection.
      </param><summary>
        Insert a new <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> at the index specified.
      </summary><remarks>
        The order in which column order hints can be added is arbitrary.
      </remarks><exception cref="T:System.ArgumentOutOfRangeException">
        The index is less than zero or greater than the size of the collection.
      </exception><exception cref="T:System.ArgumentNullException">
        A null column order hint cannot be added to the collection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Remove(Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint)">
            <param name="columnOrderHint"> <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object to be removed from the collection.</param><summary>
        Removes the specified <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> element from the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" />.
      </summary><remarks>
        <para>
          The Remove method is most commonly used when you use a single <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to process more than one bulk copy operation. If you create column order hints for one bulk copy operation, you must clear the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" /> after the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method and before processing the next bulk copy.
        </para>
        <para>
          You can clear the entire collection by using the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Clear" /> method, or remove hints individually using the Remove method or the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.RemoveAt" /> method.
        </para>
        <para>
          Performing several bulk copies using the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance will usually be more efficient from a performance point of view than using a separate <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> for each operation.
        </para>
      </remarks><example>
        <para>
          The following example performs two bulk copy operations. The first operation copies sales order header information, and the second copies sales order details. The example defines a column order hint for the <b>OrderDate</b> column in the first bulk copy operation. The hint is removed before the second bulk copy operation.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHintCollectionRemove -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();

                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Empty the destination tables. 
                      SqlCommand deleteHeader = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      deleteHeader.ExecuteNonQuery();
                      SqlCommand deleteDetail = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      deleteDetail.ExecuteNonQuery();
          
                      // Perform an initial count on the destination
                      //  table with matching columns. 
                      SqlCommand countRowHeader = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      long countStartHeader = System.Convert.ToInt32(
                          countRowHeader.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Header table = {0}",
                          countStartHeader);
          
                      // Perform an initial count on the destination
                      // table with different column positions. 
                      SqlCommand countRowDetail = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      long countStartDetail = System.Convert.ToInt32(
                          countRowDetail.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Detail table = {0}",
                          countStartDetail);
          
                      // Get data from the source table as a SqlDataReader.
                      // The Sales.SalesOrderHeader and Sales.SalesOrderDetail
                      // tables are quite large and could easily cause a timeout
                      // if all data from the tables is added to the destination. 
                      // To keep the example simple and quick, a parameter is  
                      // used to select only orders for a particular account 
                      // as the source for the bulk insert. 
                      SqlCommand headerData = new SqlCommand(
                          "SELECT [SalesOrderID], [OrderDate], " +
                          "[AccountNumber] FROM [Sales].[SalesOrderHeader] " +
                          "WHERE [AccountNumber] = @accountNumber;",
                          connection);
                      SqlParameter parameterAccount = new SqlParameter();
                      parameterAccount.ParameterName = "@accountNumber";
                      parameterAccount.SqlDbType = SqlDbType.NVarChar;
                      parameterAccount.Direction = ParameterDirection.Input;
                      parameterAccount.Value = "10-4020-000034";
                      headerData.Parameters.Add(parameterAccount);
                      SqlDataReader readerHeader = headerData.ExecuteReader();
          
                      // Get the Detail data in a separate connection.
                      using (SqlConnection connection2 = new SqlConnection(connectionString))
                      {
                          connection2.Open();
                          SqlCommand sourceDetailData = new SqlCommand(
                              "SELECT [Sales].[SalesOrderDetail].[SalesOrderID], [SalesOrderDetailID], " +
                              "[OrderQty], [ProductID], [UnitPrice] FROM [Sales].[SalesOrderDetail] " +
                              "INNER JOIN [Sales].[SalesOrderHeader] ON [Sales].[SalesOrderDetail]." +
                              "[SalesOrderID] = [Sales].[SalesOrderHeader].[SalesOrderID] " +
                              "WHERE [AccountNumber] = @accountNumber;", connection2);
          
                          SqlParameter accountDetail = new SqlParameter();
                          accountDetail.ParameterName = "@accountNumber";
                          accountDetail.SqlDbType = SqlDbType.NVarChar;
                          accountDetail.Direction = ParameterDirection.Input;
                          accountDetail.Value = "10-4020-000034";
                          sourceDetailData.Parameters.Add(accountDetail);
                          SqlDataReader readerDetail = sourceDetailData.ExecuteReader();
          
                          // Create the SqlBulkCopy object. 
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                          {
                              bulkCopy.DestinationTableName =
                                  "dbo.BulkCopyDemoOrderHeader";
          
                              // Guarantee that columns are mapped correctly by
                              // defining the column mappings for the order.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("OrderDate", "OrderDate");
                              bulkCopy.ColumnMappings.Add("AccountNumber", "AccountNumber");
          
                              // Add the order hint for the OrderDate column.
                              SqlBulkCopyColumnOrderHint hintDate =
                                  new SqlBulkCopyColumnOrderHint("OrderDate", SortOrder.Ascending);
                              bulkCopy.ColumnOrderHints.Add(hintDate);
          
                              // Write readerHeader to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerHeader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerHeader.Close();
                              }
          
                              // Set up the order details destination. 
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderDetail";
          
                              // Clear the ColumnMappingCollection.
                              bulkCopy.ColumnMappings.Clear();
          
                              // Add order detail column mappings.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("SalesOrderDetailID", "SalesOrderDetailID");
                              bulkCopy.ColumnMappings.Add("OrderQty", "OrderQty");
                              bulkCopy.ColumnMappings.Add("ProductID", "ProductID");
                              bulkCopy.ColumnMappings.Add("UnitPrice", "UnitPrice");
          
                              // Remove the order hint for the OrderDate column.
                              bulkCopy.ColumnOrderHints.Remove(hintDate);
          
                              // Write readerDetail to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerDetail);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerDetail.Close();
                              }
                          }
          
                          // Perform a final count on the destination
                          // tables to see how many rows were added. 
                          long countEndHeader = System.Convert.ToInt32(
                              countRowHeader.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Header table.",
                              countEndHeader - countStartHeader);
                          long countEndDetail = System.Convert.ToInt32(
                              countRowDetail.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Detail table.",
                              countEndDetail - countStartDetail);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
          
              private static string GetConnectionString() 
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        The value is null.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.RemoveAt(System.Int32)">
            <param name="index">
        The zero-based index of the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHint" /> object to be removed from the collection.
      </param><summary>
        Removes the column order hint at the specified index from the collection.
      </summary><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.RemoveAt" /> method is most commonly used when you use a single <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to process more than one bulk copy operation. If you create column order hints for one bulk copy operation, you must clear the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection" /> after the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> method and before processing the next bulk copy. You can clear the entire collection by using the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Clear" /> method, or remove hints individually using the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.Remove" /> method or the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopyColumnOrderHintCollection.RemoveAt" /> method.
        </para>
        <para>
          Performing several bulk copies using the same <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance will usually be more efficient from a performance point of view than using a separate <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> for each operation.
        </para>
      </remarks><example>
        <para>
          The following example performs two bulk copy operations. The first operation copies sales order header information, and the second copies sales order details. The example defines a column order hint for the <b>OrderDate</b> column in the first bulk copy operation. The hint is removed before the second bulk copy operation.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_ColumnOrderHintCollectionRemoveAt -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  
                  // Open a connection to the AdventureWorks database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      // Empty the destination tables. 
                      SqlCommand deleteHeader = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      deleteHeader.ExecuteNonQuery();
                      SqlCommand deleteDetail = new SqlCommand(
                          "DELETE FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      deleteDetail.ExecuteNonQuery();
          
                      // Perform an initial count on the destination
                      //  table with matching columns. 
                      SqlCommand countRowHeader = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderHeader;",
                          connection);
                      long countStartHeader = System.Convert.ToInt32(
                          countRowHeader.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Header table = {0}",
                          countStartHeader);
          
                      // Perform an initial count on the destination
                      // table with different column positions. 
                      SqlCommand countRowDetail = new SqlCommand(
                          "SELECT COUNT(*) FROM dbo.BulkCopyDemoOrderDetail;",
                          connection);
                      long countStartDetail = System.Convert.ToInt32(
                          countRowDetail.ExecuteScalar());
                      Console.WriteLine(
                          "Starting row count for Detail table = {0}",
                          countStartDetail);
          
                      // Get data from the source table as a SqlDataReader.
                      // The Sales.SalesOrderHeader and Sales.SalesOrderDetail
                      // tables are quite large and could easily cause a timeout
                      // if all data from the tables is added to the destination. 
                      // To keep the example simple and quick, a parameter is  
                      // used to select only orders for a particular account 
                      // as the source for the bulk insert. 
                      SqlCommand headerData = new SqlCommand(
                          "SELECT [SalesOrderID], [OrderDate], " +
                          "[AccountNumber] FROM [Sales].[SalesOrderHeader] " +
                          "WHERE [AccountNumber] = @accountNumber;",
                          connection);
                      SqlParameter parameterAccount = new SqlParameter();
                      parameterAccount.ParameterName = "@accountNumber";
                      parameterAccount.SqlDbType = SqlDbType.NVarChar;
                      parameterAccount.Direction = ParameterDirection.Input;
                      parameterAccount.Value = "10-4020-000034";
                      headerData.Parameters.Add(parameterAccount);
                      SqlDataReader readerHeader = headerData.ExecuteReader();
          
                      // Get the Detail data in a separate connection.
                      using (SqlConnection connection2 = new SqlConnection(connectionString))
                      {
                          connection2.Open();
                          SqlCommand sourceDetailData = new SqlCommand(
                              "SELECT [Sales].[SalesOrderDetail].[SalesOrderID], [SalesOrderDetailID], " +
                              "[OrderQty], [ProductID], [UnitPrice] FROM [Sales].[SalesOrderDetail] " +
                              "INNER JOIN [Sales].[SalesOrderHeader] ON [Sales].[SalesOrderDetail]." +
                              "[SalesOrderID] = [Sales].[SalesOrderHeader].[SalesOrderID] " +
                              "WHERE [AccountNumber] = @accountNumber;", connection2);
          
                          SqlParameter accountDetail = new SqlParameter();
                          accountDetail.ParameterName = "@accountNumber";
                          accountDetail.SqlDbType = SqlDbType.NVarChar;
                          accountDetail.Direction = ParameterDirection.Input;
                          accountDetail.Value = "10-4020-000034";
                          sourceDetailData.Parameters.Add(accountDetail);
                          SqlDataReader readerDetail = sourceDetailData.ExecuteReader();
          
                          // Create the SqlBulkCopy object. 
                          using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connectionString))
                          {
                              bulkCopy.DestinationTableName =
                                  "dbo.BulkCopyDemoOrderHeader";
          
                              // Guarantee that columns are mapped correctly by
                              // defining the column mappings for the order.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("OrderDate", "OrderDate");
                              bulkCopy.ColumnMappings.Add("AccountNumber", "AccountNumber");
          
                              // Add the order hint for the OrderDate column.
                              SqlBulkCopyColumnOrderHint hintDate =
                                  new SqlBulkCopyColumnOrderHint("OrderDate", SortOrder.Ascending);
                              bulkCopy.ColumnOrderHints.Add(hintDate);
          
                              // Write readerHeader to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerHeader);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerHeader.Close();
                              }
          
                              // Set up the order details destination. 
                              bulkCopy.DestinationTableName = "dbo.BulkCopyDemoOrderDetail";
          
                              // Clear the ColumnMappingCollection.
                              bulkCopy.ColumnMappings.Clear();
          
                              // Add order detail column mappings.
                              bulkCopy.ColumnMappings.Add("SalesOrderID", "SalesOrderID");
                              bulkCopy.ColumnMappings.Add("SalesOrderDetailID", "SalesOrderDetailID");
                              bulkCopy.ColumnMappings.Add("OrderQty", "OrderQty");
                              bulkCopy.ColumnMappings.Add("ProductID", "ProductID");
                              bulkCopy.ColumnMappings.Add("UnitPrice", "UnitPrice");
          
                              // Remove the order hint for the OrderDate column.
                              bulkCopy.ColumnOrderHints.RemoveAt(0);
          
                              // Write readerDetail to the destination.
                              try
                              {
                                  bulkCopy.WriteToServer(readerDetail);
                              }
                              catch (Exception ex)
                              {
                                  Console.WriteLine(ex.Message);
                              }
                              finally
                              {
                                  readerDetail.Close();
                              }
                          }
          
                          // Perform a final count on the destination
                          // tables to see how many rows were added. 
                          long countEndHeader = System.Convert.ToInt32(
                              countRowHeader.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Header table.",
                              countEndHeader - countStartHeader);
                          long countEndDetail = System.Convert.ToInt32(
                              countRowDetail.ExecuteScalar());
                          Console.WriteLine("{0} rows were added to the Detail table.",
                              countEndDetail - countStartDetail);
                          Console.WriteLine("Press Enter to finish.");
                          Console.ReadLine();
                      }
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentOutOfRangeException">
        The index must be non-negative and less than the size of the collection.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBulkCopyOptions">
            <summary>
        Bitwise flag that specifies one or more options to use with an instance of <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" />.
      </summary><remarks>
        <para>
          You can use the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopyOptions" /> enumeration when you construct a <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> instance to change how the <see cref="O:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer" /> methods for that instance behave.
        </para>
      </remarks><example>
        <para>
          The following console application demonstrates how to perform a bulk load that copies the value in the identity column of the source table to the corresponding column in the destination table, instead of generating a new value for each row's identity column.
        </para>
        <para>
          To see how the option changes the way the bulk load works, run the sample with the <b> dbo.BulkCopyDemoMatchingColumns</b> table empty. All rows load from the source. Next, run the sample again without emptying the table. An exception is thrown, and the code writes a message to the console window notifying you that rows were not added because of primary key violations.
        </para>
        <note type="important">
          This sample will not run unless you have created the work tables as described in <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/bulk-copy-example-setup">Bulk Copy Example Setup</see>.
        </note>
        <para>
          This code is provided to demonstrate the syntax for using <b>SqlBulkCopy</b> only. If the source and destination tables are in the same SQL Server instance, it is easier and faster to use a Transact-SQL <c>INSERT … SELECT</c> statement to copy the data.
        </para>
        <!-- SqlBulkCopy_KeepIdentity -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  // Open a sourceConnection to the AdventureWorks database.
                  using (SqlConnection sourceConnection = new SqlConnection(connectionString))
                  {
                      sourceConnection.Open();
          
                      // Perform an initial count on the destination table.
                      SqlCommand commandRowCount = new SqlCommand(
                          "SELECT COUNT(*) FROM " +
                          "dbo.BulkCopyDemoMatchingColumns;",
                          sourceConnection);
                      long countStart = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Starting row count = {0}", countStart);
          
                      // Get data from the source table as a SqlDataReader.
                      SqlCommand commandSourceData = new SqlCommand(
                          "SELECT ProductID, Name, " +
                          "ProductNumber " +
                          "FROM Production.Product;", sourceConnection);
                      SqlDataReader reader = commandSourceData.ExecuteReader();
          
                      // Create the SqlBulkCopy object using a connection string 
                      // and the KeepIdentity option. 
                      // In the real world you would not use SqlBulkCopy to move
                      // data from one table to the other in the same database.
                      using (SqlBulkCopy bulkCopy =
                          new SqlBulkCopy(connectionString, SqlBulkCopyOptions.KeepIdentity))
                      {
                          bulkCopy.DestinationTableName =
                              "dbo.BulkCopyDemoMatchingColumns";
          
                          try
                          {
                              // Write from the source to the destination.
                              bulkCopy.WriteToServer(reader);
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine(ex.Message);
                          }
                          finally
                          {
                              // Close the SqlDataReader. The SqlBulkCopy
                              // object is automatically closed at the end
                              // of the using block.
                              reader.Close();
                          }
                      }
          
                      // Perform a final count on the destination 
                      // table to see how many rows were added.
                      long countEnd = System.Convert.ToInt32(
                          commandRowCount.ExecuteScalar());
                      Console.WriteLine("Ending row count = {0}", countEnd);
                      Console.WriteLine("{0} rows were added.", countEnd - countStart);
                      Console.WriteLine("Press Enter to finish.");
                      Console.ReadLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the sourceConnection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local); " +
                         " Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks;";
              }
          }
        </code>
      </example>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.AllowEncryptedValueModifications">
            <summary>
        <para>
          When specified, <b>AllowEncryptedValueModifications</b> enables bulk copying of encrypted data between tables or databases, without decrypting the data. Typically, an application would select data from encrypted columns from one table without decrypting the data (the app would connect to the database with the column encryption setting keyword set to disabled) and then would use this option to bulk insert the data, which is still encrypted.
        </para>
        <para>
          Use caution when specifying <b>AllowEncryptedValueModifications</b> as this may lead to corrupting the database because the driver does not check if the data is indeed encrypted, or if it is correctly encrypted using the same encryption type, algorithm and key as the target column.
        </para>
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.CheckConstraints">
            <summary>
        Check constraints while data is being inserted. By default, constraints are not checked.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.Default">
            <summary>
        Use the default values for all options.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.FireTriggers">
            <summary>
        When specified, cause the server to fire the insert triggers for the rows being inserted into the database.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.KeepIdentity">
            <summary>
        Preserve source identity values. When not specified, identity values are assigned by the destination.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.KeepNulls">
            <summary>
        Preserve null values in the destination table regardless of the settings for default values. When not specified, null values are replaced by default values where applicable.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.TableLock">
            <summary>
        Obtain a bulk update lock for the duration of the bulk copy operation. When not specified, row locks are used.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction">
            <summary>
        When specified, each batch of the bulk-copy operation will occur within a transaction. If you indicate this option and also provide a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> object to the constructor, an <see cref="T:System.ArgumentException" /> occurs.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlClientFactory">
            <summary>
        Represents a set of methods for creating instances of the <see cref="N:Microsoft.Data.SqlClient" /> provider's implementation of the data source classes.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientFactory.Instance">
            <summary>
        Gets an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlClientFactory" />. This can be used to retrieve strongly typed data objects.
      </summary><example>
        <para>
          The following code fragment uses the <see cref="P:Microsoft.Data.SqlClient.SqlClientFactory.Instance" /> property to retrieve a <see cref="T:Microsoft.Data.SqlClient.SqlClientFactory" /> instance, and then return a strongly typed <see cref="T:System.Data.Common.DbCommand" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbCommand cmd = newFactory.CreateCommand();
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateCommand">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbCommand" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbCommand" />.
      </returns><example>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbCommand" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbCommand cmd = newFactory.CreateCommand();
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateCommandBuilder">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbCommandBuilder" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbCommandBuilder" />.
      </returns><example>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbCommandBuilder" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbCommandBuilder cmd = newFactory.CreateCommandBuilder();
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateConnection">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbConnection" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbConnection" />.
      </returns><remarks>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbConnection" /> instance:
        </para>
        <code>
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbConnection cmd = newFactory.CreateConnection();
        </code>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateConnectionStringBuilder">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbConnectionStringBuilder" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbConnectionStringBuilder" />.
      </returns><example>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbConnectionStringBuilder" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbConnectionStringBuilder cmd = newFactory.CreateConnectionStringBuilder();
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateDataAdapter">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbDataAdapter" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbDataAdapter" />.
      </returns><example>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbDataAdapter" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbDataAdapter cmd = newFactory.CreateDataAdapter();
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateParameter">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbParameter" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbParameter" />.
      </returns><example>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbParameter" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbParameter cmd = newFactory.CreateParameter();
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateDataSourceEnumerator">
            <summary>
        Returns a new <see cref="T:System.Data.Sql.SqlDataSourceEnumerator" />.
      </summary><returns>
        A new data source enumerator.
      </returns><example>
        <para>
          The following example displays a list of all available SQL Server data sources, using code that could enumerate data sources for any provider.
        </para>
        <!-- SqlClientFactory_DataSourceEnumerator -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  // List all SQL Server instances:
                  ListServers(SqlClientFactory.Instance);
          
                  Console.WriteLine();
                  Console.WriteLine("Press any key to continue...");
                  Console.ReadKey();
              }
              private static void ListServers(DbProviderFactory factory)
              {
                  // This procedure is provider-agnostic, and can list
                  // instances of any provider's servers. Of course, 
                  // not all providers can create a data source enumerator,
                  // so it's best to check the CanCreateDataSourceEnumerator 
                  // property before attempting to list the data sources.
                  if (factory.CanCreateDataSourceEnumerator)
                  {
                      DbDataSourceEnumerator instance =
                          factory.CreateDataSourceEnumerator();
                      DataTable table = instance.GetDataSources();
          
                      foreach (DataRow row in table.Rows)
                      {
                          Console.WriteLine("{0}\\{1}",
                              row["ServerName"], row["InstanceName"]);
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlClientFactory.CanCreateBatch">
            <summary>
        Gets a value that indicates whether a <see cref="T:System.Data.Common.DbBatch" /> can be created.
      </summary><value>
        <see langword="true" /> if a <see cref="T:System.Data.Common.DbBatch" /> can be created; otherwise, <see langword="false" />.
      </value><remarks>
        The <see cref="T:System.Data.Common.DbProviderFactory" /> class provides the <see cref="P:System.Data.Common.DbProviderFactory.CanCreateBatch" /> property so that inheritors can indicate whether they can provide a DbBatch. The <see cref="T:Microsoft.Data.SqlClient.SqlClientFactory" /> displays this property, but its value is always <c>true</c>.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateBatch">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbBatch" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbBatch" />.
      </returns><example>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbBatch" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbParameter cmd = newFactory.CreateBatch();
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientFactory.CreateBatchCommand">
            <summary>
        Returns a strongly typed <see cref="T:System.Data.Common.DbBatchCommand" /> instance.
      </summary><returns>
        A new strongly typed instance of <see cref="T:System.Data.Common.DbBatchCommand" />.
      </returns><example>
        <para>
          The following code fragment returns a strongly typed <see cref="T:System.Data.Common.DbBatchCommand" /> instance:
        </para>
        <code language="c#">
          SqlClientFactory newFactory = SqlClientFactory.Instance;
          DbParameter cmd = newFactory.CreateBatchCommand();
        </code>
      </example>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlClientLogger">
            <summary>
        Represents a SQL client logger.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientLogger.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlClientLogger" /> class.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlClientLogger.IsLoggingEnabled">
            <summary>
        Gets a value that indicates whether bid tracing is enabled.
      </summary><value>
        <see langword="true" /> if bid tracing is enabled; otherwise, <see langword="false" />.
      </value>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientLogger.LogWarning(System.String,System.String,System.String)">
            <param name="type">
        The type to be logged.
      </param><param name="method">
        The logging method.
      </param><param name="message">
        The message to be logged.
      </param><summary>
        Logs warning through a specified method of the current instance type.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientLogger.LogAssert(System.Boolean,System.String,System.String,System.String)">
            <param name="value">
        <see langword="false" /> to log the message; otherwise, <see langword="true" />.
      </param><param name="type">
        The type to be logged.
      </param><param name="method">
        The logging method.
      </param><param name="message">
        The message to be logged.
      </param><summary>
        Logs the specified message if <paramref name="value" /> is <see langword="false" />.
      </summary><returns>
        <see langword="true" /> if the message is not logged; otherwise, <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientLogger.LogError(System.String,System.String,System.String)">
            <param name="type">
        The type to be logged.
      </param><param name="method">
        The logging method.
      </param><param name="message">
        The message to be logged.
      </param><summary>
        Logs an error through a specified method of the current instance type.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlClientLogger.LogInfo(System.String,System.String,System.String)">
            <param name="type">
        The type to be logged.
      </param><param name="method">
        The logging method.
      </param><param name="message">
        The message to be logged.
      </param><summary>
        Logs information through a specified method of the current instance type.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames">
            <summary>
        Provides a list of constants for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method to retrieve metadata collections.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.Columns">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>Columns</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.Databases">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>Databases</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.ForeignKeys">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>ForeignKeys</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.IndexColumns">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>IndexColumns</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.Indexes">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>Indexes</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.ProcedureParameters">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>ProcedureParameters</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.Procedures">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>Procedures</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.Tables">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>Tables</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.UserDefinedTypes">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>UserDefinedTypes</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.Users">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>Users</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.ViewColumns">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>ViewColumns</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.Views">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>Views</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.AllColumns">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>AllColumns</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.ColumnSetColumns">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>ColumnSetColumns</b> collection.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlClientMetaDataCollectionNames.StructuredTypeMembers">
            <summary>
        A constant for use with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)" /> method that represents the <b>StructuredTypeMembers</b> collection.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConnectionAttestationProtocol">
            <summary>
        Specifies a value for Attestation Protocol.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionAttestationProtocol.NotSpecified">
            <summary>
        If the attestation protocol is not specified. Use this as default value.
      </summary><value>
        0
      </value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionAttestationProtocol.AAS">
            <summary>
        Attestation protocol for Azure Attestation Service
      </summary><value>
        1
      </value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionAttestationProtocol.None">
            <summary>
        Attestation protocol for no attestation. Only compatible with Virtualization-based security (VBS) enclaves. An Enclave Attestation Url is not required when using this protocol.
      </summary><value>
        2
      </value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionAttestationProtocol.HGS">
            <summary>
        Attestation protocol for Host Guardian Service
      </summary><value>
        3
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConnectionIPAddressPreference">
            <summary>
        Specifies a value for IP address preference during a TCP connection.
      </summary><remarks>
        If <c>Multi Subnet Failover</c> is set to <c>true</c>, this setting has no effect.
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionIPAddressPreference.IPv4First">
            <summary>
        Connects using IPv4 address(es) first. If the connection fails, try IPv6 address(es), if provided. This is the default value.
      </summary><value>0</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionIPAddressPreference.IPv6First">
            <summary>
        Connect using IPv6 address(es) first. If the connection fails, try IPv4 address(es), if available.
      </summary><value>1</value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionIPAddressPreference.UsePlatformDefault">
            <summary>
        Connects with IP addresses in the order the underlying platform or operating system provides them.
      </summary><value>2</value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption">
            <summary>
        These options are used to control encryption behavior of the communication between the server and the client.
      </summary><remarks>
        Implicit conversions have been added to maintain backwards compatibility with boolean behavior for the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Encrypt" /> property. When converting from a boolean, a value of <see langword="true" /> converts to <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" /> and a value of <see langword="false" /> converts to <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Optional" />. When converting to a boolean, <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" />, <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Strict" />, and <see langword="null" /> convert to <see langword="true" /> and <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Optional" /> converts <see langword="false" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Parse(System.String)">
            <summary>
        Converts the specified string representation of a logical value to its <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> equivalent.
      </summary><param name="value">
        A string containing the value to convert.
      </param><returns>
        An object that is equivalent to <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> contained in <paramref name="value" />.
      </returns><exception cref="T:System.ArgumentException">
        Throws exception if provided <paramref name="value" /> is not convertible to <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> type.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.TryParse(System.String,Microsoft.Data.SqlClient.SqlConnectionEncryptOption@)">
            <summary>
        Converts the specified string representation of a logical value to its <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> equivalent and returns a value that indicates whether the conversion succeeded.
      </summary><param name="value">
        A string containing the value to convert.
      </param><param name="result">
        An object that is equivalent to <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> contained in <paramref name="value" />. <see langword="null" /> if conversion fails.
      </param><returns>
        <see langword="true" /> if the <paramref name="value" /> parameter was converted successfully; otherwise, <see langword="false" />.
      </returns><remarks>
        This method does not throw an exception if conversion fails.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Optional">
            <summary>
        Specifies that TLS encryption is optional when connecting to the server. If the server requires encryption, encryption will be negotiated.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory">
            <summary>
        Specifies that TLS encryption is required when connecting to the server. If the server doesn't support encryption, the connection will fail.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Strict">
            <summary>
        Enables and requires TDS 8.0, TLS encryption to the server. If the server doesn't support TDS 8.0, TLS encryption, the connection will fail.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.op_Implicit(System.Boolean)~Microsoft.Data.SqlClient.SqlConnectionEncryptOption">
            <param name="value">
        The boolean value to be used for implicit comparison.
      </param><summary>
        Enables implicit conversion of a boolean to a <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" />. A value of <see langword="true" /> converts to <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" />. A value of <see langword="false" /> converts to <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Optional" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.op_Implicit(Microsoft.Data.SqlClient.SqlConnectionEncryptOption)~System.Boolean">
            <param name="value">
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> value to be used for implicit comparison.
      </param><summary>
        Enables implicit conversion of a <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> to a boolean. <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" /> and <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Strict" /> convert to <see langword="true" />. <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Optional" /> converts to <see langword="false" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.ToString">
            <summary>
        Returns the string value of <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Equals(System.Object)">
            <summary>
        Compares the <see cref="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.ToString" /> representation of <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> to another <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.GetHashCode">
            <summary>
        Returns the hash code of the <see cref="M:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.ToString" /> value.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider">
            <summary>
        The implementation of the key store provider for Windows Certificate Store. This class enables using certificates stored in the Windows Certificate Store as column master keys. For details, see <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.ProviderName">
            <summary>
        The provider name.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.#ctor">
            <summary>
        Key store provider for Windows Certificate Store.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm. Currently, the only valid value is: <c>RSA_OAEP</c>
      </param><param name="encryptedColumnEncryptionKey">
        The encrypted column encryption key.
      </param><summary>
        Decrypts the specified encrypted value of a column encryption key. The encrypted value is expected to be encrypted using the certificate with the specified key path and using the specified algorithm. The format of the key path should be "Local Machine/My/&lt;certificate_thumbprint&gt;" or "Current User/My/&lt;certificate_thumbprint&gt;".
      </summary><returns>
        Returns <see cref="T:System.Byte" />. The decrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm. Currently, the only valid value is: <c>RSA_OAEP</c>
      </param><param name="columnEncryptionKey">
        The plaintext column encryption key.
      </param><summary>
        Encrypts a column encryption key using the certificate with the specified key path and using the specified algorithm. The format of the key path should be "Local Machine/My/&lt;certificate_thumbprint&gt;" or "Current User/My/&lt;certificate_thumbprint&gt;".
      </summary><returns>
        Returns <see cref="T:System.Byte" />. The encrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.SignColumnMasterKeyMetadata(System.String,System.Boolean)">
            <param name="masterKeyPath">
        The column master key path.
      </param><param name="allowEnclaveComputations">
        <see langword="true" /> to indicate that the column master key supports enclave computations; otherwise, <see langword="false" />.
      </param><summary>
        Digitally signs the column master key metadata with the column master key referenced by the <paramref name="masterKeyPath" /> parameter.
      </summary><returns>
        The signature of the column master key metadata.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider.VerifyColumnMasterKeyMetadata(System.String,System.Boolean,System.Byte[])">
            <param name="masterKeyPath">
        The complete path of an asymmetric key. The path format is specific to a key store provider.
      </param><param name="allowEnclaveComputations">
        A Boolean that indicates if this key can be sent to the trusted enclave.
      </param><param name="signature">
        The master key metadata signature.
      </param><summary>
        This function must be implemented by the corresponding Key Store providers. This function should use an asymmetric key identified by a key path and verify the masterkey metadata consisting of (masterKeyPath, allowEnclaveComputations, providerName).
      </summary><returns>
        A Boolean value that indicates if the master key metadata can be verified based on the provided signature.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider">
            <summary>
        The CMK Store provider implementation for using the Microsoft Cryptography API: Next Generation (CNG) with <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
      </summary><remarks>
        Enables storing Always Encrypted column master key keys in a store, such as a hardware security module (HSM), that supports the Microsoft Cryptography API: Next Generation (CNG).
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.ProviderName">
            <summary>
        A constant string for the provider name <c>MSSQL_CNG_STORE</c>&gt;.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider" /> class.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm.
      </param><param name="encryptedColumnEncryptionKey">
        The encrypted column encryption key.
      </param><summary>
        Decrypts the given encrypted value using an asymmetric key specified by the key path and the specified algorithm. The key path will be in the format of <c>[ProviderName]/KeyIdentifier</c> and should be an asymmetric key stored in the specified CNG key store provider. The valid algorithm used to encrypt/decrypt the CEK is <c>RSA_OAEP</c>.
      </summary><returns>
        The decrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm.
      </param><param name="columnEncryptionKey">
        The plaintext column encryption key.
      </param><summary>
        Encrypts the given plain text column encryption key using an asymmetric key specified by the key path and the specified algorithm. The key path will be in the format of <c>[ProviderName]/KeyIdentifier</c> and should be an asymmetric key stored in the specified CNG key store provider. The valid algorithm used to encrypt/decrypt the CEK is <c>RSA_OAEP</c>.
      </summary><returns>
        The encrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.SignColumnMasterKeyMetadata(System.String,System.Boolean)">
            <param name="masterKeyPath">
        The column master key path. The path format is specific to a key store provider.
      </param><param name="allowEnclaveComputations">
        <see langword="true" /> to indicate that the column master key supports enclave computations; otherwise, <see langword="false" />.
      </param><summary>
        Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.
      </summary><returns>
        The signature of the column master key metadata.
      </returns><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.SignColumnMasterKeyMetadata" /> method must be implemented by the corresponding key store providers. <see cref="P:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.SignColumnMasterKeyMetadata" /> should use an asymmetric key identified by a key path and sign the master key metadata consisting of <paramref name="masterKeyPath" />, <paramref name="allowEnclaveComputations" />, and <see cref="P:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.ProviderName" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCngProvider.VerifyColumnMasterKeyMetadata(System.String,System.Boolean,System.Byte[])">
            <param name="masterKeyPath">
        The complete path of an asymmetric key. The path format is specific to a key store provider.
      </param><param name="allowEnclaveComputations">
        A Boolean that indicates if this key can be sent to the trusted enclave.
      </param><param name="signature">
        The master key metadata signature.
      </param><summary>
        This function must be implemented by the corresponding Key Store providers. This function should use an asymmetric key identified by a key path and verify the master key metadata consisting of (masterKeyPath, allowEnclaveComputations, providerName).
      </summary><returns>
        A Boolean that indicates if the master key metadata can be verified based on the provided signature.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider">
            <summary>
        The CMK Store provider implementation for using Microsoft CAPI based Cryptographic Service Providers (CSP) with <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
      </summary><remarks>
        Enables storing Always Encrypted column master key keys in a store, such as a hardware security module (HSM), that supports the Microsoft CAPI based Cryptographic Service Providers (CSP).
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.ProviderName">
            <summary>
        A constant string for the provider name <c>MSSQL_CSP_PROVIDER</c>.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider" /> class.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm.
      </param><param name="encryptedColumnEncryptionKey">
        The encrypted column encryption key.
      </param><summary>
        Decrypts the given encrypted value using an asymmetric key specified by the key path and algorithm. The key path will be in the format of <c>[ProviderName]/KeyIdentifier</c> and should be an asymmetric key stored in the specified CSP provider. The valid algorithm used to encrypt/decrypt the CEK is <c>RSA_OAEP</c>'.
      </summary><returns>
        The decrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm.
      </param><param name="columnEncryptionKey">
        The plaintext column encryption key.
      </param><summary>
        Encrypts the given plain text column encryption key using an asymmetric key specified by the key path and the specified algorithm. The key path will be in the format of <c>[ProviderName]/KeyIdentifier</c> and should be an asymmetric key stored in the specified CSP provider. The valid algorithm used to encrypt/decrypt the CEK is <c>RSA_OAEP</c>.
      </summary><returns>
        The encrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.SignColumnMasterKeyMetadata(System.String,System.Boolean)">
            <param name="masterKeyPath">
        The column master key path. The path format is specific to a key store provider.
      </param><param name="allowEnclaveComputations">
        <see langword="true" /> to indicate that the column master key supports enclave computations; otherwise, <see langword="false" />.
      </param><summary>
        Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.
      </summary><returns>
        The signature of the column master key metadata.
      </returns><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.SignColumnMasterKeyMetadata" /> method must be implemented by the corresponding key store providers. <see cref="P:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.SignColumnMasterKeyMetadata" /> should use an asymmetric key identified by a key path and sign the master key metadata consisting of <paramref name="masterKeyPath" />, <paramref name="allowEnclaveComputations" />, and <see cref="P:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.ProviderName" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.VerifyColumnMasterKeyMetadata(System.String,System.Boolean,System.Byte[])">
            <param name="masterKeyPath">
        The complete path of an asymmetric key. The path format is specific to a key store provider.
      </param><param name="allowEnclaveComputations">
        A boolean that indicates if this key can be sent to the trusted enclave.
      </param><param name="signature">
        Master key metadata signature.
      </param><summary>
        This function must be implemented by the corresponding Key Store providers. This function should use an asymmetric key identified by a key path and sign the masterkey metadata consisting of (<paramref name="masterKeyPath" />, <paramref name="allowEnclaveComputations" />, <see cref="P:Microsoft.Data.SqlClient.SqlColumnEncryptionCspProvider.ProviderName" />).
      </summary><returns>
        A Boolean that indicates if the master key metadata can be verified based on the provided signature.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider">
            <summary>
        Base class for all key store providers. A custom provider must derive from this class and override its member functions and then register it using <see cref="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" />, <see cref="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProvidersOnConnection(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.RegisterColumnEncryptionKeyStoreProvidersOnCommand(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" />. For details see, <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.DecryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm.
      </param><param name="encryptedColumnEncryptionKey">
        The encrypted column encryption key.
      </param><summary>
        Decrypts the specified encrypted value of a column encryption key. The encrypted value is expected to be encrypted using the column master key with the specified key path and using the specified algorithm.
      </summary><returns>
        Returns <see cref="T:System.Byte" />. The decrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.EncryptColumnEncryptionKey(System.String,System.String,System.Byte[])">
            <param name="masterKeyPath">
        The master key path.
      </param><param name="encryptionAlgorithm">
        The encryption algorithm.
      </param><param name="columnEncryptionKey">
        The plaintext column encryption key.
      </param><summary>
        Encrypts a column encryption key using the column master key with the specified key path and using the specified algorithm.
      </summary><returns>
        Returns <see cref="T:System.Byte" />. The encrypted column encryption key.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.SignColumnMasterKeyMetadata(System.String,System.Boolean)">
            <param name="masterKeyPath">
        The column master key path.
      </param><param name="allowEnclaveComputations">
        <see langword="true" /> to indicate that the column master key supports enclave computations; otherwise, <see langword="false" />.
      </param><summary>
        When implemented in a derived class, digitally signs the column master key metadata with the column master key referenced by the <paramref name="masterKeyPath" /> parameter. The input values used to generate the signature should be the specified values of the <paramref name="masterKeyPath" /> and <paramref name="allowEnclaveComputations" /> parameters.
      </summary><returns>
        The signature of the column master key metadata.
      </returns><remarks>
        <para>
          To ensure that the <see cref="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.SignColumnMasterKeyMetadata" /> method doesn't break applications that rely on an old API, it throws a <see cref="T:System.NotImplementedException" /> exception by default.
        </para>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.SignColumnMasterKeyMetadata" /> method will be used by client tools that generate Column Master Keys (CMK) for customers. <see cref="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.SignColumnMasterKeyMetadata" /> must be implemented by the corresponding key store providers that wish to use enclaves with <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
        </para>
      </remarks><exception cref="T:System.NotImplementedException">
        In all cases.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.VerifyColumnMasterKeyMetadata(System.String,System.Boolean,System.Byte[])">
            <param name="masterKeyPath">
        The column master key path.
      </param><param name="allowEnclaveComputations">
        Indicates whether the column master key supports enclave computations.
      </param><param name="signature">
        The signature of the column master key metadata.
      </param><summary>
        When implemented in a derived class, this method is expected to verify the specified signature is valid for the column master key with the specified key path and the specified enclave behavior. The default implementation throws NotImplementedException.
      </summary><returns>
        When implemented in a derived class, the method is expected to return true if the specified signature is valid, or false if the specified signature is not valid. The default implementation throws NotImplementedException.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider.ColumnEncryptionKeyCacheTtl">
            <summary>
        Gets or sets the lifespan of the decrypted column encryption key in the cache. Once the timespan has elapsed, the decrypted column encryption key is discarded and must be revalidated.
      </summary><remarks>
        <para>
          Internally, there is a cache of column encryption keys (once they are decrypted). This is useful for rapidly decrypting multiple data values. The default value is 2 hours. Setting this value to zero disables caching.
        </para>
        <para>
          The column encryption keys decrypted by custom key store providers registered on a connection or command instance will not be cached. Custom key store providers should implement their own caching mechanism. Caching implemented by custom key store providers will be disabled by the driver if the key store provider instance is registered using <see cref="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" />. Any caching implementation should reference the value of this property before caching a column encryption key and not cache it if the value is zero. This will avoid duplicate caching and possible user confusion when they are trying to configure key caching.
        </para>
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting">
            <summary>
        Note that these settings cannot be used to bypass encryption and gain access to plaintext data. For details, see <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted (Database Engine)</see>.
      </summary><remarks>
        <list type="bullet">
          <item>
            If Always Encrypted is disabled for a query and the query has parameters that need to be encrypted (parameters that correspond to encrypted columns), the query will fail.
          </item>
          <item>
            If Always Encrypted is disabled for a query and the query returns results from encrypted columns, the query will return encrypted values. The encrypted values will have the varbinary datatype.
          </item>
        </list>
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting.Disabled">
            <summary>
        Specifies the connection does not use Always Encrypted. Should be used if no queries sent over the connection access encrypted columns.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting.Enabled">
            <summary>
        Enables Always Encrypted for the query.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting.ResultSetOnly">
            <summary>
        Specifies that only the results of the command should be processed by the Always Encrypted routine in the driver. Use this value when the command has no parameters that require encryption.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting.UseConnectionSetting">
            <summary>
        Specifies that the command should default to the Always Encrypted setting in the connection string.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlCommand">
            <summary>
        Represents a Transact-SQL statement or stored procedure to execute against a SQL Server database. This class cannot be inherited.
      </summary><remarks>
        <para>
          When an instance of <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> is created, the read/write properties are set to their initial values. For a list of these values, see the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> constructor.
        </para>
        <para>
          <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> features the following methods for executing commands at a SQL Server database:</para>
        <para>
          <list type="table">
            <listheader>
              <term>Item</term>
              <description>Description</description>
            </listheader>
            <item>
              <term><see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /></term>
              <description>
                Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, generally executing commands such as INSERT, DELETE, UPDATE, and SET statements. Each call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> must be paired with a call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> which finishes the operation, typically on a separate thread.
              </description>
            </item>
            <item>
              <term><see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /></term>
              <description>
                Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and retrieves one or more results sets from the server. Each call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> must be paired with a call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> which finishes the operation, typically on a separate thread.
              </description>
            </item>
            <item>
              <term><see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /></term>
              <description>
                Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />. Each call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> must be paired with a call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" />, which finishes the operation, typically on a separate thread, and returns an <see cref="T:System.Xml.XmlReader" /> object.
              </description>
            </item>
            <item>
              <term><see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /></term>
              <description>
                Executes commands that return rows. For increased performance, <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> invokes commands using the Transact-SQL <c>sp_executesql</c> system stored procedure. Therefore, <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> might not have the effect that you want if used to execute commands such as Transact-SQL SET statements.
              </description>
            </item>
            <item>
              <term><see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" /></term>
              <description>Executes commands such as Transact-SQL INSERT, DELETE, UPDATE, and SET statements.</description>
            </item>
            <item>
              <term><see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalar" /></term>
              <description>Retrieves a single value (for example, an aggregate value) from a database.</description>
            </item>
            <item>
              <term><see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /></term>
              <description>
                Sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds an <see cref="T:System.Xml.XmlReader" /> object.
              </description>
            </item>
          </list>
        </para>
        <para>
          You can reset the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property and reuse the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. However, you must close the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> before you can execute a new or previous command.
        </para>
        <para>
          If a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue.
        </para>
        <para>
          <note type="note">
            Nameless, also called ordinal, parameters are not supported by the .NET Framework Data Provider for SQL Server.
          </note>
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, and a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the data, writing it to the console. Finally, the example closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and then the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> as it exits the <c>using</c> code blocks.
        </para>
        <!-- SqlCommand -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace SqlCommandCs
          {
              class Program
              {
                  static void Main()
                  {
                      string str = "Data Source=(local);Initial Catalog=Northwind;"
                                 + "Integrated Security=SSPI";
                      ReadOrderData(str);
                  }
          
                  private static void ReadOrderData(string connectionString)
                  {
                      string queryString = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          SqlCommand command = new SqlCommand(queryString, connection);
                          connection.Open();
                          using (SqlDataReader reader = command.ExecuteReader())
                          {
                              while (reader.Read())
                              {
                                  Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));
                              }
                          }
                      }
                  }
              }
          }

        </code>
        <para>
          The following sample shows how to create and execute different types of SqlCommand objects.
        </para>
        <!-- SqlCommand_Setup -->
        <code language="sql">
          USE [master]
          GO
          
          CREATE DATABASE [MySchool]
          GO
          
          USE [MySchool]
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          CREATE procedure [dbo].[CourseExtInfo] @CourseId int
          as
          select c.CourseID,c.Title,c.Credits,d.Name as DepartmentName
          from Course as c left outer join Department as d on c.DepartmentID=d.DepartmentID
          where c.CourseID=@CourseId
          
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          create procedure [dbo].[DepartmentInfo] @DepartmentId int,@CourseCount int output
          as
          select @CourseCount=Count(c.CourseID)
          from course as c
          where c.DepartmentID=@DepartmentId
          
          select d.DepartmentID,d.Name,d.Budget,d.StartDate,d.Administrator
          from Department as d
          where d.DepartmentID=@DepartmentId
          
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          Create PROCEDURE [dbo].[GetDepartmentsOfSpecifiedYear]
          @Year int,@BudgetSum money output
          AS
          BEGIN
          SELECT @BudgetSum=SUM([Budget])
          FROM [MySchool].[dbo].[Department]
          Where YEAR([StartDate])=@Year
          
          SELECT [DepartmentID]
          ,[Name]
          ,[Budget]
          ,[StartDate]
          ,[Administrator]
          FROM [MySchool].[dbo].[Department]
          Where YEAR([StartDate])=@Year
          
          END
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,
          [Year] [smallint] NOT NULL,
          [Title] [nvarchar](100) NOT NULL,
          [Credits] [int] NOT NULL,
          [DepartmentID] [int] NOT NULL,
          CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED
          (
          [CourseID] ASC,
          [Year] ASC
          )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]
          
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,
          [Name] [nvarchar](50) NOT NULL,
          [Budget] [money] NOT NULL,
          [StartDate] [datetime] NOT NULL,
          [Administrator] [int] NULL,
          CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED
          (
          [DepartmentID] ASC
          )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]
          
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          CREATE TABLE [dbo].[Person]([PersonID] [int] IDENTITY(1,1) NOT NULL,
          [LastName] [nvarchar](50) NOT NULL,
          [FirstName] [nvarchar](50) NOT NULL,
          [HireDate] [datetime] NULL,
          [EnrollmentDate] [datetime] NULL,
          CONSTRAINT [PK_School.Student] PRIMARY KEY CLUSTERED
          (
          [PersonID] ASC
          )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]
          
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          CREATE TABLE [dbo].[StudentGrade]([EnrollmentID] [int] IDENTITY(1,1) NOT NULL,
          [CourseID] [nvarchar](10) NOT NULL,
          [StudentID] [int] NOT NULL,
          [Grade] [decimal](3, 2) NOT NULL,
          CONSTRAINT [PK_StudentGrade] PRIMARY KEY CLUSTERED
          (
          [EnrollmentID] ASC
          )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]
          
          GO
          
          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO
          create view [dbo].[EnglishCourse]
          as
          select c.CourseID,c.Title,c.Credits,c.DepartmentID
          from Course as c join Department as d on c.DepartmentID=d.DepartmentID
          where d.Name=N'English'
          
          GO
          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)
          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)
          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)
          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)
          SET IDENTITY_INSERT [dbo].[Department] ON
          
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)
          SET IDENTITY_INSERT [dbo].[Department] OFF
          SET IDENTITY_INSERT [dbo].[Person] ON
          
          INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (1, N'Hu', N'Nan', NULL, CAST(0x0000A0BF00000000 AS DateTime))
          INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (2, N'Norman', N'Laura', NULL, CAST(0x0000A0BF00000000 AS DateTime))
          INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (3, N'Olivotto', N'Nino', NULL, CAST(0x0000A0BF00000000 AS DateTime))
          INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (4, N'Anand', N'Arturo', NULL, CAST(0x0000A0BF00000000 AS DateTime))
          INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (5, N'Jai', N'Damien', NULL, CAST(0x0000A0BF00000000 AS DateTime))
          INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (6, N'Holt', N'Roger', CAST(0x000097F100000000 AS DateTime), NULL)
          INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (7, N'Martin', N'Randall', CAST(0x00008B1A00000000 AS DateTime), NULL)
          SET IDENTITY_INSERT [dbo].[Person] OFF
          SET IDENTITY_INSERT [dbo].[StudentGrade] ON
          
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (1, N'C1045', 1, CAST(3.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (2, N'C1045', 2, CAST(3.00 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (3, N'C1045', 3, CAST(2.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (4, N'C1045', 4, CAST(4.00 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (5, N'C1045', 5, CAST(3.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (6, N'C1061', 1, CAST(4.00 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (7, N'C1061', 3, CAST(3.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (8, N'C1061', 4, CAST(2.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (9, N'C1061', 5, CAST(1.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (10, N'C2021', 1, CAST(2.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (11, N'C2021', 2, CAST(3.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (12, N'C2021', 4, CAST(3.00 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (13, N'C2021', 5, CAST(3.00 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (14, N'C2042', 1, CAST(2.00 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (15, N'C2042', 2, CAST(3.50 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (16, N'C2042', 3, CAST(4.00 AS Decimal(3, 2)))
          INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (17, N'C2042', 5, CAST(3.00 AS Decimal(3, 2)))
          SET IDENTITY_INSERT [dbo].[StudentGrade] OFF
          ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])
          REFERENCES [dbo].[Department] ([DepartmentID])
          GO
          ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]
          GO
          ALTER TABLE [dbo].[StudentGrade]  WITH CHECK ADD  CONSTRAINT [FK_StudentGrade_Student] FOREIGN KEY([StudentID])
          REFERENCES [dbo].[Person] ([PersonID])
          GO
          ALTER TABLE [dbo].[StudentGrade] CHECK CONSTRAINT [FK_StudentGrade_Student]
          GO
        </code>
        <para>
          Next, compile and execute the following:
        </para>
        <!-- SqlCommand_Intro -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Threading.Tasks;
          
          class Program
          {
              static class SqlHelper
              {
                  // Set the connection, command, and then execute the command with non query.
                  public static Int32 ExecuteNonQuery(String connectionString, String commandText,
                  CommandType commandType, params SqlParameter[] parameters)
                  {
                      using (SqlConnection conn = new SqlConnection(connectionString))
                      {
                          using (SqlCommand cmd = new SqlCommand(commandText, conn))
                          {
                              // There are three command types: StoredProcedure, Text, TableDirect. The TableDirect
                              // type is only for OLE DB.
                              cmd.CommandType = commandType;
                              cmd.Parameters.AddRange(parameters);
          
                              conn.Open();
                              return cmd.ExecuteNonQuery();
                          }
                      }
                  }
          
                  // Set the connection, command, and then execute the command and only return one value.
                  public static Object ExecuteScalar(String connectionString, String commandText,
                  CommandType commandType, params SqlParameter[] parameters)
                  {
                      using (SqlConnection conn = new SqlConnection(connectionString))
                      {
                          using (SqlCommand cmd = new SqlCommand(commandText, conn))
                          {
                              cmd.CommandType = commandType;
                              cmd.Parameters.AddRange(parameters);
          
                              conn.Open();
                              return cmd.ExecuteScalar();
                          }
                      }
                  }
          
                  // Set the connection, command, and then execute the command with query and return the reader.
                  public static SqlDataReader ExecuteReader(String connectionString, String commandText,
                  CommandType commandType, params SqlParameter[] parameters)
                  {
                      SqlConnection conn = new SqlConnection(connectionString);
          
                      using (SqlCommand cmd = new SqlCommand(commandText, conn))
                      {
                          cmd.CommandType = commandType;
                          cmd.Parameters.AddRange(parameters);
          
                          conn.Open();
                          // When using CommandBehavior.CloseConnection, the connection will be closed when the
                          // IDataReader is closed.
                          SqlDataReader reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);
          
                          return reader;
                      }
                  }
              }
          
              static void Main(string[] args)
              {
                  String connectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;";
          
                  CountCourses(connectionString, 2012);
                  Console.WriteLine();
          
                  Console.WriteLine("Following result is the departments that started from 2007:");
                  GetDepartments(connectionString, 2007);
                  Console.WriteLine();
          
                  Console.WriteLine("Add the credits when the credits of course are lower than 4.");
                  AddCredits(connectionString, 4);
                  Console.WriteLine();
          
                  Console.WriteLine("Please press any key to exit...");
                  Console.ReadKey();
              }
          
              static void CountCourses(String connectionString, Int32 year)
              {
                  String commandText = "Select Count([CourseID]) FROM [MySchool].[dbo].[Course] Where Year=@Year";
                  SqlParameter parameterYear = new SqlParameter("@Year", SqlDbType.Int);
                  parameterYear.Value = year;
          
                  Object oValue = SqlHelper.ExecuteScalar(connectionString, commandText, CommandType.Text, parameterYear);
                  Int32 count;
                  if (Int32.TryParse(oValue.ToString(), out count))
                  {
                      Console.WriteLine("There {0} {1} course{2} in {3}.", count &gt; 1 ? "are" : "is", count, count &gt; 1 ? "s" : null, year);
                  }
              }
          
              // Display the Departments that start from the specified year.
              static void GetDepartments(String connectionString, Int32 year)
              {
                  String commandText = "dbo.GetDepartmentsOfSpecifiedYear";
          
                  // Specify the year of StartDate
                  SqlParameter parameterYear = new SqlParameter("@Year", SqlDbType.Int);
                  parameterYear.Value = year;
          
                  // When the direction of parameter is set as Output, you can get the value after
                  // executing the command.
                  SqlParameter parameterBudget = new SqlParameter("@BudgetSum", SqlDbType.Money);
                  parameterBudget.Direction = ParameterDirection.Output;
          
                  using (SqlDataReader reader = SqlHelper.ExecuteReader(connectionString, commandText,
                  CommandType.StoredProcedure, parameterYear, parameterBudget))
                  {
                      Console.WriteLine("{0,-20}{1,-20}{2,-20}{3,-20}", "Name", "Budget", "StartDate",
                      "Administrator");
                      while (reader.Read())
                      {
                          Console.WriteLine("{0,-20}{1,-20:C}{2,-20:d}{3,-20}", reader["Name"],
                          reader["Budget"], reader["StartDate"], reader["Administrator"]);
                      }
                  }
                  Console.WriteLine("{0,-20}{1,-20:C}", "Sum:", parameterBudget.Value);
              }
          
              // If credits of course is lower than the certain value, the method will add the credits.
              static void AddCredits(String connectionString, Int32 creditsLow)
              {
                  String commandText = "Update [MySchool].[dbo].[Course] Set Credits=Credits+1 Where Credits&lt;@Credits";
          
                  SqlParameter parameterCredits = new SqlParameter("@Credits", creditsLow);
          
                  Int32 rows = SqlHelper.ExecuteNonQuery(connectionString, commandText, CommandType.Text, parameterCredits);
          
                  Console.WriteLine("{0} row{1} {2} updated.", rows, rows &gt; 1 ? "s" : null, rows &gt; 1 ? "are" : "is");
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> class.
      </summary><remarks>
        <para>
          The base constructor initializes all fields to their default values. The following table shows initial property values for an instance of <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>Properties</term>
              <description>Initial value</description>
            </listheader>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /></term>
              <description>empty string ("")</description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /></term>
              <description>30</description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /></term>
              <description><see cref="F:System.Data.CommandType.Text" /></description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /></term>
              <description><see langword="null" /></description>
            </item>
          </list>
        </para>
        <para>
          You can change the value for any of these properties through a separate call to the property.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and sets the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
        <!-- IDbCommand_CommandTimeout -->
        <code language="c#">
          using System;
          using System.Xml;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using Microsoft.Data.SqlClient;

          public class Form1 : Form
          {
              protected DataSet DataSet1;
              protected DataGrid dataGrid1;

              public void CreateSqlCommand()
              {
                  SqlCommand command = new SqlCommand();
                  command.CommandTimeout = 15;
                  command.CommandType = CommandType.Text;
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.#ctor(System.String)">
            <param name="cmdText">
        The text of the query.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> class with the text of the query.
      </summary><remarks>
        <para>
          When an instance of <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> is created, the following read/write properties are set to initial values.
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>Properties</term>
              <description>Initial value</description>
            </listheader>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /></term>
              <description><paramref name="cmdText" /></description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /></term>
              <description>30</description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /></term>
              <description><see cref="F:System.Data.CommandType.Text" /></description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /></term>
              <description><see langword="null" /></description>
            </item>
          </list>
        </para>
        <para>
          You can change the value for any of these properties through a separate call to the property.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, passing in the connection string and command text.
        </para>
        <!-- SqlCommand_SqlCommand1 -->
        <code language="c#">
          using System;
          using System.Xml;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using Microsoft.Data.SqlClient;

          public class Form1 : Form
          {
              protected DataSet DataSet1;
              protected DataGrid dataGrid1;

              public void CreateCommand()
              {
                  string queryString = "SELECT * FROM Categories ORDER BY CategoryID";
                  SqlCommand command = new SqlCommand(queryString);
                  command.CommandTimeout = 15;
                  command.CommandType = CommandType.Text;
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.#ctor(System.String,Microsoft.Data.SqlClient.SqlConnection)">
            <param name="cmdText">
        The text of the query.
      </param><param name="connection">
        A <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> that represents the connection to an instance of SQL Server.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> class with the text of the query and a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />.
      </summary><remarks>
        <para>
          The following table shows initial property values for an instance of <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>Properties</term>
              <description>Initial value</description>
            </listheader>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /></term>
              <description><c>cmdText</c></description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /></term>
              <description>30</description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /></term>
              <description><see cref="F:System.Data.CommandType.Text" /></description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /></term>
              <description>
                A new <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> that is the value for the <paramref name="connection" /> parameter.
              </description>
            </item>
          </list>
        </para>
        <para>
          You can change the value for any of these parameters by setting the related property.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and sets some of its properties.
        </para>
        <!-- SqlCommand_SqlCommand2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          namespace SqlCommandCS
          {
              class Program
              {
                  static void Main()
                  {
                      string str = "Data Source=(local);Initial Catalog=Northwind;"
                          + "Integrated Security=SSPI";
                      string qs = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                      CreateCommand(qs, str);

                  }

                  private static void CreateCommand(string queryString, string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          SqlCommand command = new SqlCommand(queryString, connection);
                          connection.Open();
                          SqlDataReader reader = command.ExecuteReader();
                          while (reader.Read())
                          {
                              Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));
                          }
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.#ctor(System.String,Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlTransaction)">
            <param name="cmdText">
        The text of the query.
      </param><param name="connection">
        A <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> that represents the connection to an instance of SQL Server.
      </param><param name="transaction">
        The <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> in which the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> executes.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> class with the text of the query, a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, and the <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />.
      </summary><remarks>
        <para>
          The following table shows initial property values for an instance of <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>Properties</term>
              <description>Initial value</description>
            </listheader>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /></term>
              <description><c>cmdText</c></description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /></term>
              <description>30</description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /></term>
              <description><see cref="F:System.Data.CommandType.Text" /></description>
            </item>
            <item>
              <term><see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /></term>
              <description>
                A new <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> that is the value for the <paramref name="connection" /> parameter.
              </description>
            </item>
          </list>
        </para>
        <para>
          You can change the value for any of these parameters by setting the related property.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.#ctor(System.String,Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlTransaction,Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting)">
            <param name="cmdText">
        The text of the query.
      </param><param name="connection">
        A <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> that represents the connection to an instance of SQL Server.
      </param><param name="transaction">
        The <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> in which the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> executes.
      </param><param name="columnEncryptionSetting">
        The encryption setting. For more information, see <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> class with specified command text, connection, transaction, and encryption setting.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.ColumnEncryptionSetting">
            <summary>
        Gets the column encryption setting for this command.
      </summary><value>
        The column encryption setting for this command.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.CommandText">
            <summary>
        Gets or sets the Transact-SQL statement, table name or stored procedure to execute at the data source.
      </summary><value>
        The Transact-SQL statement or stored procedure to execute. The default is an empty string.
      </value><remarks>
        <para>
          When the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /> property is set to <see cref="F:System.Data.CommandType.StoredProcedure" />, the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property should be set to the name of the stored procedure. The user may be required to use escape character syntax if the stored procedure name contains any special characters. The command executes this stored procedure when you call one of the <c>Execute*</c> methods.
        </para>
        <para>
          The Microsoft .NET Framework Data Provider for SQL Server does not support the question mark (?) placeholder for passing parameters to a Transact-SQL statement or a stored procedure called by a command of <see cref="F:System.Data.CommandType.Text" />. In this case, named parameters must be used. For example:
        </para>
        <para>
          <code language="sql">
            SELECT * FROM dbo.Customers WHERE CustomerID = @CustomerID
          </code>
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/configure-parameters">Configuring parameters</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and sets some of its properties.
        </para>
        <!-- SqlCommand_CommandText -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;

          public class Form1 : Form
          {
              protected DataSet DataSet1;
              protected DataGrid dataGrid1;

              public void CreateCommand()
              {
                  SqlCommand command = new SqlCommand();
                  command.CommandText = "SELECT * FROM Categories ORDER BY CategoryID";
                  command.CommandTimeout = 15;
                  command.CommandType = CommandType.Text;
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout">
            <summary>
        Gets or sets the wait time (in seconds) before terminating the attempt to execute a command and generating an error. The default is 30 seconds.
      </summary><value>
        The time in seconds to wait for the command to execute. The default is 30 seconds.
      </value><remarks>
        <para>
          A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).
        </para>
        <para>
          <note type="note">
            The <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property will be ignored during old-style asynchronous method calls such as <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" />. It will be honored by the newer async methods such as <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync" />.
          </note>
        </para>
        <para>
          <note type="note">
            This property is the cumulative time-out (for all network packets that are read during the invocation of a method) for all network reads during command execution or processing of the results. A time-out can still occur after the first row is returned, and does not include user processing time, only network read time.
          </note>
        </para>
        <para>
          For example, with a 30 second time out, if <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> requires two network packets, then it has 30 seconds to read both network packets. If you call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> again, it will have another 30 seconds to read any data that it requires.
        </para>
      </remarks><example>
        <!-- SqlCommand_CommandTimeout -->
        <code language="c#">
          using System;
          using Microsoft.Data.SqlClient;

          public class A
          {
              public static void Main()
              {
                  string connectionString = "&lt;Your-connection-string-here&gt;";

                  // Wait for 5 second delay in the command
                  string queryString = "waitfor delay '00:00:05'";
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      SqlCommand command = new SqlCommand(queryString, connection);
                      // Setting command timeout to 1 second
                      command.CommandTimeout = 1;
                      try
                      {
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException e)
                      {
                          Console.WriteLine("Got expected SqlException due to command timeout ");
                          Console.WriteLine(e);
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value set is less than 0.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.CommandType">
            <summary>
        Gets or sets a value indicating how the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property is to be interpreted.
      </summary><value>
        One of the <see cref="T:System.Data.CommandType" /> values. The default is <see langword="Text" />.
      </value><remarks>
        <para>
          When you set the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /> property to <see cref="F:System.Data.CommandType.StoredProcedure" />, you should set the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property to the name of the stored procedure. The command executes this stored procedure when you call one of the Execute methods.
        </para>
        <para>
          The Microsoft .NET Framework Data Provider for SQL Server does not support the question mark (?) placeholder for passing parameters to a SQL Statement or a stored procedure called with a <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /> of <see cref="F:System.Data.CommandType.Text" />. In this case, named parameters must be used. For example:
        </para>
        <code language="sql">
          SELECT * FROM Customers WHERE CustomerID = @CustomerID
        </code>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/configure-parameters">Configuring parameters</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and sets some of its properties.
        </para>
        <!-- IDbCommand_CommandTimeout -->
        <code language="c#">
          using System;
          using System.Xml;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using Microsoft.Data.SqlClient;

          public class Form1 : Form
          {
              protected DataSet DataSet1;
              protected DataGrid dataGrid1;

              public void CreateSqlCommand()
              {
                  SqlCommand command = new SqlCommand();
                  command.CommandTimeout = 15;
                  command.CommandType = CommandType.Text;
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.Connection">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> used by this instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
      </summary><value>
        The connection to a data source. The default value is <see langword="null" />.
      </value><remarks>
        <para>
          If the command is enlisted in an existing transaction, and the connection is changed, trying to execute the command will throw an <see cref="T:System.InvalidOperationException" />.
        </para>
        <para>
          If the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Transaction" /> property is not null and the transaction has already been committed or rolled back, <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Transaction" /> is set to null.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and sets some of its properties.
        </para>
        <!-- SqlCommand_Connection -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;


          namespace SqlCommandCS
          {
              class Program
              {
                  static void Main()
                  {
                      string str = "Data Source=(local);Initial Catalog=Northwind;"
                                 + "Integrated Security=SSPI";
                      string qs = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                      CreateCommand(qs, str);
                  }

                  private static void CreateCommand(string queryString, string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(
                                 connectionString))
                      {
                          SqlCommand command = new SqlCommand();
                          command.Connection = connection;
                          command.CommandTimeout = 15;
                          command.CommandType = CommandType.Text;
                          command.CommandText = queryString;

                          connection.Open();
                          SqlDataReader reader = command.ExecuteReader();
                          while (reader.Read())
                          {
                              Console.WriteLine(String.Format("{0}, {1}",
                                  reader[0], reader[1]));
                          }
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        The <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> property was changed while the command was enlisted in a transaction.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.DbConnection">
            <summary>
        To be added.
      </summary><value>
        To be added.
      </value><remarks>
        To be added.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.DbParameterCollection">
            <summary>
        Gets the collection of <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> objects.
      </summary><value>
        The parameters of the SQL statement or stored procedure.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.DbTransaction">
            <summary>
        To be added.
      </summary><value>
        To be added.
      </value><remarks>
        To be added.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.DesignTimeVisible">
            <summary>
        Gets or sets a value indicating whether the command object should be visible in a Windows Form Designer control.
      </summary><value>
        A value indicating whether the command object should be visible in a control. The default is <see langword="true" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding">
            <summary>
        Gets or sets a value indicating whether the command object should optimize parameter performance by disabling Output and InputOutput directions when submitting the command to the SQL Server. <br /> This option is only used when the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /> is <see cref="F:System.Data.CommandType.Text" /> otherwise it is ignored.
      </summary><value>
        A value indicating whether the command object should optimize parameter performance by disabling Output and InputOutput parameter directions when submitting the command to the SQL Server. The default is <see langword="false" />.
      </value><remarks>
        <para>
          You must set the value for this property before the command is executed for it to take effect.
        </para>
        <para>
          When a command is submitted to the server with parameters a list of the parameter names is sent as part of the submission. The list is used on the server to match Output and InputOutput parameters to the results of the query execution so that the values can be returned to the caller. This option disables the construction and submission of the parameter name list and as a consequence disables the use of Output and InputOutput parameters. The return parameter is not affected by this option.
        </para>
        <para>
          A command sent with this option changes the way parameters are handled on the server, because there is no need to maintain an output parameter map. The result of this change is that queries with large numbers of input parameters may execute much faster.
        </para>
        <para>
          The fewest number of parameters where this will take effect depends on the individual situation and should be detected by measuring query duration with and without the option enabled. Any query with more than 24 parameters may show lower overall query duration. Queries with parameter counts lower than 24 are unlikely to show a difference.
        </para>
        <para>
          <note type="note">
            If the option is enabled and a parameter with Direction Output or InputOutput is present in the Parameters collection an InvalidOperationException will be thrown when the command is executed.
          </note>
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.Parameters">
            <summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><value>
        The parameters of the Transact-SQL statement or stored procedure. The default is an empty collection.
      </value><remarks>
        <para>
          The Microsoft .NET Framework Data Provider for SQL Server does not support the question mark (?) placeholder for passing parameters to a SQL Statement or a stored procedure called by a command of <see cref="F:System.Data.CommandType.Text" />. In this case, named parameters must be used. For example:
        </para>
        <code language="sql">
          SELECT * FROM Customers WHERE CustomerID = @CustomerID
        </code>
        <note type="note">
          If the parameters in the collection do not match the requirements of the query to be executed, an error may result.
        </note>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/configure-parameters">Configuring parameters</see>.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates how to create a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and add parameters to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
        </para>
        <!-- SqlParameterCollection_AddWithValue -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  string demo = @"&lt;StoreSurvey xmlns=""http://schemas.microsoft.com/sqlserver/2004/07/adventure-works/StoreSurvey""&gt;&lt;AnnualSales&gt;1500000&lt;/AnnualSales&gt;&lt;AnnualRevenue&gt;150000&lt;/AnnualRevenue&gt;&lt;BankName&gt;Primary International&lt;/BankName&gt;&lt;BusinessType&gt;OS&lt;/BusinessType&gt;&lt;YearOpened&gt;1974&lt;/YearOpened&gt;&lt;Specialty&gt;Road&lt;/Specialty&gt;&lt;SquareFeet&lt;38000&lt;/SquareFeet&gt;&lt;Brands&gt;3&lt;/Brands&gt;&lt;Internet&gt;DSL&lt;/Internet&gt;&lt;NumberEmployees&gt;40&lt;/NumberEmployees&gt;&lt;/StoreSurvey&gt;";
                  Int32 id = 3;
                  UpdateDemographics(id, demo, connectionString);
                  Console.ReadLine();
              }
              private static void UpdateDemographics(Int32 customerID,
                  string demoXml, string connectionString)
              {
                  // Update the demographics for a store, which is stored 
                  // in an xml column. 
                  string commandText = "UPDATE Sales.Store SET Demographics = @demographics "
                      + "WHERE CustomerID = @ID;";
          
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(commandText, connection);
                      command.Parameters.Add("@ID", SqlDbType.Int);
                      command.Parameters["@ID"].Value = customerID;
          
                      // Use AddWithValue to assign Demographics.
                      // SQL Server will implicitly convert strings into XML.
                      command.Parameters.AddWithValue("@demographics", demoXml);
          
                      try
                      {
                          connection.Open();
                          Int32 rowsAffected = command.ExecuteNonQuery();
                          Console.WriteLine("RowsAffected: {0}", rowsAffected);
                      }
                      catch (Exception ex)
                      {
                          Console.WriteLine(ex.Message);
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.Transaction">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> within which the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> executes.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. The default value is <see langword="null" />.
      </value><remarks>
        You cannot set the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Transaction" /> property if it is already set to a specific value, and the command is in the process of executing. If you set the transaction property to a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> object that is not connected to the same <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> as the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object, an exception is thrown the next time that you attempt to execute a statement.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.UpdatedRowSource">
            <summary>
        Gets or sets how command results are applied to the <see cref="T:System.Data.DataRow" /> when used by the <c>Update</c> method of the <see cref="T:System.Data.Common.DbDataAdapter" />.
      </summary><value>
        One of the <see cref="T:System.Data.UpdateRowSource" /> values.
      </value><remarks>
        <para>
          The default <see cref="T:System.Data.UpdateRowSource" /> value is <see cref="F:System.Data.UpdateRowSource.Both" /> unless the command is automatically generated (as in the case of the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />), in which case the default is <see cref="F:System.Data.UpdateRowSource.None" />.
        </para>
        <para>
          For more information about using the <b>UpdatedRowSource</b> property, see <see href="https://learn.microsoft.com/sql/connect/ado-net/dataadapter-parameters">DataAdapter Parameters</see>.
        </para>
      </remarks>
        </member>
        <member name="E:Microsoft.Data.SqlClient.SqlCommand.StatementCompleted">
            <summary>
        Occurs when the execution of a Transact-SQL statement completes.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery">
            <summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" />, which returns the number of affected rows.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method starts the process of asynchronously executing a Transact-SQL statement or stored procedure that does not return rows, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> method to finish the operation. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> before the command's execution is completed causes the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters are sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server - that is, reads are asynchronous.
        </para>
        <para>
          Because this overload does not support a callback procedure, developers must either poll to determine whether the command has completed, using the <see cref="P:System.IAsyncResult.IsCompleted" /> property of the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method; or wait for the completion of one or more commands using the <see cref="P:System.IAsyncResult.AsyncWaitHandle" /> property of the returned <see cref="T:System.IAsyncResult" />.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following console application creates updates data within the <b>AdventureWorks</b> sample database, doing its work asynchronously. In order to emulate a long-running process, this example inserts a <c>WAITFOR</c> statement in the command text. Normally, you would not take efforts to make your commands run slower, but doing this in this case makes it easier to demonstrate the asynchronous behavior.
        </para>
        <!-- SqlCommand_BeginExecuteNonQuery -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Class1
          {
              static void Main()
              {
                  // This is a simple example that demonstrates the usage of the 
                  // BeginExecuteNonQuery functionality.
                  // The WAITFOR statement simply adds enough time to prove the 
                  // asynchronous nature of the command.
          
                  string commandText =
                      "UPDATE Production.Product SET ReorderPoint = ReorderPoint + 1 " +
                      "WHERE ReorderPoint Is Not Null;" +
                      "WAITFOR DELAY '0:0:3';" +
                      "UPDATE Production.Product SET ReorderPoint = ReorderPoint - 1 " +
                      "WHERE ReorderPoint Is Not Null";
          
                  RunCommandAsynchronously(commandText, GetConnectionString());
          
                  Console.WriteLine("Press ENTER to continue.");
                  Console.ReadLine();
              }
          
              private static void RunCommandAsynchronously(string commandText, string connectionString)
              {
                  // Given command text and connection string, asynchronously execute
                  // the specified command against the connection. For this example,
                  // the code displays an indicator as it is working, verifying the 
                  // asynchronous behavior. 
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      try
                      {
                          int count = 0;
                          SqlCommand command = new SqlCommand(commandText, connection);
                          connection.Open();
          
                          IAsyncResult result = command.BeginExecuteNonQuery();
                          while (!result.IsCompleted)
                          {
                              Console.WriteLine("Waiting ({0})", count++);
                              // Wait for 1/10 second, so the counter
                              // does not consume all available resources 
                              // on the main thread.
                              System.Threading.Thread.Sleep(100);
                          }
                        
                          Console.WriteLine("Command complete. Affected {0} rows.",
                              command.EndExecuteNonQuery(result));
                      }
                      catch (SqlException ex)
                      {
                          Console.WriteLine("Error ({0}): {1}", ex.Number, ex.Message);
                      }
                      catch (InvalidOperationException ex)
                      {
                          Console.WriteLine("Error: {0}", ex.Message);
                      }
                      catch (Exception ex)
                      {
                          // You might want to pass these errors
                          // back out to the caller.
                          Console.WriteLine("Error: {0}", ex.Message);
                      }
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,            
                  // you can retrieve it from a configuration file. 
                  return "Data Source=(local);Integrated Security=SSPI;" +
                         "Initial Catalog=AdventureWorks";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            Any error that occurred while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery(System.AsyncCallback,System.Object)">
            <param name="callback">
        An <see cref="T:System.AsyncCallback" /> delegate that is invoked when the command's execution has completed. Pass <see langword="null" /> (<see langword="Nothing" /> in Microsoft Visual Basic) to indicate that no callback is required.
      </param><param name="stateObject">
        A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" /> property.
      </param><summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, given a callback procedure and state information.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" />, which returns the number of affected rows.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method starts the process of asynchronously executing a Transact-SQL statement or stored procedure that does not return rows, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> method to finish the operation. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> before the command's execution is completed causes the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          The <paramref name="callback" /> parameter lets you specify an <see cref="T:System.AsyncCallback" /> delegate that is called when the statement has completed. You can call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery" /> method from within this delegate procedure, or from any other location within your application. In addition, you can pass any object in the <paramref name="stateObject" /> parameter, and your callback procedure can retrieve this information using the <see cref="P:System.IAsyncResult.AsyncState" /> property.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters are sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server--that is, reads are asynchronous.
        </para>
        <para>
          Because the callback procedure executes from within a background thread supplied by the Microsoft .NET common language runtime, it is very important that you take a rigorous approach to handling cross-thread interactions from within your applications. For example, you must not interact with a form's contents from within your callback procedure; should you have to update the form, you must switch back to the form's thread in order to do your work. The example in this topic demonstrates this behavior.
        </para>
        <para>
          All errors that occur during the execution of the operation are thrown as exceptions in the callback procedure. You must handle the exception in the callback procedure, not in the main application. See the example in this topic for additional information on handling exceptions in the callback procedure.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following Windows application demonstrates the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method, executing a Transact-SQL statement that includes a delay of several seconds (emulating a long-running command).
        </para>
        <para>
          This example demonstrates many important techniques. This includes calling a method that interacts with the form from a separate thread. In addition, this example demonstrates how you must block users from executing a command multiple times concurrently, and how you must make sure that the form does not close before the callback procedure is called.
        </para>
        <para>
          To set up this example, create a new Windows application. Put a <see cref="T:System.Windows.Forms.Button" /> control and a <see cref="T:System.Windows.Forms.Label" /> control on the form (accepting the default name for each control). Add the following code to the form's class, modifying the connection string as needed for your environment.
        </para>
        <!-- SqlCommand_BeginExecuteNonQueryForm -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.ComponentModel;
          using System.Data;
          using System.Drawing;
          using System.Text;
          using System.Windows.Forms;
          using Microsoft.Data.SqlClient;
          
          namespace Microsoft.AdoDotNet.CodeSamples
          {
              public partial class Form1 : Form
              {
                  public Form1()
                  {
                      InitializeComponent();
                  }
          
                  // Hook up the form's Load event handler (you can double-click on 
                  // the form's design surface in Visual Studio), and then add 
                  // this code to the form's class:
                  private void Form1_Load(object sender, EventArgs e)
                  {
                      this.button1.Click += new System.EventHandler(this.button1_Click);
                      this.FormClosing += new System.Windows.Forms.
                          FormClosingEventHandler(this.Form1_FormClosing);
                  }
          
                  // You need this delegate in order to display text from a thread
                  // other than the form's thread. See the HandleCallback
                  // procedure for more information.
                  // This same delegate matches both the DisplayStatus 
                  // and DisplayResults methods.
                  private delegate void DisplayInfoDelegate(string Text);
          
                  // This flag ensures that the user does not attempt
                  // to restart the command or close the form while the 
                  // asynchronous command is executing.
                  private bool isExecuting;
          
                  // This example maintains the connection object 
                  // externally, so that it is available for closing.
                  private SqlConnection connection;
          
                  private static string GetConnectionString()
                  {
                      // To avoid storing the connection string in your code,            
                      // you can retrieve it from a configuration file.
                      return "Data Source=(local);Integrated Security=true;" +
                             "Initial Catalog=AdventureWorks";
                  }
          
                  private void DisplayStatus(string Text)
                  {
                      this.label1.Text = Text;
                  }
          
                  private void DisplayResults(string Text)
                  {
                      this.label1.Text = Text;
                      DisplayStatus("Ready");
                  }
          
                  private void Form1_FormClosing(object sender, System.Windows.Forms.FormClosingEventArgs e)
                  {
                      if (isExecuting)
                      {
                          MessageBox.Show(this, "Cannot close the form until " +
                              "the pending asynchronous command has completed. Please wait...");
                          e.Cancel = true;
                      }
                  }
          
                  private void button1_Click(object sender, System.EventArgs e)
                  {
                      if (isExecuting)
                      {
                          MessageBox.Show(this,
                              "Already executing. Please wait until the current query " +
                              "has completed.");
                      }
                      else
                      {
                          SqlCommand command = null;
                          try
                          {
                              DisplayResults("");
                              DisplayStatus("Connecting...");
                              connection = new SqlConnection(GetConnectionString());
                              // To emulate a long-running query, wait for 
                              // a few seconds before working with the data.
                              // This command does not do much, but that's the point--
                              // it does not change your data, in the long run.
                              string commandText =
                                  "WAITFOR DELAY '0:0:05';" +
                                  "UPDATE Production.Product SET ReorderPoint = ReorderPoint + 1 " +
                                  "WHERE ReorderPoint Is Not Null;" +
                                  "UPDATE Production.Product SET ReorderPoint = ReorderPoint - 1 " +
                                  "WHERE ReorderPoint Is Not Null";
          
                              command = new SqlCommand(commandText, connection);
                              connection.Open();
          
                              DisplayStatus("Executing...");
                              isExecuting = true;
                              // Although it is not required that you pass the 
                              // SqlCommand object as the second parameter in the 
                              // BeginExecuteNonQuery call, doing so makes it easier
                              // to call EndExecuteNonQuery in the callback procedure.
                              AsyncCallback callback = new AsyncCallback(HandleCallback);
                              command.BeginExecuteNonQuery(callback, command);
          
                          }
                          catch (Exception ex)
                          {
                              isExecuting = false;
                              DisplayStatus(string.Format("Ready (last error: {0})", ex.Message));
                              if (connection != null)
                              {
                                  connection.Close();
                              }
                          }
                      }
                  }
          
                  private void HandleCallback(IAsyncResult result)
                  {
                      try
                      {
                          // Retrieve the original command object, passed
                          // to this procedure in the AsyncState property
                          // of the IAsyncResult parameter.
                          SqlCommand command = (SqlCommand)result.AsyncState;
                          int rowCount = command.EndExecuteNonQuery(result);
                          string rowText = " rows affected.";
                          if (rowCount == 1)
                          {
                              rowText = " row affected.";
                          }
                        
                          rowText = rowCount + rowText;
          
                          // You may not interact with the form and its contents
                          // from a different thread, and this callback procedure
                          // is all but guaranteed to be running from a different thread
                          // than the form. Therefore you cannot simply call code that 
                          // displays the results, like this:
                          // DisplayResults(rowText)
          
                          // Instead, you must call the procedure from the form's thread.
                          // One simple way to accomplish this is to call the Invoke
                          // method of the form, which calls the delegate you supply
                          // from the form's thread. 
                          DisplayInfoDelegate del = new DisplayInfoDelegate(DisplayResults);
                          this.Invoke(del, rowText);
          
                      }
                      catch (Exception ex)
                      {
                          // Because you are now running code in a separate thread, 
                          // if you do not handle the exception here, none of your other
                          // code catches the exception. Because none of 
                          // your code is on the call stack in this thread, there is nothing
                          // higher up the stack to catch the exception if you do not 
                          // handle it here. You can either log the exception or 
                          // invoke a delegate (as in the non-error case in this 
                          // example) to display the error on the form. In no case
                          // can you simply display the error without executing a delegate
                          // as in the try block here. 
          
                          // You can create the delegate instance as you 
                          // invoke it, like this:
                          this.Invoke(new DisplayInfoDelegate(DisplayStatus),
                              String.Format("Ready(last error: {0}", ex.Message));
                      }
                      finally
                      {
                          isExecuting = false;
                          if (connection != null)
                          {
                              connection.Close();
                          }
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            Any error that occurred while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader">
            <summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, and retrieves one or more result sets from the server.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />, which returns a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance that can be used to retrieve the returned rows.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method starts the process of asynchronously executing a Transact-SQL statement or stored procedure that returns rows, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method to finish the operation and retrieve the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> returned by the command. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> before the command's execution is completed causes the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters are sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server - that is, reads are asynchronous. Although command execution is asynchronous, value fetching is still synchronous. This means that calls to <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> may block if more data is required and the underlying network's read operation blocks.
        </para>
        <para>
          Because this overload does not support a callback procedure, developers must either poll to determine whether the command has completed, using the <see cref="P:System.IAsyncResult.IsCompleted" /> property of the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method; or wait for the completion of one or more commands using the <see cref="P:System.IAsyncResult.AsyncWaitHandle" /> property of the returned <see cref="T:System.IAsyncResult" />.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server will return any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following console application starts the process of retrieving a data reader asynchronously. While waiting for the results, this simple application sits in a loop, investigating the <see cref="P:System.IAsyncResult.IsCompleted" /> property value. As soon as the process has completed, the code retrieves the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and displays its contents.
        </para>
        <!-- SqlCommand_BeginExecuteReader -->
        <code language="c#">
          using System;
          using Microsoft.Data.SqlClient;

          class Class1
          {
              static void Main()
              {
                  // This is a simple example that demonstrates the usage of the
                  // BeginExecuteReader functionality
                  // The WAITFOR statement simply adds enough time to prove the
                  // asynchronous nature of the command.
                  string commandText =
                      "WAITFOR DELAY '00:00:03';" +
                      "SELECT LastName, FirstName FROM Person.Contact " +
                      "WHERE LastName LIKE 'M%'";

                  RunCommandAsynchronously(commandText, GetConnectionString());

                  Console.WriteLine("Press ENTER to continue.");
                  Console.ReadLine();
              }

              private static void RunCommandAsynchronously(
                  string commandText, string connectionString)
              {
                  // Given command text and connection string, asynchronously execute
                  // the specified command against the connection. For this example,
                  // the code displays an indicator as it is working, verifying the
                  // asynchronous behavior.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      try
                      {
                          SqlCommand command = new SqlCommand(commandText, connection);

                          connection.Open();
                          IAsyncResult result = command.BeginExecuteReader();

                          // Although it is not necessary, the following code
                          // displays a counter in the console window, indicating that
                          // the main thread is not blocked while awaiting the command
                          // results.
                          int count = 0;
                          while (!result.IsCompleted)
                          {
                              count += 1;
                              Console.WriteLine("Waiting ({0})", count);
                              // Wait for 1/10 second, so the counter
                              // does not consume all available resources
                              // on the main thread.
                              System.Threading.Thread.Sleep(100);
                          }

                          using (SqlDataReader reader = command.EndExecuteReader(result))
                          {
                              DisplayResults(reader);
                          }
                      }
                      catch (SqlException ex)
                      {
                          Console.WriteLine("Error ({0}): {1}", ex.Number, ex.Message);
                      }
                      catch (InvalidOperationException ex)
                      {
                          Console.WriteLine("Error: {0}", ex.Message);
                      }
                      catch (Exception ex)
                      {
                          // You might want to pass these errors
                          // back out to the caller.
                          Console.WriteLine("Error: {0}", ex.Message);
                      }
                  }
              }

              private static void DisplayResults(SqlDataReader reader)
              {
                  // Display the data within the reader.
                  while (reader.Read())
                  {
                      // Display all the columns. 
                      for (int i = 0; i &lt; reader.FieldCount; i++)
                      {
                          Console.Write("{0}\t", reader.GetValue(i));
                      }
                      Console.WriteLine();
                  }
              }

              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,            
                  // you can retrieve it from a configuration file. 

                  return "Data Source=(local);Integrated Security=true;" +
                      "Initial Catalog=AdventureWorks";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            Any error that occurred while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback,System.Object)">
            <param name="callback">
        An <see cref="T:System.AsyncCallback" /> delegate that is invoked when the command's execution has completed. Pass <see langword="null" /> (<see langword="Nothing" /> in Microsoft Visual Basic) to indicate that no callback is required.
      </param><param name="stateObject">
        A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" /> property.
      </param><summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and retrieves one or more result sets from the server, given a callback procedure and state information.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll, wait for results, or both; this value is also needed when invoking <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />, which returns a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance which can be used to retrieve the returned rows.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method starts the process of asynchronously executing a Transact-SQL statement or stored procedure that returns rows, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method to finish the operation and retrieve the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> returned by the command. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> before the command's execution is completed cause the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          The <paramref name="callback" /> parameter lets you specify an <see cref="T:System.AsyncCallback" /> delegate that is called when the statement has completed. You can call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method from within this delegate procedure, or from any other location within your application. In addition, you can pass any object in the <paramref name="stateObject" /> parameter, and your callback procedure can retrieve this information using the <see cref="P:System.IAsyncResult.AsyncState" /> property.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters are sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server--that is, reads are asynchronous. Although command execution is asynchronous, value fetching is still synchronous. This means that calls to <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> may block if more data is required and the underlying network's read operation blocks.
        </para>
        <para>
          Because the callback procedure executes from within a background thread supplied by the Microsoft .NET runtime, it is very important that you take a rigorous approach to handling cross-thread interactions from within your applications. For example, you must not interact with a form's contents from within your callback procedure; should you have to update the form, you must switch back to the form's thread in order to do your work. The example in this topic demonstrates this behavior.
        </para>
        <para>
          All errors that occur during the execution of the operation are thrown as exceptions in the callback procedure. You must handle the exception in the callback procedure, not in the main application. See the example in this topic for additional information on handling exceptions in the callback procedure.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server returns any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following Windows application demonstrates the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method, executing a Transact-SQL statement that includes a delay of a few seconds (emulating a long-running command). Because the sample executes the command asynchronously, the form remains responsive while awaiting the results. This example passes the executing <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object as the <paramref name="stateObject" /> parameter; doing so makes it simple to retrieve the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object from within the callback procedure, so that the code can call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method corresponding to the initial call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" />.
        </para>
        <para>
          This example demonstrates many important techniques. This includes calling a method that interacts with the form from a separate thread. In addition, this example demonstrates how you must block users from executing a command multiple times concurrently, and how you must make sure that the form does not close before the callback procedure is called.
        </para>
        <para>
          To set up this example, create a new Windows application. Put a <see cref="T:System.Windows.Forms.Button" /> control, a <see cref="T:System.Windows.Forms.DataGridView" /> control, and a <see cref="T:System.Windows.Forms.Label" /> control on the form (accepting the default name for each control). Add the following code to the form's class, modifying the connection string as needed for your environment.
        </para>
        <!-- SqlCommand_BeginExecuteReaderAsync -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Class1
          {
              static void Main()
              {
                  // This example is not terribly useful, but it proves a point.
                  // The WAITFOR statement simply adds enough time to prove the 
                  // asynchronous nature of the command.
                  string commandText = "WAITFOR DELAY '00:00:03';" +
                      "SELECT ProductID, Name FROM Production.Product WHERE ListPrice &lt; 100";
          
                  RunCommandAsynchronously(commandText, GetConnectionString());
          
                  Console.WriteLine("Press ENTER to continue.");
                  Console.ReadLine();
              }
          
              private static void RunCommandAsynchronously(string commandText, string connectionString)
              {
                  // Given command text and connection string, asynchronously execute
                  // the specified command against the connection. For this example,
                  // the code displays an indicator as it is working, verifying the 
                  // asynchronous behavior. 
                  try
                  {
                      // The code does not need to handle closing the connection explicitly--
                      // the use of the CommandBehavior.CloseConnection option takes care
                      // of that for you. 
                      SqlConnection connection = new SqlConnection(connectionString);
                      SqlCommand command = new SqlCommand(commandText, connection);
          
                      connection.Open();
                      IAsyncResult result = command.BeginExecuteReader(CommandBehavior.CloseConnection);
          
                      // Although it is not necessary, the following code
                      // displays a counter in the console window, indicating that 
                      // the main thread is not blocked while awaiting the command 
                      // results.
                      int count = 0;
                      while (!result.IsCompleted)
                      {
                          Console.WriteLine("Waiting ({0})", count++);
                          // Wait for 1/10 second, so the counter
                          // does not consume all available resources 
                          // on the main thread.
                          System.Threading.Thread.Sleep(100);
                      }
          
                      using (SqlDataReader reader = command.EndExecuteReader(result))
                      {
                          DisplayResults(reader);
                      }
                  }
                  catch (SqlException ex)
                  {
                      Console.WriteLine("Error ({0}): {1}", ex.Number, ex.Message);
                  }
                  catch (InvalidOperationException ex)
                  {
                      Console.WriteLine("Error: {0}", ex.Message);
                  }
                  catch (Exception ex)
                  {
                      // You might want to pass these errors
                      // back out to the caller.
                      Console.WriteLine("Error: {0}", ex.Message);
                  }
              }
          
              private static void DisplayResults(SqlDataReader reader)
              {
                  // Display the data within the reader.
                  while (reader.Read())
                  {
                      // Display all the columns. 
                      for (int i = 0; i &lt; reader.FieldCount; i++)
                      {
                          Console.Write("{0}\t", reader.GetValue(i));
                      }
                    
                      Console.WriteLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,            
                  // you can retrieve it from a configuration file. 
                  return "Data Source=(local);Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>Any error that occurred while executing the command text.</item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader(System.AsyncCallback,System.Object,System.Data.CommandBehavior)">
            <param name="callback">
        An <see cref="T:System.AsyncCallback" /> delegate that is invoked when the command's execution has completed. Pass <see langword="null" /> (<see langword="Nothing" /> in Microsoft Visual Basic) to indicate that no callback is required.
      </param><param name="stateObject">
        A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" /> property.
      </param><param name="behavior">
        One of the <see cref="T:System.Data.CommandBehavior" /> values, indicating options for statement execution and data retrieval.
      </param><summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, using one of the <see langword="CommandBehavior" /> values, and retrieving one or more result sets from the server, given a callback procedure and state information.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />, which returns a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance which can be used to retrieve the returned rows.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method starts the process of asynchronously executing a Transact-SQL statement or stored procedure that returns rows, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method to finish the operation and retrieve the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> returned by the command. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> before the command's execution is completed causes the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          The <paramref name="callback" /> parameter lets you specify an <see cref="T:System.AsyncCallback" /> delegate that is called when the statement has completed. You can call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method from within this delegate procedure, or from any other location within your application. In addition, you can pass any object in the <c>stateObject</c> parameter, and your callback procedure can retrieve this information using the <see cref="P:System.IAsyncResult.AsyncState" /> property.
        </para>
        <para>
          The <paramref name="behavior" /> parameter lets you specify options that control the behavior of the command and its connection. These values can be combined together (using the programming language's <c>Or</c> operator); generally, developers use the <c>CloseConnection</c> value to make sure that the connection is closed by the runtime when the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed. Developers can also optimize the behavior of the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> by specifying the <c>SingleRow</c> value when it is known in advance that the Transact-SQL statement or stored procedure only returns a single row.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters are sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server--that is, reads are asynchronous. Although command execution is asynchronous, value fetching is still synchronous. This means that calls to <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> may block if more data is required and the underlying network's read operation blocks.
        </para>
        <para>
          Because the callback procedure executes from within a background thread supplied by the Microsoft .NET common language runtime, it is very important that you take a rigorous approach to handling cross-thread interactions from within your applications. For example, you must not interact with a form's contents from within your callback procedure--should you have to update the form, you must switch back to the form's thread in order to do your work. The example in this topic demonstrates this behavior.
        </para>
        <para>
          All errors that occur during the execution of the operation are thrown as exceptions in the callback procedure. You must handle the exception in the callback procedure, not in the main application. See the example in this topic for additional information on handling exceptions in the callback procedure.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server will return any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following Windows application demonstrates the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method, executing a Transact-SQL statement that includes a delay of a few seconds (emulating a long-running command). Because the sample executes the command asynchronously, the form remains responsive while awaiting the results. This example passes the executing <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object as the <c>stateObject</c> parameter; doing so makes it simple to retrieve the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object from within the callback procedure, so that the code can call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method corresponding to the initial call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" />.
        </para>
        <para>
          This example demonstrates many important techniques. This includes calling a method that interacts with the form from a separate thread. In addition, this example demonstrates how you must block users from executing a command multiple times concurrently, and how you must make sure that the form does not close before the callback procedure is called.
        </para>
        <para>
          To set up this example, create a new Windows application. Put a <see cref="T:System.Windows.Forms.Button" /> control, a <see cref="T:System.Windows.Forms.DataGridView" /> control, and a <see cref="T:System.Windows.Forms.Label" /> control on the form (accepting the default name for each control). Add the following code to the form's class, modifying the connection string as needed for your environment.
        </para>
        <para>
          This example passes the <see cref="F:System.Data.CommandBehavior.CloseConnection" /> value in the <paramref name="behavior" /> parameter, causing the returned <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> to automatically close its connection when it is closed.
        </para>
        <!-- SqlCommand_BeginExecuteReaderAsyncBehavior -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.ComponentModel;
          using System.Data;
          using System.Drawing;
          using System.Text;
          using System.Windows.Forms;
          using Microsoft.Data.SqlClient;
          
          namespace Microsoft.AdoDotNet.CodeSamples
          {
              public partial class Form1 : Form
              {
                  public Form1()
                  {
                      InitializeComponent();
                  }
                
                  // Hook up the form's Load event handler (you can double-click on 
                  // the form's design surface in Visual Studio), and then add 
                  // this code to the form's class:
                  // You need this delegate in order to fill the grid from
                  // a thread other than the form's thread. See the HandleCallback
                  // procedure for more information.
                  private delegate void FillGridDelegate(SqlDataReader reader);
          
                  // You need this delegate to update the status bar.
                  private delegate void DisplayStatusDelegate(string Text);
          
                  // This flag ensures that the user does not attempt
                  // to restart the command or close the form while the 
                  // asynchronous command is executing.
                  private bool isExecuting;
          
                  private void DisplayStatus(string Text)
                  {
                      this.label1.Text = Text;
                  }
          
                  private void FillGrid(SqlDataReader reader)
                  {
                      try
                      {
                          DataTable table = new DataTable();
                          table.Load(reader);
                          this.dataGridView1.DataSource = table;
                          DisplayStatus("Ready");
                      }
                      catch (Exception ex)
                      {
                          // Because you are guaranteed this procedure
                          // is running from within the form's thread,
                          // it can directly interact with members of the form.
                          DisplayStatus(string.Format("Ready (last attempt failed: {0})", ex.Message));
                      }
                      finally
                      {
                          // Closing the reader also closes the connection,
                          // because this reader was created using the 
                          // CommandBehavior.CloseConnection value.
                          if (reader != null)
                          {
                              reader.Close();
                          }
                      }
                  }
          
                  private void HandleCallback(IAsyncResult result)
                  {
                      try
                      {
                          // Retrieve the original command object, passed
                          // to this procedure in the AsyncState property
                          // of the IAsyncResult parameter.
                          SqlCommand command = (SqlCommand)result.AsyncState;
                          SqlDataReader reader = command.EndExecuteReader(result);
                        
                          // You may not interact with the form and its contents
                          // from a different thread, and this callback procedure
                          // is all but guaranteed to be running from a different thread
                          // than the form. Therefore you cannot simply call code that 
                          // fills the grid, like this:
                          // FillGrid(reader);
                          // Instead, you must call the procedure from the form's thread.
                          // One simple way to accomplish this is to call the Invoke
                          // method of the form, which calls the delegate you supply
                          // from the form's thread. 
                          FillGridDelegate del = new FillGridDelegate(FillGrid);
                          this.Invoke(del, reader);
                        
                          // Do not close the reader here, because it is being used in 
                          // a separate thread. Instead, have the procedure you have
                          // called close the reader once it is done with it.
                      }
                      catch (Exception ex)
                      {
                          // Because you are now running code in a separate thread, 
                          // if you do not handle the exception here, none of your other
                          // code catches the exception. Because there is none of 
                          // your code on the call stack in this thread, there is nothing
                          // higher up the stack to catch the exception if you do not 
                          // handle it here. You can either log the exception or 
                          // invoke a delegate (as in the non-error case in this 
                          // example) to display the error on the form. In no case
                          // can you simply display the error without executing a delegate
                          // as in the try block here. 
                          // You can create the delegate instance as you 
                          // invoke it, like this:
                          this.Invoke(new DisplayStatusDelegate(DisplayStatus), "Error: " + ex.Message);
                      }
                      finally
                      {
                          isExecuting = false;
                      }
                  }
          
                  private string GetConnectionString()
                  {
                      // To avoid storing the connection string in your code, 
                      // you can retrieve it from a configuration file. 
                      return "Data Source=(local);Integrated Security=true;" +
                             "Initial Catalog=AdventureWorks";
                  }
          
                  private void button1_Click(object sender, System.EventArgs e)
                  {
                      if (isExecuting)
                      {
                          MessageBox.Show(this,
                              "Already executing. Please wait until the current query " +
                              "has completed.");
                      }
                      else
                      {
                          SqlCommand command = null;
                          SqlConnection connection = null;
                          try
                          {
                              DisplayStatus("Connecting...");
                              connection = new SqlConnection(GetConnectionString());
                              // To emulate a long-running query, wait for 
                              // a few seconds before retrieving the real data.
                              command = new SqlCommand("WAITFOR DELAY '0:0:5';" +
                                  "SELECT ProductID, Name, ListPrice, Weight FROM Production.Product",
                                  connection);
                              connection.Open();
          
                              DisplayStatus("Executing...");
                              isExecuting = true;
                              // Although it is not required that you pass the 
                              // SqlCommand object as the second parameter in the 
                              // BeginExecuteReader call, doing so makes it easier
                              // to call EndExecuteReader in the callback procedure.
                              AsyncCallback callback = new AsyncCallback(HandleCallback);
                              command.BeginExecuteReader(callback, command,
                                  CommandBehavior.CloseConnection);
                          }
                          catch (Exception ex)
                          {
                              DisplayStatus("Error: " + ex.Message);
                              if (connection != null)
                              {
                                  connection.Close();
                              }
                          }
                      }
                  }
          
                  private void Form1_Load(object sender, System.EventArgs e)
                  {
                      this.button1.Click += new System.EventHandler(this.button1_Click);
                      this.FormClosing += new FormClosingEventHandler(Form1_FormClosing);
                  }
          
                  void Form1_FormClosing(object sender, FormClosingEventArgs e)
                  {
                      if (isExecuting)
                      {
                          MessageBox.Show(this, "Cannot close the form until " +
                              "the pending asynchronous command has completed. Please wait...");
                          e.Cancel = true;
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            Any error that occurred while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader(System.Data.CommandBehavior)">
            <param name="behavior">
        One of the <see cref="T:System.Data.CommandBehavior" /> values, indicating options for statement execution and data retrieval.
      </param><summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> using one of the <see cref="T:System.Data.CommandBehavior" /> values.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll, wait for results, or both; this value is also needed when invoking <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />, which returns a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance that can be used to retrieve the returned rows.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method starts the process of asynchronously executing a Transact-SQL statement or stored procedure that returns rows, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method to finish the operation and retrieve the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> returned by the command. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader" /> before the command's execution is completed causes the <see cref="M:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          The <c>behavior</c> parameter lets you specify options that control the behavior of the command and its connection. These values can be combined (using the programming language's <c>OR</c> operator); generally, developers use the <c>CommandBehavior.CloseConnection</c> value to make sure that the connection is closed by the runtime when the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters are sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server - that is, reads are asynchronous. Although command execution is asynchronous, value fetching is still synchronous. This means that calls to <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> may block if more data is required and the underlying network's read operation blocks.
        </para>
        <para>
          Because this overload does not support a callback procedure, developers must either poll to determine whether the command has completed, using the <see cref="P:System.IAsyncResult.IsCompleted" /> property of the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method; or wait for the completion of one or more commands using the <see cref="P:System.IAsyncResult.AsyncWaitHandle" /> property of the returned <see cref="T:System.IAsyncResult" />.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server returns any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following console application starts the process of retrieving a data reader asynchronously. While waiting for the results, this simple application sits in a loop, investigating the <see cref="P:System.IAsyncResult.IsCompleted" /> property value. Once the process has completed, the code retrieves the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and displays its contents.
        </para>
        <para>
          This example also passes the <see cref="F:System.Data.CommandBehavior.CloseConnection" /> and <see cref="F:System.Data.CommandBehavior.SingleRow" /> values in the behavior parameter, causing the connection to be closed with the returned <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed, and to optimize for a single row result.
        </para>
        <!-- SqlCommand_BeginExecuteReaderAsyncSimple -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Class1
          {
              static void Main()
              {
                  // This example is not terribly useful, but it proves a point.
                  // The WAITFOR statement simply adds enough time to prove the 
                  // asynchronous nature of the command.
                  string commandText = "WAITFOR DELAY '00:00:03';" +
                      "SELECT ProductID, Name FROM Production.Product WHERE ListPrice &lt; 100";
          
                  RunCommandAsynchronously(commandText, GetConnectionString());
          
                  Console.WriteLine("Press ENTER to continue.");
                  Console.ReadLine();
              }
          
              private static void RunCommandAsynchronously(string commandText, string connectionString)
              {
                  // Given command text and connection string, asynchronously execute
                  // the specified command against the connection. For this example,
                  // the code displays an indicator as it is working, verifying the 
                  // asynchronous behavior. 
                  try
                  {
                      // The code does not need to handle closing the connection explicitly--
                      // the use of the CommandBehavior.CloseConnection option takes care
                      // of that for you. 
                      SqlConnection connection = new SqlConnection(connectionString);
                      SqlCommand command = new SqlCommand(commandText, connection);
          
                      connection.Open();
                      IAsyncResult result = command.BeginExecuteReader(CommandBehavior.CloseConnection);
          
                      // Although it is not necessary, the following code
                      // displays a counter in the console window, indicating that 
                      // the main thread is not blocked while awaiting the command 
                      // results.
                      int count = 0;
                      while (!result.IsCompleted)
                      {
                          Console.WriteLine("Waiting ({0})", count++);
                          // Wait for 1/10 second, so the counter
                          // does not consume all available resources 
                          // on the main thread.
                          System.Threading.Thread.Sleep(100);
                      }
          
                      using (SqlDataReader reader = command.EndExecuteReader(result))
                      {
                          DisplayResults(reader);
                      }
                  }
                  catch (SqlException ex)
                  {
                      Console.WriteLine("Error ({0}): {1}", ex.Number, ex.Message);
                  }
                  catch (InvalidOperationException ex)
                  {
                      Console.WriteLine("Error: {0}", ex.Message);
                  }
                  catch (Exception ex)
                  {
                      // You might want to pass these errors
                      // back out to the caller.
                      Console.WriteLine("Error: {0}", ex.Message);
                  }
              }
          
              private static void DisplayResults(SqlDataReader reader)
              {
                  // Display the data within the reader.
                  while (reader.Read())
                  {
                      // Display all the columns. 
                      for (int i = 0; i &lt; reader.FieldCount; i++)
                      {
                          Console.Write("{0}\t", reader.GetValue(i));
                      }
                    
                      Console.WriteLine();
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,            
                  // you can retrieve it from a configuration file. 
                  return "Data Source=(local);Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            Any error that occurred while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader">
            <summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and returns results as an <see cref="T:System.Xml.XmlReader" /> object.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll or wait for results, or both; this value is also needed when invoking <see langword="EndExecuteXmlReader" />, which returns a single XML value.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> method starts the process of asynchronously executing a Transact-SQL statement that returns rows as XML, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method to finish the operation and retrieve the XML returned by the command. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <c>EndExecuteXmlReader</c> before the command's execution is completed causes the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property ordinarily specifies a Transact-SQL statement with a valid FOR XML clause. However, <c>CommandText</c> can also specify a statement that returns <c>ntext</c> data that contains valid XML.
        </para>
        <para>
          A typical <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> query can be formatted as in the following C# example:
        </para>
        <para>
          <code language="c#">
            SqlCommand command = new SqlCommand("SELECT ContactID, FirstName, LastName FROM dbo.Contact FOR XML AUTO, XMLDATA", SqlConn);
          </code>
        </para>
        <para>
          This method can also be used to retrieve a single-row, single-column result set. In this case, if more than one row is returned, the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method attaches the <see cref="T:System.Xml.XmlReader" /> to the value on the first row, and discards the rest of the result set.
        </para>
        <para>
          The multiple active result set (MARS) feature lets multiple actions use the same connection.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters are sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server--that is, reads are asynchronous. Although command execution is asynchronous, value fetching is still synchronous.
        </para>
        <para>
          Because this overload does not support a callback procedure, developers need to either poll to determine whether the command has completed, using the <see cref="P:System.IAsyncResult.IsCompleted" /> property of the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> method; or wait for the completion of one or more commands using the <see cref="P:System.IAsyncResult.AsyncWaitHandle" /> property of the returned <see cref="T:System.IAsyncResult" />.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server returns any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following console application starts the process of retrieving XML data asynchronously. While waiting for the results, this simple application sits in a loop, investigating the <see cref="P:System.IAsyncResult.IsCompleted" /> property value. Once the process has completed, the code retrieves the XML and displays its contents.
        </para>
        <!-- SqlCommand_BeginExecuteXmlReader -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Xml;
          
          class Class1
          {
              static void Main()
              {
                  // This example is not terribly effective, but it proves a point.
                  // The WAITFOR statement simply adds enough time to prove the 
                  // asynchronous nature of the command.
                  string commandText =
                      "WAITFOR DELAY '00:00:03';" +
                      "SELECT Name, ListPrice FROM Production.Product " +
                      "WHERE ListPrice &lt; 100 " +
                      "FOR XML AUTO, XMLDATA";
          
                  RunCommandAsynchronously(commandText, GetConnectionString());
          
                  Console.WriteLine("Press ENTER to continue.");
                  Console.ReadLine();
              }
          
              private static void RunCommandAsynchronously(string commandText, string connectionString)
              {
                  // Given command text and connection string, asynchronously execute
                  // the specified command against the connection. For this example,
                  // the code displays an indicator as it is working, verifying the 
                  // asynchronous behavior. 
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(commandText, connection);
          
                      connection.Open();
                      IAsyncResult result = command.BeginExecuteXmlReader();
          
                      // Although it is not necessary, the following procedure
                      // displays a counter in the console window, indicating that 
                      // the main thread is not blocked while awaiting the command 
                      // results.
                      int count = 0;
                      while (!result.IsCompleted)
                      {
                          Console.WriteLine("Waiting ({0})", count++);
                          // Wait for 1/10 second, so the counter
                          // does not consume all available resources 
                          // on the main thread.
                          System.Threading.Thread.Sleep(100);
                      }
          
                      XmlReader reader = command.EndExecuteXmlReader(result);
                      DisplayProductInfo(reader);
                  }
              }
          
              private static void DisplayProductInfo(XmlReader reader)
              {
                  // Display the data within the reader.
                  while (reader.Read())
                  {
                      // Skip past items that are not from the correct table.
                      if (reader.LocalName.ToString() == "Production.Product")
                      {
                          Console.WriteLine("{0}: {1:C}",
                              reader["Name"], Convert.ToSingle(reader["ListPrice"]));
                      }
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,            
                  // you can retrieve it from a configuration file. 
                  return "Data Source=(local);Integrated Security=true;" +
                         "Initial Catalog=AdventureWorks";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            Any error that occurred while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader(System.AsyncCallback,System.Object)">
            <param name="callback">
        An <see cref="T:System.AsyncCallback" /> delegate that is invoked when the command's execution has completed. Pass <see langword="null" /> (<see langword="Nothing" /> in Microsoft Visual Basic) to indicate that no callback is required.
      </param><param name="stateObject">
        A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" /> property.
      </param><summary>
        Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and returns results as an <see cref="T:System.Xml.XmlReader" /> object, using a callback procedure.
      </summary><returns>
        An <see cref="T:System.IAsyncResult" /> that can be used to poll, wait for results, or both; this value is also needed when the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" /> is called, which returns the results of the command as XML.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> method starts the process of asynchronously executing a Transact-SQL statement or stored procedure that returns rows as XML, so that other tasks can run concurrently while the statement is executing. When the statement has completed, developers must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method to finish the operation and retrieve the requested XML data. The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> method returns immediately, but until the code executes the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method call, it must not execute any other calls that start a synchronous or asynchronous execution against the same <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object. Calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> before the command's execution is completed causes the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to block until the execution is finished.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property ordinarily specifies a Transact-SQL statement with a valid FOR XML clause. However, <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> can also specify a statement that returns data that contains valid XML. This method can also be used to retrieve a single-row, single-column result set. In this case, if more than one row is returned, the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method attaches the <see cref="T:System.Xml.XmlReader" /> to the value on the first row, and discards the rest of the result set.
        </para>
        <para>
          A typical <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> query can be formatted as in the following C# example:
        </para>
        <para>
          <code language="c#">
            SqlCommand command = new SqlCommand("SELECT ContactID, FirstName, LastName FROM Contact FOR XML AUTO, XMLDATA", SqlConn);
          </code>
        </para>
        <para>
          This method can also be used to retrieve a single-row, single-column result set. In this case, if more than one row is returned, the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method attaches the <see cref="T:System.Xml.XmlReader" /> to the value on the first row, and discards the rest of the result set.
        </para>
        <para>
          The multiple active result set (MARS) feature lets multiple actions use the same connection.
        </para>
        <para>
          The <paramref name="callback" /> parameter lets you specify an <see cref="P:System.AsyncCallback" /> delegate that is called when the statement has completed. You can call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method from within this delegate procedure, or from any other location within your application. In addition, you can pass any object in the <c>stateObject</c> parameter, and your callback procedure can retrieve this information using the <see cref="T:System.IAsyncResult.AsyncState" /> property.
        </para>
        <para>
          Note that the command text and parameters are sent to the server synchronously. If a large command or many parameters is sent, this method may block during writes. After the command is sent, the method returns immediately without waiting for an answer from the server--that is, reads are asynchronous.
        </para>
        <para>
          All errors that occur during the execution of the operation are thrown as exceptions in the callback procedure. You must handle the exception in the callback procedure, not in the main application. See the example in this topic for additional information on handling exceptions in the callback procedure.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server will return any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
        <para>
          This method ignores the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property.
        </para>
      </remarks><example>
        <para>
          The following Windows application demonstrates the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> method, executing a Transact-SQL statement that includes a delay of a few seconds (emulating a long-running command). This example passes the executing <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object as the <paramref name="stateObject" /> parameter--doing so makes it simple to retrieve the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object from within the callback procedure, so that the code can call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader" /> method corresponding to the initial call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />.
        </para>
        <para>
          To set up this example, create a new Windows application. Put a <see cref="T:System.Windows.Forms.Button" /> control, a <see cref="T:System.Windows.Forms.ListBox" /> control, and a <see cref="T:System.Windows.Forms.Label" /> control on the form (accepting the default name for each control). Add the following code to the form's class, modifying the connection string as needed for your environment.
        </para>
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.ComponentModel;
          using System.Data;
          using System.Drawing;
          using System.Text;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          namespace Microsoft.AdoDotNet.CodeSamples
          {
              public partial class Form1 : Form
              {
                  // Hook up the form's Load event handler and then add 
                  // this code to the form's class:
                  // You need these delegates in order to display text from a thread
                  // other than the form's thread. See the HandleCallback
                  // procedure for more information.
                  private delegate void DisplayInfoDelegate(string Text);
                  private delegate void DisplayReaderDelegate(XmlReader reader);
          
                  private bool isExecuting;
          
                  // This example maintains the connection object 
                  // externally, so that it is available for closing.
                  private SqlConnection connection;
          
                  public Form1()
                  {
                      InitializeComponent();
                  }
          
                  private string GetConnectionString()
                  {
                      // To avoid storing the connection string in your code, 
                      // you can retrieve it from a configuration file. 
                      return "Data Source=(local);Integrated Security=true;" +
                             "Initial Catalog=AdventureWorks";
                  }
          
                  private void DisplayStatus(string Text)
                  {
                      this.label1.Text = Text;
                  }
          
                  private void ClearProductInfo()
                  {
                      // Clear the list box.
                      this.listBox1.Items.Clear();
                  }
          
                  private void DisplayProductInfo(XmlReader reader)
                  {
                      // Display the data within the reader.
                      while (reader.Read())
                      {
                          // Skip past items that are not from the correct table.
                          if (reader.LocalName.ToString() == "Production.Product")
                          {
                              this.listBox1.Items.Add(String.Format("{0}: {1:C}",
                                  reader["Name"], Convert.ToDecimal(reader["ListPrice"])));
                          }
                      }
                      DisplayStatus("Ready");
                  }
          
                  private void Form1_FormClosing(object sender,
                      System.Windows.Forms.FormClosingEventArgs e)
                  {
                      if (isExecuting)
                      {
                          MessageBox.Show(this, "Cannot close the form until " +
                              "the pending asynchronous command has completed. Please wait...");
                          e.Cancel = true;
                      }
                  }
          
                  private void button1_Click(object sender, System.EventArgs e)
                  {
                      if (isExecuting)
                      {
                          MessageBox.Show(this,
                              "Already executing. Please wait until the current query " +
                              "has completed.");
                      }
                      else
                      {
                          SqlCommand command = null;
                          try
                          {
                              ClearProductInfo();
                              DisplayStatus("Connecting...");
                              connection = new SqlConnection(GetConnectionString());
          
                              // To emulate a long-running query, wait for 
                              // a few seconds before working with the data.
                              string commandText =
                                  "WAITFOR DELAY '00:00:03';" +
                                  "SELECT Name, ListPrice FROM Production.Product " +
                                  "WHERE ListPrice &lt; 100 " +
                                  "FOR XML AUTO, XMLDATA";
          
                              command = new SqlCommand(commandText, connection);
                              connection.Open();
          
                              DisplayStatus("Executing...");
                              isExecuting = true;
                              // Although it is not required that you pass the 
                              // SqlCommand object as the second parameter in the 
                              // BeginExecuteXmlReader call, doing so makes it easier
                              // to call EndExecuteXmlReader in the callback procedure.
                              AsyncCallback callback = new AsyncCallback(HandleCallback);
                              command.BeginExecuteXmlReader(callback, command);
          
                          }
                          catch (Exception ex)
                          {
                              isExecuting = false;
                              DisplayStatus(string.Format("Ready (last error: {0})", ex.Message));
                              if (connection != null)
                              {
                                  connection.Close();
                              }
                          }
                      }
                  }
          
                  private void HandleCallback(IAsyncResult result)
                  {
                      try
                      {
                          // Retrieve the original command object, passed
                          // to this procedure in the AsyncState property
                          // of the IAsyncResult parameter.
                          SqlCommand command = (SqlCommand)result.AsyncState;
                          XmlReader reader = command.EndExecuteXmlReader(result);
          
                          // You may not interact with the form and its contents
                          // from a different thread, and this callback procedure
                          // is all but guaranteed to be running from a different thread
                          // than the form. 
          
                          // Instead, you must call the procedure from the form's thread.
                          // One simple way to accomplish this is to call the Invoke
                          // method of the form, which calls the delegate you supply
                          // from the form's thread. 
                          DisplayReaderDelegate del = new DisplayReaderDelegate(DisplayProductInfo);
                          this.Invoke(del, reader);
          
                      }
                      catch (Exception ex)
                      {
                          // Because you are now running code in a separate thread, 
                          // if you do not handle the exception here, none of your other
                          // code catches the exception. Because none of 
                          // your code is on the call stack in this thread, there is nothing
                          // higher up the stack to catch the exception if you do not 
                          // handle it here. You can either log the exception or 
                          // invoke a delegate (as in the non-error case in this 
                          // example) to display the error on the form. In no case
                          // can you simply display the error without executing a delegate
                          // as in the try block here. 
          
                          // You can create the delegate instance as you 
                          // invoke it, like this:
                          this.Invoke(new DisplayInfoDelegate(DisplayStatus),
                          String.Format("Ready(last error: {0}", ex.Message));
                      }
                      finally
                      {
                          isExecuting = false;
                          if (connection != null)
                          {
                              connection.Close();
                          }
                      }
                  }
          
                  private void Form1_Load(object sender, System.EventArgs e)
                  {
                      this.button1.Click += new System.EventHandler(this.button1_Click);
                      this.FormClosing += new System.Windows.Forms.
                          FormClosingEventHandler(this.Form1_FormClosing);
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            Any error that occurred while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlCommand.EnableOptimizedParameterBinding" /> is set to true and a parameter with direction Output or InputOutput has been added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><seealso cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" /><seealso cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.Cancel">
            <summary>
        Tries to cancel the execution of a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
      </summary><remarks>
        <para>
          If there is nothing to cancel, nothing occurs. However, if there is a command in process, and the attempt to cancel fails, no exception is generated.
        </para>
        <para>
          In some rare cases, if you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" />, then call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Close" /> (implicitly or explicitly) before calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" />, and then call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" />, the cancel command will not be sent to SQL Server and the result set can continue to stream after you call <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" />. To avoid this, make sure that you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" /> before closing the reader or connection.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" /> method.
        </para>
        <code language="c#">
          using System;
          using System.Data;
          using System.Threading;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static SqlCommand m_rCommand;
          
              public static SqlCommand Command
              {
                  get { return m_rCommand; }
                  set { m_rCommand = value; }
              }
          
              public static void Thread_Cancel()
              {
                  Command.Cancel();
              }
          
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  try
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
          
                          Command = connection.CreateCommand();
                          Command.CommandText = "DROP TABLE TestCancel";
                          try
                          {
                              Command.ExecuteNonQuery();
                          }
                          catch { }
          
                          Command.CommandText = "CREATE TABLE TestCancel(co1 int, co2 char(10))";
                          Command.ExecuteNonQuery();
                          Command.CommandText = "INSERT INTO TestCancel VALUES (1, '1')";
                          Command.ExecuteNonQuery();
          
                          Command.CommandText = "SELECT * FROM TestCancel";
                          SqlDataReader reader = Command.ExecuteReader();
          
                          Thread rThread2 = new Thread(new ThreadStart(Thread_Cancel));
                          rThread2.Start();
                          rThread2.Join();
          
                          reader.Read();
                          System.Console.WriteLine(reader.FieldCount);
                          reader.Close();
                      }
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine(ex.Message);
                  }
              }
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.Clone">
            <summary>
        Creates a new <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object that is a copy of the current instance.
      </summary><returns>
        A new <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object that is a copy of this instance.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.CreateDbParameter">
            <summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.CreateParameter">
            <summary>
        Creates a new instance of a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </returns><remarks>
        The <see cref="M:Microsoft.Data.SqlClient.SqlCommand.CreateParameter" /> method is a strongly-typed version of <see cref="M:System.Data.IDbCommand.CreateParameter" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)">
            <param name="asyncResult">
        The <see cref="T:System.IAsyncResult" /> returned by the call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />.
      </param><summary>
        Finishes asynchronous execution of a Transact-SQL statement.
      </summary><returns>
        The number of rows affected (the same behavior as <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" />).
      </returns><remarks>
        When you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> to execute a Transact-SQL statement, you must call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" /> in order to complete the operation. If the process of executing the command has not yet finished, this method blocks until the operation is complete. Users can verify that the command has completed its operation by using the <see cref="T:System.IAsyncResult" /> instance returned by the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> method. If a callback procedure was specified in the call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />, this method must be called.
      </remarks><example>
        For examples demonstrating the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" /> method, see <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />.
      </example><exception cref="T:System.ArgumentException">
        <paramref name="asyncResult" /> parameter is null (<see langword="Nothing" /> in Microsoft Visual Basic)
      </exception><exception cref="T:System.InvalidOperationException">
        <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" /> was called more than once for a single command execution, or the method was mismatched against its execution method (for example, the code called <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" /> to complete execution of a call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            The amount of time specified in <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> elapsed and the asynchronous operation specified with <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> is not complete.
          </item>
          <item>
            In some situations, <see cref="T:System.IAsyncResult" /> can set <see cref="P:System.IAsyncResult.IsCompleted" /> incorrectly. If this occurs and <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" /> is called, EndExecuteNonQuery could raise a SqlException error if the amount of time specified in <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> elapsed and the asynchronous operation specified with <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" /> is not complete. To correct this situation, you should either increase the value of CommandTimeout or reduce the work being done by the asynchronous operation.
          </item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)">
            <param name="asyncResult">
        The <see cref="T:System.IAsyncResult" /> returned by the call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" />.
      </param><summary>
        Finishes asynchronous execution of a Transact-SQL statement, returning the requested <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> object that can be used to retrieve the requested rows.
      </returns><remarks>
        When you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to execute a Transact-SQL statement, you must call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" /> in order to complete the operation. If the process of executing the command has not yet finished, this method blocks until the operation is complete. Users can verify that the command has completed its operation by using the <see cref="T:System.IAsyncResult" /> instance returned by the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> method. If a callback procedure was specified in the call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" />, this method must be called.
      </remarks><example>
        For examples demonstrating the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" /> method, see <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" />.
      </example><exception cref="T:System.ArgumentException">
        <paramref name="asyncResult" /> parameter is null (<see langword="Nothing" /> in Microsoft Visual Basic)
      </exception><exception cref="T:System.InvalidOperationException">
        <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" /> was called more than once for a single command execution, or the method was mismatched against its execution method (for example, the code called <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" /> to complete execution of a call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)">
            <param name="asyncResult">
        The <see cref="T:System.IAsyncResult" /> returned by the call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />.
      </param><summary>
        Finishes asynchronous execution of a Transact-SQL statement, returning the requested data as XML.
      </summary><returns>
        An <see cref="T:System.Xml.XmlReader" /> object that can be used to fetch the resulting XML data.
      </returns><remarks>
        When you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to execute a Transact-SQL statement, you must call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" /> in order to complete the operation. If the process of executing the command has not yet finished, this method blocks until the operation is complete. Users can verify that the command has completed its operation by using the <see cref="T:System.IAsyncResult" /> instance returned by the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> method. If a callback procedure was specified in the call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />, this method must be called.
      </remarks><example>
        For examples demonstrating the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" /> method, see <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />.
      </example><exception cref="T:System.ArgumentException">
        <paramref name="asyncResult" /> parameter is null (<see langword="Nothing" /> in Microsoft Visual Basic)
      </exception><exception cref="T:System.InvalidOperationException">
        <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" /> was called more than once for a single command execution, or the method was mismatched against its execution method (for example, the code called <see cref="M:Microsoft.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" /> to complete execution of a call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteDbDataReader(System.Data.CommandBehavior)">
            <param name="behavior">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)">
            <param name="behavior">
        To be added.
      </param><param name="cancellationToken">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery">
            <summary>
        Executes a Transact-SQL statement against the connection and returns the number of rows affected.
      </summary><returns>
        The number of rows affected.
      </returns><remarks>
        <para>
          You can use the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" /> to perform catalog operations (for example, querying the structure of a database or creating database objects such as tables), or to change the data in a database without using a <see cref="T:System.Data.DataSet" /> by executing UPDATE, INSERT, or DELETE statements.
        </para>
        <para>
          Although the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" /> returns no rows, any output parameters or return values mapped to parameters are populated with data.
        </para>
        <para>
          For UPDATE, INSERT, and DELETE statements, the return value is the number of rows affected by the command. For all other types of statements, the return value is -1. When a trigger exists on a table being inserted or updated, the return value includes the number of rows affected by both the insert or update operation and the number of rows affected by the trigger or triggers. When SET NOCOUNT ON is set on the connection (before or as part of executing the command, or as part of a trigger initiated by the execution of the command) the rows affected by individual statements stop contributing to the count of rows affected that is returned by this method. If no statements are detected that contribute to the count, the return value is -1. If a rollback occurs, the return value is also -1. 
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and then executes it using <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" />. The example is passed a string that is a Transact-SQL statement (such as UPDATE, INSERT, or DELETE) and a string to use to connect to the data source.
        </para>
        <!-- SqlCommand_ExecuteNonQuery -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace SqlCommandCS
          {
              class Program
              {
                  static void Main()
                  {
                      string str = "Data Source=(local);Initial Catalog=Northwind;"
                                 + "Integrated Security=SSPI";
                      string qs = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                      CreateCommand(qs, str);
                  }
                  private static void CreateCommand(string queryString,
                      string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(
                                 connectionString))
                      {
                          SqlCommand command = new SqlCommand(queryString, connection);
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.InvalidOperationException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" />, which executes a Transact-SQL statement against the connection and returns the number of rows affected. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        <para>
          For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
        <note type="note">
          For long-running queries on the server, consider using <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" /> due to a known issue with canceling queries via a cancellation token. Also, consider canceling execution using the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" /> method.
        </note>
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader">
            <summary>
        Sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> object.
      </returns><remarks>
        <para>
          When the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /> property is set to <see cref="F:System.Data.CommandType.StoredProcedure" />, the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property should be set to the name of the stored procedure. The command executes this stored procedure when you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" />.
        </para>
        <note type="note">
          If a transaction is deadlocked, an exception may not be thrown until <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> is called.
        </note>
        <para>
          The multiple active result set (MARS) feature allows for multiple actions using the same connection.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server will return any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, and then executes it by passing a string that is a Transact-SQL SELECT statement, and a string to use to connect to the data source.
        </para>
        <!-- SqlCommand_ExecuteReader -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
            
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI";
                  string qs = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                  CreateCommand(qs, str);
              }
          
              private static void CreateCommand(string queryString, string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      SqlCommand command = new SqlCommand(queryString, connection);
                      SqlDataReader reader = command.ExecuteReader();
                      while (reader.Read())
                      {
                          Console.WriteLine(String.Format("{0}", reader[0]));
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The current state of the connection is closed. <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> requires an open <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior)">
            <param name="behavior">
        One of the <see cref="T:System.Data.CommandBehavior" /> values.
      </param><summary>
        Sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" />, and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> using one of the <see cref="T:System.Data.CommandBehavior" /> values.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> object.
      </returns><remarks>
        <para>
          When the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /> property is set to <see cref="F:System.Data.CommandType.StoredProcedure" />, the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property should be set to the name of the stored procedure. The command executes this stored procedure when you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" />.
        </para>
        <note type="note">
          Use <see cref="F:System.Data.CommandBehavior.SequentialAccess" /> to retrieve large values and binary data. Otherwise, an <see cref="T:System.OutOfMemoryException" /> might occur and the connection will be closed.
        </note>
        <para>
          The multiple active result set (MARS) feature allows for multiple actions using the same connection.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server will return any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, and then executes it by passing a string that is a Transact-SQL SELECT statement, and a string to use to connect to the data source. <see cref="T:System.Data.CommandBehavior" /> is set to <see cref="F:System.Data.CommandBehavior.CloseConnection" />.
        </para>
        <!-- SqlCommand_ExecuteReader2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI";
                  string qs = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                  CreateCommand(qs, str);
              }
          
              private static void CreateCommand(string queryString, string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      connection.Open();
                      SqlDataReader reader = command.ExecuteReader(CommandBehavior.CloseConnection);
                      while (reader.Read())
                      {
                          Console.WriteLine(String.Format("{0}", reader[0]));
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type-="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.InvalidOperationException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync">
            <summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" />, which sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        <para>
          For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
        <note type="note">
          For long-running queries on the server, consider using <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> due to a known issue with canceling queries via a cancellation token. Also, consider canceling execution using the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" /> method.
        </note>
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.ArgumentException">
        An invalid <see cref="T:System.Data.CommandBehavior" /> value.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync" /> more than once for the same instance before task completion.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior)">
            <param name="behavior">
        Options for statement execution and data retrieval. When is set to <see langword="Default" />, <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.ReadAsync(System.Threading.CancellationToken)" /> reads the entire row before returning a complete Task.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior)" />, which sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" />, and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.ArgumentException">
        An invalid <see cref="T:System.Data.CommandBehavior" /> value.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior)" /> more than once for the same instance before task completion.
          </item>
          <item>
            <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)">
            <param name="behavior">
        Options for statement execution and data retrieval. When is set to <see langword="Default" />, <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.ReadAsync(System.Threading.CancellationToken)" /> reads the entire row before returning a complete Task.
      </param><param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior)" />, which sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" />, and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.ArgumentException">
        An invalid <see cref="T:System.Data.CommandBehavior" /> value.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" />, which sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.ArgumentException">
        An invalid <see cref="T:System.Data.CommandBehavior" /> value.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalar">
            <summary>
        Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.
      </summary><returns>
        The first column of the first row in the result set, or a null reference (<see langword="Nothing" /> in Visual Basic) if the result set is empty. Returns a maximum of 2033 characters.
      </returns><remarks>
        <para>
          Use the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalar" /> method to retrieve a single value (for example, an aggregate value) from a database. This requires less code than using the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> method, and then performing the operations that you need to generate the single value using the data returned by a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
        </para>
      </remarks><example>
        <para>
          A typical <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalar" /> query can be formatted as in the following C# example:
        </para>
        <code language="c#">
          cmd.CommandText = "SELECT COUNT(*) FROM dbo.region";
          Int32 count = (Int32) cmd.ExecuteScalar();
        </code>
      </example><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and then executes it using <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalar" />. The example is passed a string representing a new value to be inserted into a table, and a string to use to connect to the data source. The function returns the new <b>Identity</b> column value if a new row was inserted, 0 on failure. &gt;
        </para>
        <!-- SqlCommand_ExecuteScalar -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          public class Sample
          {
              public void CreateSqlCommand(string queryString, SqlConnection connection)
              {
                  SqlCommand command = new SqlCommand(queryString, connection);
                  command.Connection.Open();
                  command.ExecuteScalar();
                  connection.Close();
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalarAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalar" />, which executes the query asynchronously and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        <para>
          For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
        <note type="note">
          For long-running queries on the server, consider using <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalar" /> due to a known issue with canceling queries via a cancellation token. Also, consider canceling execution using the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" /> method.
        </note>
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader">
            <summary>
        Sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds an <see cref="T:System.Xml.XmlReader" /> object.
      </summary><returns>
        An <see cref="T:System.Xml.XmlReader" /> object.
      </returns><remarks>
        <para>
          The <see cref="T:System.Xml.XmlReader" /> returned by this method does not support asynchronous operations. The <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> property ordinarily specifies a Transact-SQL statement with a valid FOR XML clause. However, <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> can also specify a statement that returns <c>ntext</c> or <c>nvarchar</c> data that contains valid XML, or the contents of a column defined with the <c>xml</c> data type.
        </para>
        <para>
          A typical <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> query can be formatted as in the following Microsoft Visual C# example:
        </para>
        <code language="c#">
          SqlCommand command = new SqlCommand("SELECT * FROM dbo.Customers FOR XML AUTO, XMLDATA", SqlConn);
        </code>
        <para>
          This method can also be used to retrieve a single-row, single-column result set that contains XML data. In this case, if more than one row is returned, the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> method attaches the <see cref="T:System.Xml.XmlReader" /> to the value on the first row, and discards the rest of the result set.
        </para>
        <para>
          The multiple active result set (MARS) feature allows for multiple actions using the same connection.
        </para>
        <para>
          If you use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteReader" /> to access XML data, SQL Server will return any XML results greater than 2,033 characters in length in multiple rows of 2,033 characters each. To avoid this behavior, use <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" /> to read FOR XML queries.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and then executes it using <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" />. The example is passed a string that is a Transact-SQL FOR XML SELECT statement, and a string to use to connect to the data source.
        </para>
        <!-- SqlCommand_ExecuteXmlReader -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          private static void CreateXMLReader(string queryString, string connectionString)
          {
              using (SqlConnection connection = new SqlConnection(connectionString))
              {
                  connection.Open();
                  SqlCommand command = new SqlCommand(queryString, connection);
                  System.Xml.XmlReader reader = command.ExecuteXmlReader();
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReaderAsync">
            <summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" />, which sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds an <see cref="T:System.Xml.XmlReader" /> object.
        Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        <para>
          The <see cref="T:System.Xml.XmlReader" /> returned by this method does not support asynchronous operations. For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
        <note type="note">
          For long-running queries on the server, consider using <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" /> due to a known issue with canceling queries via a cancellation token. Also, consider canceling execution using the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" /> method.
        </note>
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReaderAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteXmlReader" />, which sends the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds an <see cref="T:System.Xml.XmlReader" /> object. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        The <see cref="T:System.Xml.XmlReader" /> returned by this method does not support asynchronous operations. For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidCastException">
        <list type="bullet">
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Binary</c> or <c>VarBinary</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.Stream" />. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Char</c>, <c>NChar</c>, <c>NVarChar</c>, <c>VarChar</c>, or <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.IO.TextReader" />.
          </item>
          <item>
            A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> other than <c>Xml</c> was used when <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> was set to <see cref="T:System.Xml.XmlReader" />.
          </item>
        </list>
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            Calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
          </item>
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> closed or dropped during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <list type="bullet">
          <item>
            SQL Server returned an error while executing the command text.
          </item>
          <item>
            A timeout occurred during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
          </item>
        </list>
      </exception><exception cref="T:System.IO.IOException">
        An error occurred in a <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object during a streaming operation.For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception><exception cref="T:System.ObjectDisposedException">
        The <see cref="T:System.IO.Stream" />, <see cref="T:System.Xml.XmlReader" /> or <see cref="T:System.IO.TextReader" /> object was closed during a streaming operation. For more information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.Prepare">
            <summary>
        Creates a prepared version of the command on an instance of SQL Server.
      </summary><remarks>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandType" /> is set to <see cref="F:System.Data.CommandType.StoredProcedure" />, the call to <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Prepare" /> should succeed, although it may cause a no-op.
        </para>
        <para>
          Before you call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Prepare" />, specify the data type of each parameter in the statement to be prepared. For each parameter that has a variable length data type, you must set the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" /> property to the maximum size needed. <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Prepare" /> returns an error if these conditions are not met.
        </para>
        <note type="note">
          If the database context is changed by executing the Transact-SQL <c>USE &lt;database&gt;</c> statement, or by calling the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ChangeDatabase(System.String)" /> method, then <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Prepare" /> must be called a second time.
        </note>
        <para>
          If you call an <c>Execute*</c> method after calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Prepare" />, any parameter value that is larger than the value specified by the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" /> property is automatically truncated to the original specified size of the parameter, and no truncation errors are returned.
        </para>
        <para>
          Output parameters (whether prepared or not) must have a user-specified data type. If you specify a variable length data type, you must also specify the maximum <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" />.
        </para>
        <para>
          Prior to Visual Studio 2010, <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Prepare" /> threw an exception. Beginning in Visual Studio 2010, this method does not throw an exception.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates the use of the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Prepare" /> method.
        </para>
        <!-- SqlCommand_Prepare -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace SqlPrepareCS
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString = "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      SqlCommandPrepareEx(connectionString);
                      Console.ReadLine();
          
                  }
                  private static void SqlCommandPrepareEx(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
                          SqlCommand command = new SqlCommand(null, connection);
          
                          // Create and prepare an SQL statement.
                          command.CommandText =
                              "INSERT INTO Region (RegionID, RegionDescription) " +
                              "VALUES (@id, @desc)";
                          SqlParameter idParam = new SqlParameter("@id", SqlDbType.Int, 0);
                          SqlParameter descParam = new SqlParameter("@desc", SqlDbType.Text, 100);
                          idParam.Value = 20;
                          descParam.Value = "First Region";
                          command.Parameters.Add(idParam);
                          command.Parameters.Add(descParam);
          
                          // Call Prepare after setting the Commandtext and Parameters.
                          command.Prepare();
                          command.ExecuteNonQuery();
          
                          // Change parameter values and call ExecuteNonQuery.
                          command.Parameters[0].Value = 21;
                          command.Parameters[1].Value = "Second Region";
                          command.ExecuteNonQuery();
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.Notification">
            <summary>
        Gets or sets a value that specifies the <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> object bound to this command.
      </summary><value>
        When set to null (default), no notification should be requested.
      </value><remarks>
        You must set the value for this property before the command is executed for it to take effect.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.RegisterColumnEncryptionKeyStoreProvidersOnCommand(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})">
            <param name="customProviders">
        Dictionary of custom column encryption key providers
      </param><summary>
        Registers the encryption key store providers on the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> instance. If this function has been called, any providers registered using the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" /> or <see cref="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProvidersOnConnection(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" /> methods will be ignored. This function can be called more than once. This does shallow copying of the dictionary so that the app cannot alter the custom provider list once it has been set.
      </summary><remarks>
        <para>
          Custom master key store providers can be registered with the driver at three different layers. The precedence of the three registrations is as follows:
        </para>
        <list type="bullet">
          <item>The per-command registration will be checked if it is not empty.</item>
          <item>If the per-command registration is empty, the per-connection registration will be checked if it is not empty.</item>
          <item>If the per-connection registration is empty, the global registration will be checked.</item>
        </list>
        <para>
          Once any key store provider is found at a registration level, the driver will <b>NOT</b> fall back to the other registrations to search for a provider. If providers are registered but the proper provider is not found at a level, an exception will be thrown containing only the registered providers in the registration that was checked.
        </para>
        <para>
          The built-in column master key store providers that are available for the Windows Certificate Store, CNG Store and CSP are pre-registered.
        </para>
        <para>
          This does shallow copying of the dictionary so that the app cannot alter the custom provider list once it has been set.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        <list type="bullet">
          <item>A null dictionary was provided.</item>
          <item>A string key in the dictionary was null or empty.</item>
          <item>
            A <see cref="T:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider" /> value in the dictionary was null.
          </item>
        </list>
      </exception><exception cref="T:System.ArgumentException">
        A string key in the dictionary started with "MSSQL_". This prefix is reserved for system providers.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.ResetCommandTimeout">
            <summary>
        Resets the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> property to its default value.
      </summary><remarks>
        The default value of the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> is 30 seconds.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommand.RetryLogicProvider">
            <summary>
        Gets or sets a value that specifies the <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object bound to this command.
      </summary><value>
        When set to null (default), the default non-retryable provider will be used.
      </value><remarks>
        <para>
          You must set the value for this property before the command is executed for it to take effect.
        </para>
        <para>
          To apply the retry logic, do the following steps before executing the command:
        </para>
        <list type="number">
          <item>
            Define the configuration parameters by using <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicOption" /> type.
          </item>
          <item>
            Create a <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> by using one of the following static methods of the <see cref="T:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory" /> class:
            <list type="bullet">
              <item>
                <see cref="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateFixedRetryProvider" />
              </item>
              <item>
                <see cref="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateIncrementalRetryProvider" />
              </item>
              <item>
                <see cref="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateExponentialRetryProvider" />
              </item>
              <item>
                <see cref="M::Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateNoneRetryProvider" />
              </item>
            </list>
          </item>
          <item>
            Assign the <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object to the <c>RetryLogicProvider</c> property.
          </item>
        </list>
        <note type="note">
          Detecting retryable exceptions is a vital part of the retry pattern. Before applying retry logic, it is important to investigate exceptions and choose a retry provider that best fits your scenario. First, log your exceptions and find transient faults.
        </note>
        <note type="note">
          The command <b>timeout</b> restarts for each execution of a command within the retry logic and after applying the retry time delay. There is no timing overlap between these two actions.
        </note>
        <note type="note">
          The default retry logic provider is not enabled unless it is configured in an application configuration file. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/configurable-retry-logic-config-file-sqlclient">Configurable retry logic configuration file</see>.
        </note>
        <note type="caution">
          A command with <see cref="F:System.Data.CommandBehavior.CloseConnection" /> isn't compatible with the built-in retry logic. The underlying connection is immediately closed after the first execution attempt and is no longer available for subsequent retries.
        </note>
      </remarks><example>
        <para>
          The following sample creates a database and establishes an active connection to it. While the database has an active connection, it tries to drop it with a new <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> that uses a <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" />. You should kill the active connection through the database to unblock the second command before exceeding the number of retries. The blocking connection simulates a situation like a command still running in the database and unlikely to finish.
        </para>
        <!-- SqlConfigurableRetryLogic_SqlCommand #1 -->
        <code language="c#">
          /// Detecting retriable exceptions is a vital part of the retry pattern.
          /// Before applying retry logic it is important to investigate exceptions and choose a retry provider that best fits your scenario.
          /// First, log your exceptions and find transient faults.
          /// The purpose of this sample is to illustrate how to use this feature and the condition might not be realistic.
          
          private const string DefaultDB = "Northwind";
          private const string CnnStringFormat = "Server=localhost; Initial Catalog={0}; Integrated Security=true; pooling=false;";
          private const string DropDatabaseFormat = "DROP DATABASE {0}";
          private const string CreateDatabaseFormat = "CREATE DATABASE {0}";
      
          // For general use
          private static SqlConnection s_generalConnection = new SqlConnection(string.Format(CnnStringFormat, DefaultDB));
      
          static void Main(string[] args)
          {
              // 1. Define the retry logic parameters
              var options = new SqlRetryLogicOption()
              {
                  NumberOfTries = 5,
                  MaxTimeInterval = TimeSpan.FromSeconds(20),
                  DeltaTime = TimeSpan.FromSeconds(1),
                  AuthorizedSqlCondition = null,
                  // error number 3702 : Cannot drop database "xxx" because it is currently in use.
                  TransientErrors = new int[] { 3702 }
              };
      
              // 2. Create a retry provider
              var provider = SqlConfigurableRetryFactory.CreateExponentialRetryProvider(options);
      
              // define the retrying event to report execution attempts
              provider.Retrying += (object s, SqlRetryingEventArgs e) =&gt;
                  {
                      int attempts = e.RetryCount + 1;
                      Console.ForegroundColor = ConsoleColor.Yellow;
                      Console.WriteLine($"attempt {attempts} - current delay time:{e.Delay} \n");
                      Console.ForegroundColor = ConsoleColor.DarkGray;
                      if (e.Exceptions[e.Exceptions.Count - 1] is SqlException ex)
                      {
                          Console.WriteLine($"{ex.Number}-{ex.Message}\n");
                      }
                      else
                      {
                          Console.WriteLine($"{e.Exceptions[e.Exceptions.Count - 1].Message}\n");
                      }
      
                      // It is not good practice to do time-consuming tasks inside the retrying event which blocks the running task.
                      // Use parallel programming patterns to mitigate it.
                      if (e.RetryCount == provider.RetryLogic.NumberOfTries - 1)
                      {
                          Console.WriteLine("This is the last chance to execute the command before throwing the exception.");
                          Console.WriteLine("Press Enter when you're ready:");
                          Console.ReadLine();
                          Console.WriteLine("continue ...");
                      }
                  };
      
              // Open a general connection.
              s_generalConnection.Open();
      
              try
              {
                  // Assume the database is creating and other services are going to connect to it.
                  RetryCommand(provider);
              }
              catch
              {
                  s_generalConnection.Close();
                  // exception is thrown if connecting to the database isn't successful.
                  throw;
              }
              s_generalConnection.Close();
          }
      
          private static void ExecuteCommand(SqlConnection cn, string command)
          {
              using var cmd = cn.CreateCommand();
              cmd.CommandText = command;
              cmd.ExecuteNonQuery();
          }
      
          private static void FindActiveSessions(SqlConnection cnn, string dbName)
          {
              using var cmd = cnn.CreateCommand();
              cmd.CommandText = "DECLARE @query NVARCHAR(max) = '';" + Environment.NewLine +
                  $"SELECT @query = @query + 'KILL ' + CAST(spid as varchar(50)) + ';' FROM sys.sysprocesses WHERE dbid = DB_ID('{dbName}')" + Environment.NewLine +
                  "SELECT @query AS Active_sessions;";
              var reader = cmd.ExecuteReader();
              if (reader.Read())
              {
                  Console.ForegroundColor = ConsoleColor.Green;
                  Console.Write($"&gt;&gt; Execute the '{reader.GetString(0)}' command in SQL Server to unblock the running task.");
                  Console.ResetColor();
              }
              reader.Close();
          }
        </code>
        <para>
          How to use with synchronous commands:
        </para>
        <!-- SqlConfigurableRetryLogic_SqlCommand #2 -->
        <code language="c#">
          private static void RetryCommand(SqlRetryLogicBaseProvider provider)
          {
              // Change this if you already have a database with the same name in your database.
              string dbName = "RetryCommand_TestDatabase";
      
              // Subscribe a new event on retry event and discover the active sessions on a database
              EventHandler&lt;SqlRetryingEventArgs&gt; retryEvent = (object s, SqlRetryingEventArgs e) =&gt;
              {
                  // Run just at first execution
                  if (e.RetryCount == 1)
                  {
                      FindActiveSessions(s_generalConnection, dbName);
                      Console.WriteLine($"Before exceeding {provider.RetryLogic.NumberOfTries} attempts.");
                  }
              };
      
              provider.Retrying += retryEvent;
      
              // Create a new database.
              ExecuteCommand(s_generalConnection, string.Format(CreateDatabaseFormat, dbName));
              Console.WriteLine($"The '{dbName}' database is created.");
      
              // Open a connection to the newly created database to block it from being dropped.
              using var blockingCnn = new SqlConnection(string.Format(CnnStringFormat, dbName));
              blockingCnn.Open();
              Console.WriteLine($"Established a connection to '{dbName}' to block it from being dropped.");
      
              Console.WriteLine($"Dropping `{dbName}`...");
              // Try to drop the new database.
              RetryCommandSync(provider, dbName);
      
              Console.WriteLine("Command executed successfully.");
      
              provider.Retrying -= retryEvent;
          }
      
          private static void RetryCommandSync(SqlRetryLogicBaseProvider provider, string dbName)
          {
              using var cmd = s_generalConnection.CreateCommand();
              cmd.CommandText = string.Format(DropDatabaseFormat, dbName);
              // 3. Assign the `provider` to the command
              cmd.RetryLogicProvider = provider;
              Console.WriteLine("The first attempt, before getting into the retry logic.");
              cmd.ExecuteNonQuery();
          }
        </code>
        <para>
          How to use with asynchronous commands:
        </para>
        <!-- SqlConfigurableRetryLogic_SqlCommand #3 -->
        <code language="c#">
          private static void RetryCommand(SqlRetryLogicBaseProvider provider)
          {
              // Change this if you already have a database with the same name in your database.
              string dbName = "RetryCommand_TestDatabase";
      
              // Subscribe to the retry event and discover active sessions in a database
              EventHandler&lt;SqlRetryingEventArgs&gt; retryEvent = (object s, SqlRetryingEventArgs e) =&gt;
              {
                  // Run just at first execution
                  if (e.RetryCount == 1)
                  {
                      FindActiveSessions(s_generalConnection, dbName);
                      Console.WriteLine($"Before exceeding {provider.RetryLogic.NumberOfTries} attempts.");
                  }
              };
      
              provider.Retrying += retryEvent;
      
              // Create a new database.
              ExecuteCommand(s_generalConnection, string.Format(CreateDatabaseFormat, dbName));
              Console.WriteLine($"The '{dbName}' database is created.");
      
              // Open a connection to the newly created database to block it from being dropped.
              using var blockingCnn = new SqlConnection(string.Format(CnnStringFormat, dbName));
              blockingCnn.Open();
              Console.WriteLine($"Established a connection to '{dbName}' to block it from being dropped.");
      
              Console.WriteLine("Dropping the database...");
              // Try to drop the new database.
              RetryCommandAsync(provider, dbName).Wait();
      
              Console.WriteLine("Command executed successfully.");
      
              provider.Retrying -= retryEvent;
          }
      
          private static async Task RetryCommandAsync(SqlRetryLogicBaseProvider provider, string dbName)
          {
              using var cmd = s_generalConnection.CreateCommand();
              cmd.CommandText = string.Format(DropDatabaseFormat, dbName);
              // 3. Assign the `provider` to the command
              cmd.RetryLogicProvider = provider;
              Console.WriteLine("The first attempt, before getting into the retry logic.");
              await cmd.ExecuteNonQueryAsync();
          }
        </code>
        <para>
          How to use with legacy asynchronous commands:
        </para>
        <para>
          Besides assigning the provider to the command and executing the command, it's possible to run it directly using the following <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> methods:
        </para>
        <list type="bullet">
          <item>
            <see cref="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Execute{T1}" />
          </item>
          <item>
            <see cref="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.ExecuteAsync(System.Object,System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          </item>
          <item>
            <see cref="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.ExecuteAsync{T1}(System.Object,System.Func{System.Threading.Tasks.Task{T1}},System.Threading.CancellationToken)" />
          </item>
        </list>
        <!-- SqlConfigurableRetryLogic_SqlCommand #4 -->
        <code language="c#">
          private static void RetryCommand(SqlRetryLogicBaseProvider provider)
          {
              // Change this if you already have a database with the same name in your database.
              string dbName = "RetryCommand_TestDatabase";
      
              // Subscribe to the retry event and discover the active sessions in a database
              EventHandler&lt;SqlRetryingEventArgs&gt; retryEvent = (object s, SqlRetryingEventArgs e) =&gt;
              {
                  // Run just at first execution
                  if (e.RetryCount == 1)
                  {
                      FindActiveSessions(s_generalConnection, dbName);
                      Console.WriteLine($"Before exceeding {provider.RetryLogic.NumberOfTries} attempts.");
                  }
              };
      
              provider.Retrying += retryEvent;
      
              // Create a new database.
              ExecuteCommand(s_generalConnection, string.Format(CreateDatabaseFormat, dbName));
              Console.WriteLine($"The '{dbName}' database is created.");
      
              // Open a connection to the newly created database to block it from being dropped.
              using var blockingCnn = new SqlConnection(string.Format(CnnStringFormat, dbName));
              blockingCnn.Open();
              Console.WriteLine($"Established a connection to '{dbName}' to block it from being dropped.");
      
              Console.WriteLine("Dropping the database...");
              // Try to drop the new database.
              RetryCommandBeginExecuteAsync(provider, dbName).Wait();
      
              Console.WriteLine("Command executed successfully.");
      
              provider.Retrying -= retryEvent;
          }
      
          private static async Task RetryCommandBeginExecuteAsync(SqlRetryLogicBaseProvider provider, string dbName)
          {
              using var cmd = s_generalConnection.CreateCommand();
              cmd.CommandText = string.Format(DropDatabaseFormat, dbName);
              // Execute the BeginExecuteXXX and EndExecuteXXX functions by using Task.Factory.FromAsync().
              // Apply the retry logic by using the ExecuteAsync function of the configurable retry logic provider.
              Console.WriteLine("The first attempt, before getting into the retry logic.");
              await provider.ExecuteAsync(cmd, () =&gt; Task.Factory.FromAsync(cmd.BeginExecuteNonQuery(), cmd.EndExecuteNonQuery));
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommand.Dispose(System.Boolean)">
            <param name="disposing">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlCommandBuilder">
            <summary>
        Automatically generates single-table commands that are used to reconcile changes made to a <see cref="T:System.Data.DataSet" /> with the associated SQL Server database. This class cannot be inherited.
      </summary><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> does not automatically generate the Transact-SQL statements required to reconcile changes made to a <see cref="T:System.Data.DataSet" /> with the associated instance of SQL Server. However, you can create a <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> object to automatically generate Transact-SQL statements for single-table updates if you set the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />. Then, any additional Transact-SQL statements that you do not set are generated by the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> registers itself as a listener for <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> events whenever you set the <see cref="P:Microsoft.Data.SqlClient.SqlCommandBuilder.DataAdapter" /> property. You can only associate one <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> or <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> object with each other at one time.
        </para>
        <para>
          To generate INSERT, UPDATE, or DELETE statements, the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> uses the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property to retrieve a required set of metadata automatically. If you change the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> after the metadata has been retrieved, such as after the first update, you should call the <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> method to update the metadata.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> must also return at least one primary key or unique column. If none are present, an <see cref="T:System.InvalidOperationException" /> exception is generated, and the commands are not generated.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> also uses the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" />, <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" />, and <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Transaction" /> properties referenced by the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" />. The user should call <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> if one or more of these properties are modified, or if the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> itself is replaced. Otherwise the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />, and <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> properties retain their previous values.
        </para>
        <para>
          If you call <see cref="M:System.ComponentModel.Component.Dispose" />, the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> is disassociated from the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />, and the generated commands are no longer used.
        </para>
      </remarks><example>
        <para>
          The following example uses the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, along <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, to select rows from a data source. The example is passed a connection string, a query string that is a Transact-SQL SELECT statement, and a string that is the name of the database table. The example then creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />.
        </para>
        <!-- SqlCommandBuilder #1 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace SqlCommandBuilderCS
          {
              class Program
              {
                  static void Main()
                  {
                      string cnnst = "";
                      string queryst = "";
                      string tablen = "";
                      DataSet ds = SelectSqlRows(cnnst, queryst, tablen);
                  }
          
                  public static DataSet SelectSqlRows(string connectionString, string queryString, string tableName)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          SqlDataAdapter adapter = new SqlDataAdapter();
                          adapter.SelectCommand = new SqlCommand(queryString, connection);
                          SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
          
                          connection.Open();
          
                          DataSet dataSet = new DataSet();
                          adapter.Fill(dataSet, tableName);
          
                          // code to modify data in DataSet here
          
                          builder.GetUpdateCommand();
          
                          // Without the SqlCommandBuilder this line would fail
                          adapter.Update(dataSet, tableName);
          
                          return dataSet;
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> class.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.#ctor(Microsoft.Data.SqlClient.SqlDataAdapter)">
            <param name="adapter">
        The name of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> class with the associated <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> object.
      </summary><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> registers itself as a listener for <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> events that are generated by the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> specified in this property.
        </para>
        <para>
          When you create a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />, any existing <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> associated with this <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is released.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommandBuilder.CatalogLocation">
            <summary>
        Sets or gets the <see cref="T:System.Data.Common.CatalogLocation" /> for an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> class.
      </summary><value>
        A <see cref="T:System.Data.Common.CatalogLocation" /> object.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommandBuilder.CatalogSeparator">
            <summary>
        Sets or gets a string used as the catalog separator for an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> class.
      </summary><value>
        A string that indicates the catalog separator for use with an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> class.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommandBuilder.DataAdapter">
            <summary>
        Gets or sets a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> object for which Transact-SQL statements are automatically generated.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> object.
      </value><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> registers itself as a listener for <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> events that are generated by the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> specified in this property.
        </para>
        <para>
          When you create a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />, any existing <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> associated with this <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is released.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.DeriveParameters(Microsoft.Data.SqlClient.SqlCommand)">
            <param name="command">
        The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> referencing the stored procedure from which the parameter information is to be derived. The derived parameters are added to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
      </param><summary>
        Retrieves parameter information from the stored procedure specified in the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and populates the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Parameters" /> collection of the specified <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
      </summary><remarks>
        <para>
          <c>DeriveParameters</c> overwrites any existing parameter information for the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
        </para>
        <para>
          <c>DeriveParameters</c> requires an additional call to the database to obtain the information. If the parameter information is known in advance, it is more efficient to populate the parameters collection by setting the information explicitly.
        </para>
        <para>
          You can only use <c>DeriveParameters</c> with stored procedures. You cannot use <c>DeriveParameters</c> with extended stored procedures. You cannot use <c>DeriveParameters</c> to populate the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> with arbitrary Transact-SQL statements, such as a parameterized SELECT statement.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/configure-parameters">Configuring parameters</see>.
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        The command text is not a valid stored procedure name.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommandBuilder.QuotePrefix">
            <summary>
        Gets or sets the starting character or characters to use when specifying SQL Server database objects, such as tables or columns, whose names contain characters such as spaces or reserved tokens.
      </summary><value>
        The starting character or characters to use. The default is an empty string.
      </value><remarks>
        <note type="note">
          Although you cannot change the <see cref="P:Microsoft.Data.SqlClient.SqlCommandBuilder.QuotePrefix" /> or <see cref="P:Microsoft.Data.SqlClient.SqlCommandBuilder.QuoteSuffix" /> properties after an insert, update, or delete command has been generated, you can change their settings after calling the <c>Update</c> method of a DataAdapter.
        </note>
      </remarks><exception cref="T:System.InvalidOperationException">
        This property cannot be changed after an INSERT, UPDATE, or DELETE command has been generated.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommandBuilder.QuoteSuffix">
            <summary>
        Gets or sets the ending character or characters to use when specifying SQL Server database objects, such as tables or columns, whose names contain characters such as spaces or reserved tokens.
      </summary><value>
        The ending character or characters to use. The default is an empty string.
      </value><remarks>
        <note type="note">
          Although you cannot change the <see cref="P:Microsoft.Data.SqlClient.SqlCommandBuilder.QuotePrefix" /> or <see cref="P:Microsoft.Data.SqlClient.SqlCommandBuilder.QuoteSuffix" /> properties after an insert, update, or delete operation has been generated, you can change their settings after calling the <c>Update</c> method of a DataAdapter.
        </note>
      </remarks><exception cref="T:System.InvalidOperationException">
        This property cannot be changed after an insert, update, or delete command has been generated.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCommandBuilder.SchemaSeparator">
            <summary>
        Gets or sets the character to be used for the separator between the schema identifier and any other identifiers.
      </summary><value>
        The character to be used as the schema separator.
      </value><remarks>
        <para>
          Generally, database servers indicate the schema for a identifier by separating the schema name from the identifier with some character. For example, SQL Server uses a period, creating complete identifiers such as Person.CustomerName, where "Person" is the schema name and "CustomerName" is the identifier. Setting this property lets developers modify this behavior.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.ApplyParameterInfo(System.Data.Common.DbParameter,System.Data.DataRow,System.Data.StatementType,System.Boolean)">
            <param name="parameter">
        To be added.
      </param><param name="datarow">
        To be added.
      </param><param name="statementType">
        To be added.
      </param><param name="whereClause">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand">
            <summary>
        Gets the automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object required to perform deletions on the database.
      </summary><returns>
        The automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object required to perform deletions.
      </returns><remarks>
        <para>
          An application can use the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> method for informational or troubleshooting purposes because it returns the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to be executed.
        </para>
        <para>
          You can also use <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> as the basis of a modified command. For example, you might call <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> and modify the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> value, and then explicitly set that on the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
        </para>
        <para>
          After the SQL statement is first generated, the application must explicitly call <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> if it changes the statement in any way. Otherwise, the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> will still be using information from the previous statement, which might not be correct. The SQL statements are first generated when the application calls either <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" />.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand(System.Boolean)">
            <param name="useColumnsForParameterNames">
        If <see langword="true" />, generate parameter names matching column names if possible. If <see langword="false" />, generate <c>@p1</c>, <c>@p2</c>, and so on.
      </param><summary>
        Gets the automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object that is required to perform deletions on the database.
      </summary><returns>
        The automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object that is required to perform deletions.
      </returns><remarks>
        <para>
          An application can use the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> method for informational or troubleshooting purposes because it returns the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to be executed.
        </para>
        <para>
          You can also use <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> as the basis of a modified command. For example, you might call <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> and modify the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> value, and then explicitly set that on the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
        </para>
        <para>
          After the SQL statement is first generated, the application must explicitly call <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> if it changes the statement in any way. Otherwise, the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" /> will still be using information from the previous statement, which might not be correct. The SQL statements are first generated when the application calls either <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" />.
        </para>
        <para>
          The default behavior, when generating parameter names, is to use <c>@p1</c>, <c>@p2</c>, and so on for the various parameters. Passing <see langword="true" /> for the <paramref name="useColumnsForParameterNames" /> parameter lets you force the command builder to generate parameters based on the column names instead. This succeeds only if the following conditions are met:
        </para>
        <list type="bullet">
          <item>
            The <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection has been specified and its length is equal to or greater than the generated parameter name.
          </item>
          <item>
            The generated parameter name meets the criteria specified in the <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection regular expression.
          </item>
          <item>
            A <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection is specified.
          </item>
        </list>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand">
            <summary>
        Gets the automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object required to perform insertions on the database.
      </summary><returns>
        The automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object required to perform insertions.
      </returns><remarks>
        <para>
          An application can use the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> method for informational or troubleshooting purposes because it returns the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to be executed.
        </para>
        <para>
          You can also use <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> as the basis of a modified command. For example, you might call <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> and modify the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> value, and then explicitly set that on the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
        </para>
        <para>
          After the Transact-SQL statement is first generated, the application must explicitly call <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> if it changes the statement in any way. Otherwise, the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> will still be using information from the previous statement, which might not be correct. The Transact-SQL statements are first generated when the application calls either <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" />.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand(System.Boolean)">
            <param name="useColumnsForParameterNames">
        If <see langword="true" />, generate parameter names matching column names if possible. If <see langword="false" />, generate <c>@p1</c>, <c>@p2</c>, and so on.
      </param><summary>
        Gets the automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object that is required to perform insertions on the database.
      </summary><returns>
        The automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object that is required to perform insertions.
      </returns><remarks>
        <para>
          An application can use the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> method for informational or troubleshooting purposes because it returns the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to be executed.
        </para>
        <para>
          You can also use <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> as the basis of a modified command. For example, you might call <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> and modify the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> value, and then explicitly set that on the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
        </para>
        <para>
          After the Transact-SQL statement is first generated, the application must explicitly call <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> if it changes the statement in any way. Otherwise, the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" /> will still be using information from the previous statement, which might not be correct. The Transact-SQL statements are first generated when the application calls either <see cref="M:System.Data.Common.DbDataAdapter.Update" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" />.
        </para>
        <para>
          The default behavior, when generating parameter names, is to use <c>@p1</c>, <c>@p2</c>, and so on for the various parameters. Passing <see langword="true" /> for the <paramref name="useColumnsForParameterNames" /> parameter lets you force the command builder to generate parameters based on the column names instead. This succeeds only if the following conditions are met:
        </para>
        <list type="bullet">
          <item>
            The <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection has been specified and its length is equal to or greater than the generated parameter name.
          </item>
          <item>
            The generated parameter name meets the criteria specified in the <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection regular expression.
          </item>
          <item>
            A <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection is specified.
          </item>
        </list>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetParameterName(System.Int32)">
            <param name="parameterOrdinal">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetParameterName(System.String)">
            <param name="parameterName">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetParameterPlaceholder(System.Int32)">
            <param name="parameterOrdinal">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetSchemaTable(System.Data.Common.DbCommand)">
            <param name="srcCommand">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand">
            <summary>
        Gets the automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object required to perform updates on the database.
      </summary><returns>
        The automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object that is required to perform updates.
      </returns><remarks>
        <para>
          An application can use the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> method for informational or troubleshooting purposes because it returns the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to be executed.
        </para>
        <para>
          You can also use <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> as the basis of a modified command. For example, you might call <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> and modify the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> value, and then explicitly set that on the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
        </para>
        <para>
          After the Transact-SQL statement is first generated, the application must explicitly call <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> if it changes the statement in any way. Otherwise, the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> will still be using information from the previous statement, which might not be correct. The Transact-SQL statements are first generated when the application calls either <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" />.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand(System.Boolean)">
            <param name="useColumnsForParameterNames">
        If <see langword="true" />, generate parameter names matching column names if possible. If <see langword="false" />, generate <c>@p1</c>, <c>@p2</c>, and so on.
      </param><summary>
        Gets the automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object required to perform updates on the database.
      </summary><returns>
        The automatically generated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object required to perform updates.
      </returns><remarks>
        <para>
          An application can use the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> method for informational or troubleshooting purposes because it returns the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to be executed.
        </para>
        <para>
          You can also use <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> as the basis of a modified command. For example, you might call <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> and modify the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> value, and then explicitly set that on the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
        </para>
        <para>
          After the Transact-SQL statement is first generated, the application must explicitly call <see cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema" /> if it changes the statement in any way. Otherwise, the <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" /> will still be using information from the previous statement, which might not be correct. The Transact-SQL statements are first generated when the application calls either <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> or <see cref="M:Microsoft.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" />.
        </para>
        <para>
          The default behavior, when generating parameter names, is to use <c>@p1</c>, <c>@p2</c>, and so on for the various parameters. Passing <see langword="true" /> for the <paramref name="useColumnsForParameterNames" /> parameter lets you force the command builder to generate parameters based on the column names instead. This succeeds only if the following conditions are met:
        </para>
        <list type="bullet">
          <item>
            The <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection has been specified and its length is equal to or greater than the generated parameter name.
          </item>
          <item>
            The generated parameter name meets the criteria specified in the <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection regular expression.
          </item>
          <item>
            A <see cref="F:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat" /> returned from the <b>GetSchema</b> method call and found in the <see cref="F:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation" /> collection is specified.
          </item>
        </list>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.InitializeCommand(System.Data.Common.DbCommand)">
            <param name="command">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.QuoteIdentifier(System.String)">
            <param name="unquotedIdentifier">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.SetRowUpdatingHandler(System.Data.Common.DbDataAdapter)">
            <param name="adapter">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCommandBuilder.UnquoteIdentifier(System.String)">
            <param name="quotedIdentifier">
        The identifier that will have its embedded quotes removed.
      </param><summary>
        Given a quoted identifier, returns the correct unquoted form of that identifier. This includes correctly unescaping any embedded quotes in the identifier.
      </summary><returns>
        The unquoted identifier, with embedded quotes properly unescaped.
      </returns><seealso href="https://learn.microsoft.com/sql/connect/ado-net/retrieving-modifying-data">
        Connecting and Retrieving Data in ADO.NET
      </seealso><seealso type="Article" href="https://learn.microsoft.com/sql/connect/ado-net/sql/">
        Using the .NET Framework Data Provider for SQL Server
      </seealso><seealso type="Article" href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConnection">
            <summary>
        Represents a connection to a SQL Server database. This class cannot be inherited.
      </summary><remarks>
        <para>
          A <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object represents a unique session to a SQL Server data source. With a client/server database system, it is equivalent to a network connection to the server. <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is used together with <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> to increase performance when connecting to a Microsoft SQL Server database. For all third-party SQL Server products and other OLE DB-supported data sources, use <see cref="T:System.Data.OleDb.OleDbConnection" />.
        </para>
        <para>
          When you create an instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, all properties are set to their initial values. For a list of these values, see the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> constructor.
        </para>
        <para>
          See <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> for a list of the keywords in a connection string.
        </para>
        <para>
          If the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> goes out of scope, it won't be closed. Therefore, you must explicitly close the connection by calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> or <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Dispose" />. <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> and <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Dispose" /> are functionally equivalent. If the connection pooling value <c>Pooling</c> is set to <c>true</c> or <c>yes</c>, the underlying connection is returned back to the connection pool. On the other hand, if <c>Pooling</c> is set to <c>false</c> or <c>no</c>, the underlying connection to the server is actually closed.
        </para>
        <note type="note">
          Login and logout events will not be raised on the server when a connection is fetched from or returned to the connection pool, because the connection is not actually closed when it is returned to the connection pool. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-connection-pooling">SQL Server Connection Pooling (ADO.NET)</see>.
        </note>
        <para>
          To ensure that connections are always closed, open the connection inside of a <c>using</c> block, as shown in the following code fragment. Doing so ensures that the connection is automatically closed when the code exits the block.
        </para>
        <code language="vb">
          Using connection As New SqlConnection(connectionString)
          connection.Open()
          ' Do work here; connection closed on following line.
          End Using
        </code>
        <code language="csharp">
          using (SqlConnection connection = new SqlConnection(connectionString))
          {
            connection.Open();
            // Do work here; connection closed on following line.
          }
        </code>
        <note type="note">
          To deploy high-performance applications, you must use connection pooling. When you use the .NET Framework Data Provider for SQL Server, you do not have to enable connection pooling because the provider manages this automatically, although you can modify some settings. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-connection-pooling">SQL Server Connection Pooling (ADO.NET)</see>.
        </note>
        <para>
          If a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. An application that creates an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object can require all direct and indirect callers to have sufficient permission to the code by setting declarative or imperative security demands. <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> makes security demands using the <see cref="T:Microsoft.Data.SqlClient.SqlClientPermission" /> object. Users can verify that their code has sufficient permissions by using the <see cref="T:Microsoft.Data.SqlClient.SqlClientPermissionAttribute" /> object. Users and administrators can also use the <see href="https://learn.microsoft.com/dotnet/framework/tools/caspol-exe-code-access-security-policy-tool">Caspol.exe (Code Access Security Policy Tool)</see> to modify security policy at the machine, user, and enterprise levels. For more information, see <see href="https://learn.microsoft.com/dotnet/standard/security/">Security in .NET</see>. For an example demonstrating how to use security demands, see <see href="https://learn.microsoft.com/dotnet/framework/data/adonet/code-access-security">Code Access Security and ADO.NET</see>.
          For more information about handling warning and informational messages from the server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-events">Connection Events</see>. For more information about SQL Server engine errors and error messages, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
        </para>  
        <note type="caution">
          You can force TCP instead of shared memory. You can do that by prefixing tcp: to the server name in the connection string or you can use localhost.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is opened and set as the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> for the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />. The example then calls <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" />. To accomplish this, the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" /> is passed a SqlConnection and a query string that is a Transact-SQL INSERT statement. The connection is closed automatically when the code exits the using block.
        </para>
        <!-- SqlCommand_ExecuteNonQuery -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace SqlCommandCS
          {
              class Program
              {
                  static void Main()
                  {
                      string str = "Data Source=(local);Initial Catalog=Northwind;"
                                 + "Integrated Security=SSPI";
                      string qs = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                      CreateCommand(qs, str);
                  }
                  private static void CreateCommand(string queryString, string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          SqlCommand command = new SqlCommand(queryString, connection);
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                  }
              }
          }
        </code>
      </example>
            <summary>
        Represents a connection to a SQL Server database. This class cannot be inherited.
      </summary><remarks>
        <para>
          A <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object represents a unique session to a SQL Server data source. With a client/server database system, it is equivalent to a network connection to the server. <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is used together with <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> to increase performance when connecting to a Microsoft SQL Server database. For all third-party SQL Server products and other OLE DB-supported data sources, use <see cref="T:System.Data.OleDb.OleDbConnection" />.
        </para>
        <para>
          When you create an instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, all properties are set to their initial values. For a list of these values, see the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> constructor.
        </para>
        <para>
          See <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> for a list of the keywords in a connection string.
        </para>
        <para>
          If the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> goes out of scope, it won't be closed. Therefore, you must explicitly close the connection by calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> or <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Dispose" />. <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> and <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Dispose" /> are functionally equivalent. If the connection pooling value <c>Pooling</c> is set to <c>true</c> or <c>yes</c>, the underlying connection is returned back to the connection pool. On the other hand, if <c>Pooling</c> is set to <c>false</c> or <c>no</c>, the underlying connection to the server is actually closed.
        </para>
        <note type="note">
          Login and logout events will not be raised on the server when a connection is fetched from or returned to the connection pool, because the connection is not actually closed when it is returned to the connection pool. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-connection-pooling">SQL Server Connection Pooling (ADO.NET)</see>.
        </note>
        <para>
          To ensure that connections are always closed, open the connection inside of a <c>using</c> block, as shown in the following code fragment. Doing so ensures that the connection is automatically closed when the code exits the block.
        </para>
        <code language="vb">
          Using connection As New SqlConnection(connectionString)
          connection.Open()
          ' Do work here; connection closed on following line.
          End Using
        </code>
        <code language="csharp">
          using (SqlConnection connection = new SqlConnection(connectionString))
          {
            connection.Open();
            // Do work here; connection closed on following line.
          }
        </code>
        <note type="note">
          To deploy high-performance applications, you must use connection pooling. When you use the .NET Framework Data Provider for SQL Server, you do not have to enable connection pooling because the provider manages this automatically, although you can modify some settings. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-connection-pooling">SQL Server Connection Pooling (ADO.NET)</see>.
        </note>
        <para>
          If a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. An application that creates an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object can require all direct and indirect callers to have sufficient permission to the code by setting declarative or imperative security demands. <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> makes security demands using the <see cref="T:Microsoft.Data.SqlClient.SqlClientPermission" /> object. Users can verify that their code has sufficient permissions by using the <see cref="T:Microsoft.Data.SqlClient.SqlClientPermissionAttribute" /> object. Users and administrators can also use the <see href="https://learn.microsoft.com/dotnet/framework/tools/caspol-exe-code-access-security-policy-tool">Caspol.exe (Code Access Security Policy Tool)</see> to modify security policy at the machine, user, and enterprise levels. For more information, see <see href="https://learn.microsoft.com/dotnet/standard/security/">Security in .NET</see>. For an example demonstrating how to use security demands, see <see href="https://learn.microsoft.com/dotnet/framework/data/adonet/code-access-security">Code Access Security and ADO.NET</see>.
          For more information about handling warning and informational messages from the server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-events">Connection Events</see>. For more information about SQL Server engine errors and error messages, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
        </para>  
        <note type="caution">
          You can force TCP instead of shared memory. You can do that by prefixing tcp: to the server name in the connection string or you can use localhost.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is opened and set as the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> for the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />. The example then calls <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" />. To accomplish this, the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" /> is passed a SqlConnection and a query string that is a Transact-SQL INSERT statement. The connection is closed automatically when the code exits the using block.
        </para>
        <!-- SqlCommand_ExecuteNonQuery -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace SqlCommandCS
          {
              class Program
              {
                  static void Main()
                  {
                      string str = "Data Source=(local);Initial Catalog=Northwind;"
                                 + "Integrated Security=SSPI";
                      string qs = "SELECT OrderID, CustomerID FROM dbo.Orders;";
                      CreateCommand(qs, str);
                  }
                  private static void CreateCommand(string queryString, string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          SqlCommand command = new SqlCommand(queryString, connection);
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> class.
      </summary><remarks>
        <para>
          When a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is created, the read/write properties are set to the following initial values unless they are specifically set using their associated keywords in the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property.
        </para>
        <list type="table">
          <listheader>
            <term>Properties</term>
            <description>Initial value</description>
          </listheader>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /></term>
            <description>empty string ("")</description>
          </item>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionTimeout" /></term>
            <description>15</description>
          </item>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.Database" /></term>
            <description>empty string ("")</description>
          </item>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.DataSource" /></term>
            <description>empty string ("")</description>
          </item>
        </list>
        <para>
          You can change the value for these properties only by using the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property. The <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class provides functionality for creating and managing the contents of connection strings.
        </para>
      </remarks><example>
        <para>
          The following example creates and opens a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />.
        </para>
        <!-- SqlConnection_SqlConnection -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  OpenSqlConnection();
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection()
              {
                  string connectionString = GetConnectionString();
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("State: {0}", connection.State);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationManager.ConnectionStrings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.#ctor(System.String)">
            <param name="connectionString">
        The connection used to open the SQL Server database.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> class when given a string that contains the connection string.
      </summary><remarks>
        <para>
          When a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is created, the read/write properties are set to the following initial values unless they are specifically set using their associated keywords in the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property.
        </para>
        <list type="table">
          <listheader>
            <term>Properties</term>
            <description>Initial value</description>
          </listheader>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /></term>
            <description><c>connectionString</c></description>
          </item>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionTimeout" /></term>
            <description>15</description>
          </item>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.Database" /></term>
            <description>empty string ("")</description>
          </item>
          <item>
            <term><see cref="P:Microsoft.Data.SqlClient.SqlConnection.DataSource" /></term>
            <description>empty string ("")</description>
          </item>
        </list>
        <para>
          You can change the value for these properties only by using the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property. The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> class provides functionality for creating and managing the contents of connection strings.
        </para>
      </remarks><example>
        <para>
          The following example creates and opens a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />.
        </para>
        <!-- SqlConnection_SqlConnection1 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  OpenSqlConnection();
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection()
              {
                  string connectionString = GetConnectionString();
          
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      Console.WriteLine("State: {0}", connection.State);
                      Console.WriteLine("ConnectionString: {0}",
                          connection.ConnectionString);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The supplied connection string argument failed <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> validation.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.#ctor(System.String,Microsoft.Data.SqlClient.SqlCredential)">
            <param name="connectionString">
        A connection string that does not use any of the following connection string keywords: <c>Integrated Security = true</c>, <c>UserId</c>, or <c>Password</c>; or that does not use <c>ConnectionContext = true</c>.
      </param><param name="credential">
        A <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object. If <paramref name="credential" /> is null, <see cref="M:Microsoft.Data.SqlClient.SqlConnection.#ctor(System.String,Microsoft.Data.SqlClient.SqlCredential)" /> is functionally equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlConnection.#ctor(System.String)" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> class given a connection string, that does not use <c>Integrated Security = true</c> and a <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object that contains the user ID and password.
      </summary><exception cref="T:System.ArgumentException">
        The supplied arguments failed validation, including <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> validation.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ColumnEncryptionKeyCacheTtl">
            <summary>
        Gets or sets the time-to-live for column encryption key entries in the column encryption key cache for the <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see> feature. The default value is 2 hours. 0 means no caching at all.
      </summary><value>
        The time interval.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ColumnEncryptionQueryMetadataCacheEnabled">
            <summary>
        Gets or sets a value that indicates whether query metadata caching is enabled (true) or not (false) for parameterized queries running against <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see> enabled databases. The default value is true.
      </summary><value>
        Returns true if query metadata caching is enabled; otherwise false. true is the default.
      </value><remarks>
        For parameterized queries, SqlClient makes a roundtrip to SQL Server for parameter metadata, to see which parameter it needs to encrypt and how (which keys and algorithms should be used). If the application calls the same query multiple times, an extra roundtrip is made to the server each time, which degrades application performance. With <b>ColumnEncryptionQueryMetadataCacheEnabled</b> set to true, if the same query is called multiple times, the roundtrip to the server will be made only once. The cache has a non-configurable Max size parameter that is set to 2000 queries.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths">
            <summary>
        Allows you to set a list of trusted key paths for a database server. If while processing an application query the driver receives a key path that is not on the list, the query will fail. This property provides additional protection against security attacks that involve a compromised SQL Server providing fake key paths, which may lead to leaking key store credentials.
      </summary><value>
        The list of trusted master key paths for the column encryption.
      </value>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})">
            <param name="customProviders">
        Dictionary of custom column encryption key store providers
      </param><summary>
        <para>
          Registers the column encryption key store providers. This function should only be called once in an app. This does shallow copying of the dictionary so that the app cannot alter the custom provider list once it has been set.
        </para>
        <para>
          The built-in column master key store providers that are available for the Windows Certificate Store, CNG Store and CSP are pre-registered.
        </para>
      </summary><example>
        <code language="c#">
          Dictionary&lt;string, SqlColumnEncryptionKeyStoreProvider&gt; customKeyStoreProviders = new Dictionary&lt;string, SqlColumnEncryptionKeyStoreProvider&gt;();
          MySqlClientHSMProvider myProvider = new MySqlClientHSMProvider();
          customKeyStoreProviders.Add(@"HSM Provider", myProvider);
          SqlConnection.RegisterColumnEncryptionKeyStoreProviders(customKeyStoreProviders);
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        <list type="bullet">
          <item>A null dictionary was provided.</item>
          <item>A string key in the dictionary was null or empty.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider" /> value in the dictionary was null.</item>
        </list>
      </exception><exception cref="T:System.ArgumentException">
        A string key in the dictionary started with "MSSQL_". This prefix is reserved for system providers.
      </exception><exception cref="T:System.InvalidOperationException">
        This function was called more than once.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProvidersOnConnection(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})">
            <param name="customProviders">
        Dictionary of custom column encryption key providers
      </param><summary>
        Registers the encryption key store providers on the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance. If this function has been called, any providers registered using the static <see cref="M:Microsoft.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" /> methods will be ignored. This function can be called more than once. This does shallow copying of the dictionary so that the app cannot alter the custom provider list once it has been set.
      </summary><remarks>
        <para>
          Custom master key store providers can be registered with the driver at three different layers. The precedence of the three registrations is as follows:
        </para>
        <list type="bullet">
          <item>
            The per-command registration will be checked if it is not empty.
          </item>
          <item>
            If the per-command registration is empty, the per-connection registration will be checked if it is not empty.
          </item>
          <item>
            If the per-connection registration is empty, the global registration will be checked.
          </item>
        </list>
        <para>
          Once any key store provider is found at a registration level, the driver will <b>NOT</b> fall back to the other registrations to search for a provider. If providers are registered but the proper provider is not found at a level, an exception will be thrown containing only the registered providers in the registration that was checked.
        </para>
        <para>
          The built-in column master key store providers that are available for the Windows Certificate Store, CNG Store and CSP are pre-registered.
        </para>
        <para>
          This does shallow copying of the dictionary so that the app cannot alter the custom provider list once it has been set.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        <list type="bullet">
          <item>A null dictionary was provided.</item>
          <item>A string key in the dictionary was null or empty.</item>
          <item>A <see cref="T:Microsoft.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider" /> value in the dictionary was null.</item>
        </list>
      </exception><exception cref="T:System.ArgumentException">
        A string key in the dictionary started with "MSSQL_". This prefix is reserved for system providers.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.AccessToken">
            <summary>
        Gets or sets the access token for the connection.
      </summary><value>
        The access token for the connection.
      </value><remarks>
        The AccessToken is a part of the connection pool key. Care should be taken when using this property to manage your own access token. The application is responsible for knowing when the token expires and connections from the pool should no longer be used. If you set a minimum pool size &gt; 0 along with AccessToken, you must call <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ClearPool(Microsoft.Data.SqlClient.SqlConnection)" /> after the access token expires to ensure the connection pool doesn't maintain those connections indefinitely.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ClientConnectionId">
            <summary>
        The connection ID of the most recent connection attempt, regardless of whether the attempt succeeded or failed.
      </summary><value>
        The connection ID of the most recent connection attempt.
      </value><remarks>
        <para>
          <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ClientConnectionId" /> works regardless of which version of the server you connect to, but extended events logs and entry on connectivity ring buffer errors will not be present in SQL Server 2008 R2 and earlier.
        </para>
        <para>
          You can locate the connection ID in the extended events log to see if the failure was on the server if the extended event for logging connection ID is enabled. You can also locate the connection ID in the connection ring buffer (<see href="https://techcommunity.microsoft.com/t5/sql-server-blog/connectivity-troubleshooting-in-sql-server-2008-with-the/ba-p/383393">Connectivity troubleshooting in SQL Server 2008 with the Connectivity Ring Buffer</see>) for certain connection errors. If the connection ID is not in the connection ring buffer, you can assume a network error.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.AccessTokenCallback">
            <summary>
        Gets or sets the access token callback for the connection.
      </summary><value>
        The Func that takes a <see cref="T:SqlAuthenticationParameters" /> and <see cref="T:System.Threading.CancellationToken" /> and returns a <see cref="T:Microsoft.Data.SqlClient.SqlAuthenticationToken" />.
      </value><example>
        <para>
          The following example demonstrates how to define and set an <see cref="P:Microsoft.Data.SqlClient.SqlConnection.AccessTokenCallback" />.
        </para>
        <!-- SqlConnection_AccessTokenCallback -->
        <code language="c#">
          using System;
          using System.Collections.Concurrent;
          using System.Threading;
          using System.Threading.Tasks;
          using Azure.Core;
          using Azure.Identity;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  OpenSqlConnection();
                  Console.ReadLine();
              }

              const string defaultScopeSuffix = "/.default";

              // Reuse credential objects to take advantage of underlying token caches
              private static ConcurrentDictionar&lt;string, DefaultAzureCredential&gt; credentials = new ConcurrentDictionary&lt;string, DefaultAzureCredential&gt;();

              // Use a shared callback function for connections that should be in the same connection pool
              private static Func&lt;SqlAuthenticationParameters, CancellationToken, Task&lt;SqlAuthenticationToken&gt;&gt; myAccessTokenCallback =
                  async (authParams, cancellationToken) =&gt;
                  {
                      string scope = authParams.Resource.EndsWith(defaultScopeSuffix)
                          ? authParams.Resource
                          : $"{authParams.Resource}{defaultScopeSuffix}";

                      DefaultAzureCredentialOptions options = new DefaultAzureCredentialOptions();
                      options.ManagedIdentityClientId = authParams.UserId;

                      // Reuse the same credential object if we are using the same MI Client ID
                      AccessToken token = await credentials.GetOrAdd(authParams.UserId, new DefaultAzureCredential(options)).GetTokenAsync(
                          new TokenRequestContext(new string[] { scope }),
                          cancellationToken);

                      return new SqlAuthenticationToken(token.Token, token.ExpiresOn);
                  };

              private static void OpenSqlConnection()
              {
                  // (Optional) Pass a User-Assigned Managed Identity Client ID.
                  // This will ensure different MI Client IDs are in different connection pools.
                  string connectionString = "Server=myServer.database.windows.net;Encrypt=Mandatory;UserId=&lt;ManagedIdentityClientId&gt;;";

                  using (SqlConnection connection = new SqlConnection(connectionString)
                  {
                      // The callback function is part of the connection pool key. Using a static callback function
                      // ensures connections will not create a new pool per connection just for the callback.
                      AccessTokenCallback = myAccessTokenCallback
                  })
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("State: {0}", connection.State);
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        The <see cref="P:Microsoft.Data.SqlClient.SqlConnection.AccessTokenCallback" /> is combined with other conflicting authentication configurations.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.SQLDNSCachingSupportedState">
            
             for internal test only
            
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.SQLDNSCachingSupportedStateBeforeRedirect">
            
             for internal test only
            
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.System#ICloneable#Clone">
            <summary>
        Creates a new object that is a copy of the current instance.
      </summary><returns>
        A new object that is a copy of this instance.
      </returns><remarks>
        <para>
          This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance is cast to an <see cref="T:System.ICloneable" /> interface.
        </para>
        <para>
          This member is only supported by the .NET Compact Framework.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.CommandTimeout">
            <summary>
        Gets the default wait time (in seconds) before terminating the attempt to execute a command and generating an error. The default is 30 seconds.
      </summary><value>
        The time in seconds to wait for the command to execute. The default is 30 seconds.
      </value><remarks>
        You can set the default wait time by using the <c>Command Timeout</c> keyword in the connection string. A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString">
            <summary>
        Gets or sets the string used to open a SQL Server database.
      </summary><value>
        The connection string that includes the source database name, and other parameters needed to establish the initial connection. The default value is an empty string.
      </value><remarks>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> is similar to an OLE DB connection string, but is not identical. Unlike OLE DB or ADO, the connection string that is returned is the same as the user-set <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />, minus security information if the Persist Security Info value is set to <c>false</c> (default). The .NET Framework Data Provider for SQL Server does not persist or return the password in a connection string unless you set Persist Security Info to <c>true</c>. You can use the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property to connect to a database. The following example illustrates a typical connection string.
        </para>
        <code>
          "Persist Security Info=False;Integrated Security=true;Initial Catalog=Northwind;server=(local)"
        </code>
        <para>
          Use the new <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> to construct valid connection strings at run time. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-string-builders">Connection String Builders</see>. The <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property can be set only when the connection is closed. Many of the connection string values have corresponding read-only properties. When the connection string is set, these properties are updated, except when an error is detected. In this case, none of the properties are updated. <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> properties return only those settings that are contained in the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />. To connect to a local computer, specify "(local)" for the server. If a server name is not specified, a connection will be attempted to the default instance on the local computer. Resetting the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> on a closed connection resets all connection string values (and related properties) including the password. For example, if you set a connection string that includes "Database= AdventureWorks", and then reset the connection string to <c>Data Source=myserver;Integrated Security=true</c>, the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Database" /> property is no longer set to "AdventureWorks". The connection string is parsed immediately after being set. If errors in syntax are found when parsing, a runtime exception, such as <see cref="T:System.ArgumentException" />, is generated. Other errors can be found only when an attempt is made to open the connection. The basic format of a connection string includes a series of keyword/value pairs separated by semicolons. The equal sign (=) connects each keyword and its value. To include values that contain a semicolon, single-quote character, or double-quote character, the value must be enclosed in double quotation marks. If the value contains both a semicolon and a double-quote character, the value can be enclosed in single quotation marks. The single quotation mark is also useful if the value starts with a double-quote character. Conversely, the double quotation mark can be used if the value starts with a single quotation mark. If the value contains both single-quote and double-quote characters, the quotation mark character used to enclose the value must be doubled every time it occurs within the value. To include preceding or trailing spaces in the string value, the value must be enclosed in either single quotation marks or double quotation marks. Any leading or trailing spaces around integer, Boolean, or enumerated values are ignored, even if enclosed in quotation marks. However, spaces within a string literal keyword or value are preserved. Single or double quotation marks may be used within a connection string without using delimiters (for example, Data Source= my'Server or Data Source= my"Server), unless a quotation mark character is the first or last character in the value. Keywords are not case-sensitive. The following table lists the valid names for keyword values within the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />.
        </para>
        <list type="table">
          <listheader>
            <term>Keyword</term>
            <description>Default</description>
            <description>Description</description>
          </listheader>
          <item>
            <term>Addr</term>
            <description>N/A</description>
            <description>Synonym of <b>Data Source</b>.</description>
          </item>
          <item>
            <term>Address</term>
            <description>N/A</description>
            <description>Synonym of <b>Data Source</b>.</description>
          </item>
          <item>
            <term>App</term>
            <description>N/A</description>
            <description>Synonym of <b>Application Name</b>.</description>
          </item>
          <item>
            <term>
              <b>Application Intent</b> or <b>ApplicationIntent</b>
            </term>
            <description>ReadWrite</description>
            <description>
              <para>
                Declares the application workload type when connecting to a server. Possible values are <c>ReadOnly</c> and <c>ReadWrite</c>. For example: <c>ApplicationIntent=ReadOnly</c>
              </para>
              <para>
                For more information about SqlClient support for Always On Availability Groups, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/sqlclient-support-high-availability-disaster-recovery">SqlClient Support for High Availability, Disaster Recovery</see>.
              </para>
            </description>
          </item>
          <item>
            <term>Application Name</term>
            <description>N/A</description>
            <description>
              <para>
                The name of the application. If no application name is provided, 'Framework Microsoft SqlClient Data Provider' when running on .NET Framework and 'Core Microsoft SqlClient Data Provider' otherwise.
              </para>
              <para>
                An application name can be 128 characters or fewer.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>AttachDBFilename</b> or <b>Extended Properties</b> or <b>Initial File Name</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                The name of the primary database file, including the full path name of an attachable database. AttachDBFilename is only supported for primary data files with an .mdf extension.
              </para>
              <para>
                If the value of the AttachDBFileName key is specified in the connection string, the database is attached and becomes the default database for the connection.
              </para>
              <para>
                If this key is not specified and if the database was previously attached, the database will not be reattached. The previously attached database will be used as the default database for the connection.
              </para>
              <para>
                If this key is specified together with the AttachDBFileName key, the value of this key will be used as the alias. However, if the name is already used in another attached database, the connection will fail.
              </para>
              <para>
                The path may be absolute or relative by using the DataDirectory substitution string. If DataDirectory is used, the database file must exist within a subdirectory of the directory pointed to by the substitution string. <b>Note:</b> Remote server, HTTP, and UNC path names are not supported.
              </para>
              <para>
                The database name must be specified with the keyword 'database' (or one of its aliases) as in the following:
              </para>
              <code>
                AttachDbFileName=|DataDirectory|\data\YourDB.mdf;integrated security=true;database=YourDatabase
              </code>
              <para>
                An error will be generated if a log file exists in the same directory as the data file and the 'database' keyword is used when attaching the primary data file. In this case, remove the log file. Once the database is attached, a new log file will be automatically generated based on the physical path.
              </para>
            </description>
          </item>
          <item>
            <term>Attestation Protocol</term>
            <description>NotSpecified</description>
            <description>
              <para>
                Gets or sets the value of Attestation Protocol.
              </para>
              <para>
                When no value is specified, secure enclaves are disabled on the connection.
              </para>
              <para>
                Valid values are:
              </para>
              <list type="bullet">
                <item><c>AAS</c></item>
                <item><c>HGS</c></item>
                <item><c>None</c> (Only valid in v3.1 and v4.1+)</item>
              </list>
            </description>
          </item>
          <item>
            <term>Authentication</term>
            <description>N/A</description>
            <description>
              <para>
                The authentication method used for <see href="https://learn.microsoft.com/azure/azure-sql/database/authentication-aad-overview#connect-with-microsoft-entra-to-azure-sql-resources">Connect with Microsoft Entra to Azure SQL resources</see>.
              </para>
              <para>
                Valid values are:
              </para>
              <list type="bullet">
                <item><c>Active Directory Integrated</c></item>
                <item><c>Active Directory Interactive</c></item>
                <item><c>Active Directory Password</c></item>
                <item><c>Active Directory Service Principal</c></item>
                <item><c>Active Directory Device Code Flow</c></item>
                <item><c>Active Directory Managed Identity</c></item>
                <item><c>Active Directory MSI</c></item>
                <item><c>Active Directory Default</c></item>
                <item><c>Sql Password</c></item>
              </list>
              <para>
                For additional information see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/azure-active-directory-authentication">Using Azure Active Directory authentication with SqlClient</see>.
              </para>
            </description>
          </item>
          <item>
            <term>Column Encryption Setting</term>
            <description>disabled</description>
            <description>
              Enables or disables <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see> functionality for the connection. Supported values are: <c>enabled</c> and <c>disabled</c>
            </description>
          </item>
          <item>
            <term>Command Timeout</term>
            <description>30</description>
            <description>
              <para>
                The default wait time (in seconds) before terminating the attempt to execute a command and generating an error.
              </para>
              <para>
                Valid values are greater than or equal to 0 and less than or equal to 2147483647.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Connect Retry Count</b> or <b>ConnectRetryCount</b>
            </term>
            <description>1</description>
            <description>
              <para>
                Controls the number of reconnection attempts after the client identifies an idle connection failure. Valid values are 0 to 255. 0 means do not attempt to reconnect (disable connection resiliency).
              </para>
              <para>
                <b>Note:</b> Since version 5.x the default value for non Azure endpoints is 1. For Azure SQL endpoints, the default is 2. For Azure SQL serverless or on demand endpoints, the default is 5 to improve connection success for connections to an idle or paused instance.
              </para>
              <para>
                For additional information about idle connection resiliency, see <see href="https://learn.microsoft.com/azure/azure-sql/database/troubleshoot-common-connectivity-issues?view=azuresql#net-sqlconnection-parameters-for-connection-retry">.NET SqlConnection parameters for connection retry</see> and <see href="https://go.microsoft.com/fwlink/?LinkId=393996">Technical Article - Idle Connection Resiliency</see>.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Connect Retry Interval</b> or <b>ConnectRetryInterval</b>
            </term>
            <description>10</description>
            <description>
              <para>
                Specifies the time between each connection retry attempt (<c>ConnectRetryCount</c>). Valid values are 1 to 60 seconds (default=10), applied after the first reconnection attempt. When a broken connection is detected, the client immediately attempts to reconnect; this is the first reconnection attempt and only occurs if <c>ConnectRetryCount</c> is greater than 0. If the first reconnection attempt fails and <c>ConnectRetryCount</c> is greater than 1, the client waits <c>ConnectRetryInterval</c> to try the second and subsequent reconnection attempts.
              </para>
              <para>
                For additional information about idle connection resiliency, see <see href="https://learn.microsoft.com/azure/azure-sql/database/troubleshoot-common-connectivity-issues?view=azuresql#net-sqlconnection-parameters-for-connection-retry">.NET SqlConnection parameters for connection retry</see> and <see href="https://go.microsoft.com/fwlink/?LinkId=393996">Technical Article - Idle Connection Resiliency</see>.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Connect Timeout</b> or <b>Connection Timeout</b> or <b>Timeout</b>
            </term>
            <description>15</description>
            <description>
              <para>
                The length of time (in seconds) to wait for a connection to the server before terminating the attempt and generating an error.
              </para>
              <para>
                Valid values are greater than or equal to 0 and less than or equal to 2147483647.
              </para>
              <para>
                When opening a connection to a Azure SQL Database, set the connection timeout to 30 seconds.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Current Language</b> or <b>Language</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                Sets the language used for database server warning or error messages.
              </para>
              <para>
                The language name can be 128 characters or fewer.
              </para> 
            </description>
          </item>
          <item>
            <term>
              <b>Data Source</b> or <b>Server</b> or <b>Address</b> or <b>Addr</b> or <b>Network Address</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                The name or network address of the instance of SQL Server to which to connect. The port number can be specified after the server name: <c>server=tcp:servername, portnumber</c>
              </para>
              <para>
                When specifying a local instance, always use (local). To force a protocol, add one of the following prefixes: <c>np:(local), tcp:(local), lpc:(local)</c>
              </para>
              <para>
                You can also connect to a LocalDB database as follows: <c>server=(localdb)\\myInstance</c>
              </para>
              <para>
                For more information about LocalDB, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/sqlclient-support-localdb">SqlClient Support for LocalDB</see>.
              </para>
              <para>
                <b>Data Source</b> must use the TCP format or the Named Pipes format.
              </para>
              <para>
                TCP format is as follows:
              </para>
              <list type="bullet">
                <item><c>tcp:\&lt;host name&gt;\\&lt;instance name&gt;\</c></item>
                <item><c>tcp:\&lt;host name&gt;,\&lt;TCP/IP port number&gt;</c></item>
              </list>
              <para>
                The TCP format must start with the prefix "tcp:" and is followed by the database instance, as specified by a host name and an instance name. This format is not applicable when connecting to Azure SQL Database. TCP is automatically selected for connections to Azure SQL Database when no protocol is specified.
              </para>
              <para>
                The host name MUST be specified in one of the following ways:
              </para>
              <list type="bullet">
                <item>NetBIOSName</item>
                <item>IPv4Address</item>
                <item>IPv6Address</item>
              </list>
              <para>
                The instance name is used to resolve to a particular TCP/IP port number on which a database instance is hosted. Alternatively, specifying a TCP/IP port number directly is also allowed. If both instance name and port number are not present, the default database instance is used.
              </para>
              <para>
                The Named Pipes format is as follows:
              </para>
              <list type="bullet">
                <item>np:\\\\&lt;host name&gt;\pipe\\&lt;pipe name&gt;</item>
              </list>
              <para>
                The Named Pipes format MUST start with the prefix "np:" and is followed by a named pipe name. <br /><br />
                The host name MUST be specified in one of the following ways:
              </para>
              <list type="bullet">
                <item>NetBIOSName</item>
                <item>IPv4Address</item>
                <item>IPv6Address</item>
              </list>
              <para>
                The pipe name is used to identify the database instance to which the .NET application will connect.
              </para>
              <para>
                If the value of the <b>Network</b> key is specified, the prefixes "tcp:" and "np:" should not be specified. <b>Note:</b> You can force the use of TCP instead of shared memory, either by prefixing <b>tcp:</b> to the server name in the connection string, or by using <b>localhost</b>.
              </para>
            </description>
          </item>
          <item>
            <term>Enclave Attestation Url</term>
            <description>N/A</description>
            <description>Gets or sets the enclave attestation URL to be used with enclave based Always Encrypted.</description>
          </item>
          <item>
            <term>Encrypt</term>
            <description>
              <c>true</c> in 4.0 and above <br /><br />
              <c>false</c> in 3.x and below
            </description>
            <description>
              <para>
                Recognized values are:
              </para>
              <list type="bullet">
                <item>
                  versions 1 - 4: <c>true</c> / <c>yes</c> and <c>false</c> / <c>no</c>
                </item>
                <item>
                  versions 5+: <c>true</c> / <c>yes</c> / <c>mandatory</c>, <c>false</c> / <c>no</c> / <c>optional</c> and <c>strict</c>. When <c>true</c>, TLS encryption is used for all data sent between the client and server if the server has a certificate installed. When <c>strict</c>, TDS 8.0 TLS encryption is used and the <c>TrustServerCertificate</c> setting is ignored and treated as false. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-string-syntax">Connection String Syntax</see>.
                </item>
              </list>
              <para>
                When <c>Encrypt</c> is <c>mandatory</c> or <c>strict</c> and <c>TrustServerCertificate</c> is <c>false</c>, the server name (or IP address) in a server's certificate must exactly match the server name (or IP address) specified in the connection string. Otherwise, the connection attempt will fail.
              </para>
            </description>
          </item>
          <item>
            <term>Enlist</term>
            <description>'true'</description>
            <description>
              <c>true</c> indicates that the SQL Server connection pooler automatically enlists the connection in the creation thread's current transaction context.
            </description>
          </item>
          <item>
            <term>Failover Partner</term>
            <description>N/A</description>
            <description>
              <para>
                The name of the failover partner server where database mirroring is configured.
              </para>
              <para>
                If the value of this key is "", then <b>Initial Catalog</b> must be present, and its value must not be "".
              </para>
              <para>
                The server name can be 128 characters or fewer.
              </para>
              <para>
                If you specify a failover partner but the failover partner server is not configured for database mirroring and the primary server (specified with the Server keyword) is not available, then the connection will fail.
              </para>
              <para>
                If you specify a failover partner and the primary server is not configured for database mirroring, the connection to the primary server (specified with the Server keyword) will succeed if the primary server is available.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Failover Partner SPN</b> or <b>FailoverPartnerSPN</b>
            </term>
            <description>N/A</description>
            <description>
              The SPN for the failover partner. The default value is an empty string, which causes SqlClient to use the default, driver-generated SPN. (Only available in v5.0+)
            </description>
          </item>
          <item>
            <term>
              <b>Host Name In Certificate</b> or <b>HostNameInCertificate</b>
            </term>
            <description>N/A</description>
            <description>
              The host name to use when validating the server certificate. When not specified, the server name from the Data Source is used for certificate validation. (Only available in v5.0+)
            </description>
          </item>
          <item>
            <term>
              <b>Server Certificate</b> or <b>ServerCertificate</b>
            </term>
            <description>N/A</description>
            <description>
              The path to a certificate file to match against the SQL Server TLS/SSL certificate. The accepted certificate formats are PEM, DER, and CER. If specified, the SQL Server certificate is checked by verifying if the ServerCertificate provided is an exact match. (Only available in v5.1+)
            </description>
          </item>
          <item>
            <term>
              <b>Initial Catalog</b> or <b>Database</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                The name of the database.
              </para>
              <para>
                The database name can be 128 characters or fewer.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Integrated Security</b> or <b>Trusted_Connection</b>
            </term>
            <description><c>false</c></description>
            <description>
              <para>
                When <c>false</c>, User ID and Password are specified in the connection. When <c>true</c>, the current Windows account credentials are used for authentication.
              </para>
              <para>
                Recognized values are <c>true</c>, <c>false</c>, <c>yes</c>, <c>no</c>, and <c>sspi</c> (strongly recommended), which is equivalent to <c>true</c>.
              </para>
              <para>
                If User ID and Password are specified and Integrated Security is set to true, the User ID and Password will be ignored and Integrated Security will be used.
              </para>
              <para>
                <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> is a more secure way to specify credentials for a connection that uses SQL Server Authentication (<c>Integrated Security=false</c>).
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>IP Address Preference</b> or <b>IPAddressPreference</b>
            </term>
            <description><c>IPv4First</c></description>
            <description>
              <para>
                The IP address family preference when establishing TCP connections. If <c>Transparent Network IP Resolution</c> (in .NET Framework) or <c>Multi Subnet Failover</c> is set to true, this setting has no effect. Supported values include:
              </para>
              <list type="bullet">
                <item><c>IPAddressPreference=IPv4First</c></item>
                <item><c>IPAddressPreference=IPv6First</c></item>
                <item><c>IPAddressPreference=UsePlatformDefault</c></item>
              </list>
            </description>
          </item>
          <item>
            <term>
              <b>Load Balance Timeout</b> or <b>Connection Lifetime</b>
            </term>
            <description>0</description>
            <description>
              <para>
                When a connection is returned to the pool, its creation time is compared with the current time, and the connection is destroyed if that time span (in seconds) exceeds the value specified by <c>Connection Lifetime</c>. This is useful in clustered configurations to force load balancing between a running server and a server just brought online.
              </para>
              <para>
                A value of zero (0) causes pooled connections to have the maximum connection timeout.
              </para>
            </description>
          </item>
          <item>
            <term>Max Pool Size</term>
            <description>100</description>
            <description>
              <para>
                The maximum number of connections that are allowed in the pool.
              </para>
              <para>
                Valid values are greater than or equal to 1. Values that are less than <b>Min Pool Size</b> generate an error.
              </para>
            </description>
          </item>
          <item>
            <term>Min Pool Size</term>
            <description>0</description>
            <description>
              <para>
                The minimum number of connections that are allowed in the pool.
              </para>
              <para>
                Valid values are greater than or equal to 0. Zero (0) in this field means no minimum connections are initially opened.
              </para>
              <para>
                Values that are greater than <b>Max Pool Size</b> generate an error.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Multiple Active Result Sets</b> or <b>MultipleActiveResultSets</b>
            </term>
            <description>false</description>
            <description>
              <para>
                When <c>true</c>, an application can maintain multiple active result sets (MARS). When <c>false</c>, an application must process or cancel all result sets from one batch before it can execute any other batch on that connection.
              </para>
              <para>
                Recognized values are <c>true</c> and <c>false</c>.
              </para>
              <para>
                For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/multiple-active-result-sets-mars">Multiple Active Result Sets (MARS)</see>.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Multi Subnet Failover</b> or <b>MultiSubnetFailover</b>
            </term>
            <description>false</description>
            <description>
              <para>
                Always specify <c>multiSubnetFailover=True</c> when connecting to the availability group listener of a SQL Server 2012 (or later) availability group or a SQL Server 2012 (or later) Failover Cluster Instance. <c>multiSubnetFailover=True</c> configures SqlClient to provide faster detection of and connection to the (currently) active server. Possible values are <c>Yes</c> and <c>No</c>, <c>True</c> and <c>False</c> or <c>1</c> and <c>0</c>. For example:
              </para>
              <para>
                <c>MultiSubnetFailover=True</c>
              </para>
              <para>
                The default is <c>False</c>. For more information about SqlClient's support for Always On AGs, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/sqlclient-support-high-availability-disaster-recovery">SqlClient Support for High Availability, Disaster Recovery</see>.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Network Library</b> or <b>Network</b> or <b>Net</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                The network library used to establish a connection to an instance of SQL Server. Supported values include:
              </para>
              <list type="bullet">
                <item>dbnmpntw (Named Pipes)</item>
                <item>dbmsrpcn (Multiprotocol, Windows RPC)</item>
                <item>dbmsadsn (Apple Talk)</item>
                <item>dbmsgnet (VIA)</item>
                <item>dbmslpcn (Shared Memory)</item>
                <item>dbmsspxn (IPX/SPX)</item>
                <item>dbmssocn (TCP/IP)</item>
                <item>Dbmsvinn (Banyan Vines)</item>
              </list>
              <para>
                The corresponding network DLL must be installed on the system to which you connect. If you do not specify a network and you use a local server (for example, "." or "(local)"), shared memory is used. In this example, the network library is Win32 Winsock TCP/IP (dbmssocn), and 1433 is the port being used.
              </para>
              <para>
                <c>Network Library=dbmssocn;Data Source=000.000.000.000,1433;</c>
              </para>
            </description>
          </item>
          <item>
            <term>Packet Size</term>
            <description>8000</description>
            <description>
              <para>
                Size in bytes of the network packets used to communicate with an instance of SQL Server.
              </para>
              <para>
                The packet size can be greater than or equal to 512 and less than or equal to 32768.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Password</b> or <b>PWD</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                The password for the SQL Server account logging on. Not recommended. To maintain a high level of security, we strongly recommend that you use the <c>Integrated Security</c> or <c>Trusted_Connection</c> keyword instead. <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> is a more secure way to specify credentials for a connection that uses SQL Server Authentication.
              </para>
              <para>
                The password must be 128 characters or fewer.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Persist Security Info</b> or <b>PersistSecurityInfo</b>
            </term>
            <description><c>false</c></description>
            <description>
              <para>
                When set to <c>false</c> or <c>no</c> (strongly recommended), security-sensitive information, such as the password or access token, is not returned as part of the connection if the connection is open or has ever been in an open state. This property should only be set to <c>true</c> if your application has a specific need to read the password out of an already-opened database connection. The default value of <c>false</c> is the more secure setting; using <c>true</c> for this property opens your application to security risks such as accidentally logging or tracing the database password.
              </para>
              <para>
                Resetting the connection string resets all connection string values including the password. 
              </para>
              <para>
                Recognized values are <c>true</c>, <c>false</c>, <c>yes</c>, and <c>no</c>.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Pool Blocking Period</b> or <b>PoolBlockingPeriod</b>
            </term>
            <description>Auto</description>
            <description>
              Sets the blocking period behavior for a connection pool. See <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.PoolBlockingPeriod" /> property for details.
            </description>
          </item>
          <item>
            <term>Pooling</term>
            <description><c>true</c></description>
            <description>
              <para>
                When the value of this key is set to true, any newly created connection will be added to the pool when closed by the application. In a next attempt to open the same connection, that connection will be drawn from the pool.
              </para>
              <para>
                Connections are considered the same if they have the same connection string. Different connections have different connection strings.
              </para>
              <para>
                The value of this key can be <c>true</c>, <c>false</c>, <c>yes</c>, and <c>no</c>.
              </para>
            </description>
          </item>
          <item>
            <term>Replication</term>
            <description><c>false</c></description>
            <description><c>true</c> if replication is supported using the connection.</description>
          </item>
          <item>
            <term>
              <b>Server SPN</b> or <b>ServerSPN</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                The SPN for the data source. The default value is an empty string, which causes SqlClient to use the default, driver-generated SPN. (Only available in v5.0+)
              </para>
            </description>
          </item>
          <item>
            <term>Transaction Binding</term>
            <description>Implicit Unbind</description>
            <description>
              <para>
                Controls connection association with an enlisted <c>System.Transactions</c> transaction.
              </para>
              <para>
                Possible values are:
              </para>
              <list type="bullet">
                <item><c>Transaction Binding=Implicit Unbind;</c></item>
                <item><c>Transaction Binding=Explicit Unbind;</c></item>
              </list>
              <para>
                Implicit Unbind causes the connection to detach from the transaction when it ends. After detaching, additional requests on the connection are performed in autocommit mode. The <c>System.Transactions.Transaction.Current</c> property is not checked when executing requests while the transaction is active. After the transaction has ended, additional requests are performed in autocommit mode.
              </para>
              <para>
                If the system ends the transaction (in the scope of a using block) before the last command completes, it will throw <see cref="T:System.InvalidOperationException" />.
              </para>
              <para>
                Explicit Unbind causes the connection to remain attached to the transaction until the connection is closed or an explicit <c>SqlConnection.TransactionEnlist(null)</c> is called. Beginning in .NET Framework 4.0, changes to Implicit Unbind make Explicit Unbind obsolete. An <c>InvalidOperationException</c> is thrown if <c>Transaction.Current</c> is not the enlisted transaction or if the enlisted transaction is not active.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>Transparent Network IP Resolution</b> or <b>TransparentNetworkIPResolution</b>
            </term>
            <description>See description.</description>
            <description>
              <para>
                When the value of this key is set to <c>true</c>, the application is required to retrieve all IP addresses for a particular DNS entry and attempt to connect with the first one in the list. If the connection is not established within 0.5 seconds, the application will try to connect to all others in parallel. When the first answers, the application will establish the connection with the respondent IP address.
              </para>
              <para>
                If the <c>MultiSubnetFailover</c> key is set to <c>true</c>, <c>TransparentNetworkIPResolution</c> is ignored.
              </para>
              <para>
                If the <c>Failover Partner</c> key is set, <c>TransparentNetworkIPResolution</c> is ignored.
              </para>
              <para>
                The value of this key must be <c>true</c>, <c>false</c>, <c>yes</c>, or <c>no</c>.
              </para>
              <para>
                A value of <c>yes</c> is treated the same as a value of <c>true</c>.
              </para>
              <para>
                A value of <c>no</c> is treated the same as a value of <c>false</c>.
              </para>
              <para>
                The default values are as follows:
              </para>
              <list type="bullet">
                <item>
                  <c>false</c> when:
                  <list type="bullet">
                    <item>
                      Connecting to Azure SQL Database where the data source ends with:
                      <list type="bullet">
                        <item>.database.chinacloudapi.cn</item>
                        <item>.database.usgovcloudapi.net</item>
                        <item>.database.cloudapi.de</item>
                        <item>.database.windows.net</item>
                      </list>
                    </item>
                    <item><c>Authentication</c> is 'Active Directory Password' or 'Active Directory Integrated'</item>
                  </list>
                </item>
                <item><c>true</c> in all other cases.</item>
              </list>
            </description>
          </item>
          <item>
            <term>
              <b>Trust Server Certificate</b> or <b>TrustServerCertificate</b>
            </term>
            <description><c>false</c></description>
            <description>
              When set to <c>true</c>, TLS is used to encrypt the channel when bypassing walking the certificate chain to validate trust. If TrustServerCertificate is set to <c>true</c> and Encrypt is set to <c>false</c>, the channel is not encrypted. Recognized values are <c>true</c>, <c>false</c>, <c>yes</c>, and <c>no</c>. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-string-syntax">Connection String Syntax</see>.
            </description>
          </item>
          <item>
            <term>Type System Version</term>
            <description>N/A</description>
            <description>
              <b>
                A string value that indicates the type system the application expects. The functionality available to a client application is dependent on the version of SQL Server and the compatibility level of the database. Explicitly setting the type system version that the client application was written for avoids potential problems that could cause an application to break if a different version of SQL Server is used. <b>Note:</b> The type system version cannot be set for common language runtime (CLR) code executing in-process in SQL Server. For more information, see <see href="https://learn.microsoft.com/dotnet/framework/data/adonet/sql/sql-server-common-language-runtime-integration">SQL Server Common Language Runtime Integration</see>.
              </b>
              <b>
                Possible values are:
              </b>
              <list type="bullet">
                <item><c>Type System Version=SQL Server 2012;</c></item>
                <item><c>Type System Version=SQL Server 2008;</c></item>
                <item><c>Type System Version=SQL Server 2005;</c></item>
                <item><c>Type System Version=Latest;</c></item>
              </list>
              <para>
                <c>Type System Version=SQL Server 2012;</c> specifies that the application will require version 11.0.0.0 of Microsoft.SqlServer.Types.dll. The other <c>Type System Version</c> settings will require version 10.0.0.0 of Microsoft.SqlServer.Types.dll.
              </para>
              <para>
                <c>Latest</c> is obsolete and should not be used. <c>Latest</c> is equivalent to <c>Type System Version=SQL Server 2008;</c>.
              </para>
            </description>
          </item>
          <item>
            <term>
              <b>User ID</b> or <b>UID</b> or <b>User</b>
            </term>
            <description>N/A</description>
            <description>
              <para>
                The SQL Server login account. Not recommended. To maintain a high level of security, we strongly recommend that you use the <c>Integrated Security</c> or <c>Trusted_Connection</c> keywords instead. <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> is a more secure way to specify credentials for a connection that uses SQL Server Authentication.
              </para>
              <para>
                The user ID must be 128 characters or fewer.
              </para>
            </description>
          </item>
          <item>
            <term>User Instance</term>
            <description><c>false</c></description>
            <description>
              A value that indicates whether to redirect the connection from the default SQL Server Express instance to a runtime-initiated instance running under the account of the caller.
            </description>
          </item>
          <item>
            <term>
              <b>Workstation ID</b> or <b>WSID</b>
            </term>
            <description>The local computer name</description>
            <description>
              <para>The name of the workstation connecting to SQL Server.</para>
              <para>The ID must be 128 characters or fewer.</para>
            </description>
          </item>
        </list>
        <para>
          The following list contains the valid names for connection pooling values within the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-connection-pooling">SQL Server Connection Pooling (ADO.NET)</see>.
        </para>
        <list type="bullet">
          <item>Connection Lifetime (or Load Balance Timeout)</item>
          <item>Enlist</item>
          <item>Max Pool Size</item>
          <item>Min Pool Size</item>
          <item>Pooling</item>
        </list>
        <para>
          When you are setting keyword or connection pooling values that require a Boolean value, you can use <c>yed</c> instead of <c>true</c>, and <c>no</c> instead of <c>false</c>. Integer values are represented as strings.
        </para>
        <note type="note">
          The .NET Framework Data Provider for SQL Server uses its own protocol to communicate with SQL Server. Therefore, it does not support the use of an ODBC data source name (DSN) when connecting to SQL Server because it does not add an ODBC layer.
        </note>
        <note type="note">
          Universal data link (UDL) files are not supported for the .NET Framework Data Provider for SQL Server.
        </note>
        <note type="caution">
          In this release, the application should use caution when constructing a connection string based on user input (for example when retrieving user ID and password information from a dialog box, and appending it to the connection string). The application should make sure that a user cannot embed additional connection string parameters in these values (for example, entering a password as "validpassword;database=somedb" in an attempt to attach to a different database). If you need to construct connection strings based on user input, use the new <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" />, which validates the connection string and helps to eliminate this problem. See <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-string-builders">Connection String Builders</see> for more information.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and sets the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property before opening the connection.
        </para>
        <!-- SqlConnection_ConnectionString -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  OpenSqlConnection();
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection()
              {
                  string connectionString = GetConnectionString();
          
                  using (SqlConnection connection = new SqlConnection())
                  {
                      connection.ConnectionString = connectionString;
          
                      connection.Open();
          
                      Console.WriteLine("State: {0}", connection.State);
                      Console.WriteLine("ConnectionString: {0}",
                          connection.ConnectionString);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file.
                  return "Data Source=MSSQL1;Initial Catalog=AdventureWorks;"
                      + "Integrated Security=true;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        An invalid connection string argument has been supplied, or a required connection string argument has not been supplied.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionTimeout">
            <summary>
        Gets the time to wait while trying to establish a connection before terminating the attempt and generating an error.
      </summary><value>
        The time (in seconds) to wait for a connection to open. The default value is 15 seconds.
      </value><remarks>
        You can set the amount of time a connection waits to time out by using the <c>Connect Timeout</c> or <c>Connection Timeout</c> keywords in the connection string. A value of 0 indicates no limit, and should be avoided in a <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> because an attempt to connect waits indefinitely.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and sets the <c>Connection Timeout</c> to 30 seconds in the connection string. The code opens the connection and displays the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionTimeout" /> property in the console window.
        </para>
        <!-- SqlConnection_ConnectionTimeout -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  OpenSqlConnection();
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection()
              {
                  string connectionString = GetConnectionString();
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("State: {0}", connection.State);
                      Console.WriteLine("ConnectionTimeout: {0}",
                          connection.ConnectionTimeout);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                      + "Integrated Security=SSPI;Connection Timeout=30";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value set is less than 0.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.Credential">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object for this connection.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object for this connection.
      </value><remarks>
        <para>
          <c>Persist Security Info = true</c> is required to get the value of the <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object with <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" />. The default value of <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" /> is null. An <see cref="T:System.InvalidOperationException" /> exception will be raised:
        </para>
        <list type="bullet">
          <item>
            If <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" /> is set on an open connection.
          </item>
          <item>
            If <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" /> is set when <c>Integrated Security = true</c>.
          </item>
          <item>
            If <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" /> is set when the connection string uses <c>Password</c>.
          </item>
          <item>
            If <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" /> is set when the connection string uses <c>UserID</c>.
          </item>
        </list>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.Database">
            <summary>
        Gets the name of the current database or the database to be used after a connection is opened.
      </summary><value>
        The name of the current database or the name of the database to be used after a connection is opened. The default value is an empty string.
      </value><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Database" /> property updates dynamically. If you change the current database using a Transact-SQL statement or the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ChangeDatabase(System.String)" /> method, an informational message is sent and the property is updated automatically.
        <para>
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and displays some of its read-only properties.
        </para>
        <!-- SqlConnection_Database -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program1
          {
              static void Main()
              {
                  string s = GetConnectionString();
          
                  ChangeSqlDatabase(s);
                  Console.ReadLine();
              }
          
              private static void ChangeSqlDatabase(string connectionString)
              {
                  // Assumes connectionString represents a valid connection string
                  // to the AdventureWorks sample database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("Database: {0}", connection.Database);
          
                      connection.ChangeDatabase("Northwind");
                      Console.WriteLine("Database: {0}", connection.Database);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.DataSource">
            <summary>
        Gets the name of the instance of SQL Server to which to connect.
      </summary><value>
        The name of the instance of SQL Server to which to connect. The default value is an empty string.
      </value><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and displays some of its read-only properties.
        </para>
        <!-- SqlConnection_DataSource -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program1
          {
              static void Main()
              {
                  string s = GetConnectionString();
          
                  OpenSqlConnection(s);
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection(string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("DataSource: {0}", connection.DataSource);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors">
            <summary>
        Gets or sets the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> property.
      </summary><value>
        <see langword="true" /> if the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> property has been set; otherwise <see langword="false" />.
      </value><remarks>
        <para>
          When you set <see cref="P:Microsoft.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> to <c>true</c>, errors that were previously treated as exceptions are now handled as <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> events. All events fire immediately and are handled by the event handler. If is <see cref="P:Microsoft.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> is set to <c>false</c>, then <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> events are handled at the end of the procedure.
        </para>
        <note type="note">
          An error with a severity level of 17 or above that causes the server to stop processing the command needs to be handled as an exception. In this case, an exception is thrown regardless of how the error is handled in the <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event.
        </note>
        <para>
          For more information on working with events, see <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-events">Connection Events</see>. For more information on errors generated by the SQL Server engine, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Errors</see>.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.PacketSize">
            <summary>
        Gets the size (in bytes) of network packets used to communicate with an instance of SQL Server.
      </summary><value>
        The size (in bytes) of network packets. The default value is 8000.
      </value><remarks>
        <para>
          If an application performs bulk copy operations, or sends or receives lots of text or image data, a packet size larger than the default may improve efficiency because it causes fewer network read and write operations. If an application sends and receives small amounts of information, you can set the packet size to 512 bytes (using the Packet Size value in the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />), which is sufficient for most data transfer operations. For most applications, the default packet size is best. <see cref="P:Microsoft.Data.SqlClient.SqlConnection.PacketSize" /> may be a value in the range of 512 and 32767 bytes. An exception is generated if the value is outside this range.
        </para>
        <para>
          Setting the default value to a number greater than 8000 will cause the packets to use the MultiPage allocator on the instance of SQL Server instead of the much more efficient SinglePage allocator, reducing the overall scalability of the SQL Server. For more information on how SQL Server uses memory, see <see href="https://learn.microsoft.com/sql/relational-databases/memory-management-architecture-guide">Memory Management Architecture Guide</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, including setting the <c>Packet Size</c> to 512 in the connection string. It displays the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.PacketSize" /> and <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ServerVersion" /> properties in the console window.
        </para>
        <!-- SqlConnection_PacketSize -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  OpenSqlConnection();
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection()
              {
                  string connectionString = GetConnectionString();
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("PacketSize: {0}", connection.PacketSize);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;Packet Size=512";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ServerVersion">
            <summary>
        Gets a string that contains the version of the instance of SQL Server to which the client is connected.
      </summary><value>
        The version of the instance of SQL Server.
      </value><remarks>
        The version is of the form <i>##.##.####</i>, where the first two digits are the major version, the next two digits are the minor version, and the last four digits are the release version. The string is of the form <i>major.minor.build</i>, where major and minor are exactly two digits and build is exactly four digits. <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ServerVersion" /> was called while the returned Task was not completed and the connection was not opened after a call to <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and displays the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ServerVersion" /> property.
        </para>
        <!-- SqlConnection_ServerVersion -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace SqlConnection1CS
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString =
                          "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      CreateSqlConnection(connectionString);
                      Console.ReadLine();
                  }
                
                  private static void CreateSqlConnection(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
                          Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                          Console.WriteLine("State: {0}", connection.State);
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        The connection is closed. <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ServerVersion" /> was called while the returned Task was not completed and the connection was not opened after a call to <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.ServerProcessId">
            <summary>
        Gets the server process ID (SPID) of the active connection.
      </summary><value>
        The server process ID (SPID) of the active connection.
      </value><remarks>
        Returns 0 if the connection is inactive on the client side.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.State">
            <summary>
        Indicates the state of the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> during the most recent network operation performed on the connection.
      </summary><value>
        An <see cref="T:System.Data.ConnectionState" /> enumeration.
      </value><remarks>
        Returns an <see cref="T:System.Data.ConnectionState" /> enumeration indicating the state of the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. Closing and reopening the connection will refresh the value of <see cref="P:Microsoft.Data.SqlClient.SqlConnection.State" />.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.StatisticsEnabled">
            <summary>
        When set to <see langword="true" />, enables statistics gathering for the current connection.
      </summary><value>
        Returns <see langword="true" /> if statistics gathering is enabled; otherwise <see langword="false" />. <see langword="false" /> is the default.
      </value><remarks>
        Enabling statistics gathering has a minor, but measurable effect on performance and therefore should be enabled only when it is required.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.WorkstationId">
            <summary>
        Gets a string that identifies the database client.
      </summary><value>
        A string that identifies the database client. If not specified, the name of the client computer. If neither is specified, the value is an empty string.
      </value><remarks>
        The string typically contains the network name of the client. The <see cref="P:Microsoft.Data.SqlClient.SqlConnection.WorkstationId" /> property corresponds to the <c>Workstation ID</c> connection string property.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and displays the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.WorkstationId" /> property.
        </para>
        <!-- SqlConnection_WorkstationId -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
          
                  OpenSqlConnection(s);
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection(string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("WorkstationId: {0}", connection.WorkstationId);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example>
        </member>
        <member name="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage">
            <summary>
        Occurs when SQL Server returns a warning or informational message.
      </summary><remarks>
        <para>
          Clients that want to process warnings or informational messages sent by the server should create an <see cref="T:Microsoft.Data.SqlClient.SqlInfoMessageEventHandler" /> delegate to listen to this event.
        </para>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event occurs when a message with a severity of 10 or less is returned by SQL Server. Messages that have a severity between 11 and 20 raise an error and messages that have a severity over 20 causes the connection to close. For more information on SQL Server error levels, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-error-severities">Database Engine Error Severities</see>.
          For more information and an example, see <see href="https://learn.microsoft.com/sql/connect/ado-net/connection-events">Connection Events</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.BeginDbTransaction(System.Data.IsolationLevel)">
            <param name="isolationLevel">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction">
            <summary>
        Starts a database transaction.
      </summary><returns>
        An object representing the new transaction.
      </returns><remarks>
        <para>
          This command maps to the SQL Server implementation of <c>BEGIN TRANSACTION</c>.You must explicitly commit or roll back the transaction using the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> or <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> method. To make sure that the .NET Framework Data Provider for SQL Server transaction management model performs correctly, avoid using other transaction management models, such as the one provided by SQL Server.
        </para>
        <note type="note">
          If you do not specify an isolation level, the default isolation level is used. To specify an isolation level with the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> method, use the overload that takes the <c>iso</c> parameter (<see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />). The isolation level set for a transaction persists after the transaction is completed and until the connection is closed or disposed. Setting the isolation level to <b>Snapshot</b> in a database where the snapshot isolation level is not enabled does not throw an exception. The transaction will complete using the default isolation level.
        </note>
        <note type="caution">
          If a transaction is started and a level 16 or higher error occurs on the server, the transaction will not be rolled back until the <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> method is invoked. No exception is thrown on <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" />.
        </note>
        <note type="caution">
          When your query returns a large amount of data and calls <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is thrown because SQL Server does not allow parallel transactions when using MARS. To avoid this problem, always associate a transaction with the command, the connection, or both before any readers are open.
        </note>
        <para>
          For more information on SQL Server transactions, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transactions-transact-sql">Transactions (Transact-SQL)</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. It also demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, a <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />, and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> methods.
        </para>
        <!-- SqlConnection_BeginTransaction -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace Transaction1Cs
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString =
                          "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      ExecuteSqlTransaction(connectionString);
                      Console.ReadLine();
                  }
                  private static void ExecuteSqlTransaction(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
          
                          SqlCommand command = connection.CreateCommand();
                          SqlTransaction transaction;
          
                          // Start a local transaction.
                          transaction = connection.BeginTransaction();
          
                          // Must assign both transaction object and connection
                          // to Command object for a pending local transaction
                          command.Connection = connection;
                          command.Transaction = transaction;
          
                          try
                          {
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')";
                              command.ExecuteNonQuery();
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (101, 'Description')";
                              command.ExecuteNonQuery();
          
                              // Attempt to commit the transaction.
                              transaction.Commit();
                              Console.WriteLine("Both records are written to database.");
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine("Commit Exception Type: {0}", ex.GetType());
                              Console.WriteLine("  Message: {0}", ex.Message);
          
                              // Attempt to roll back the transaction.
                              try
                              {
                                  transaction.Rollback();
                              }
                              catch (Exception ex2)
                              {
                                  // This catch block will handle any errors that may have occurred
                                  // on the server that would cause the rollback to fail, such as
                                  // a closed connection.
                                  Console.WriteLine("Rollback Exception Type: {0}", ex2.GetType());
                                  Console.WriteLine("  Message: {0}", ex2.Message);
                              }
                          }
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).
      </exception><exception cref="T:System.InvalidOperationException">
        Parallel transactions are not supported.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel)">
            <param name="iso">
        The isolation level under which the transaction should run.
      </param><summary>
        Starts a database transaction with the specified isolation level.
      </summary><returns>
        An object representing the new transaction.
      </returns><remarks>
        <para>
          This command maps to the SQL Server implementation of <c>BEGIN TRANSACTION</c>. You must explicitly commit or roll back the transaction using the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> or <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> method. To make sure that the .NET Framework Data Provider for SQL Server transaction management model performs correctly, avoid using other transaction management models, such as the one provided by SQL Server.
        </para>
        <note type="note">
          After a transaction is committed or rolled back, the isolation level of the transaction persists for all subsequent commands that are in autocommit mode (the SQL Server default). This can produce unexpected results, such as an isolation level of REPEATABLE READ persisting and locking other users out of a row. To reset the isolation level to the default (READ COMMITTED), execute the Transact-SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED statement, or call <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> followed immediately by <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />. For more information on SQL Server isolation levels, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transaction-isolation-levels">Transaction Isolation Levels</see>.
        </note>
        <para>
          For more information on SQL Server transactions, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transactions-transact-sql">Transactions (Transact-SQL)</see>.
        </para>
        <note type="caution">
          When your query returns a large amount of data and calls <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is thrown because SQL Server does not allow parallel transactions when using MARS. To avoid this problem, always associate a transaction with the command, the connection, or both before any readers are open.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. It also demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, a <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />, and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> methods.
        </para>
        <!-- SqlConnection_BeginTransaction1 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString =
                      "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                  ExecuteSqlTransaction(connectionString);
                  Console.ReadLine();
              }
            
              private static void ExecuteSqlTransaction(string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      SqlCommand command = connection.CreateCommand();
                      SqlTransaction transaction;
          
                      // Start a local transaction.
                      transaction = connection.BeginTransaction(IsolationLevel.ReadCommitted);
          
                      // Must assign both transaction object and connection
                      // to Command object for a pending local transaction
                      command.Connection = connection;
                      command.Transaction = transaction;
          
                      try
                      {
                          command.CommandText =
                              "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')";
                          command.ExecuteNonQuery();
                          command.CommandText =
                              "Insert into Region (RegionID, RegionDescription) VALUES (101, 'Description')";
                          command.ExecuteNonQuery();
                          transaction.Commit();
                          Console.WriteLine("Both records are written to database.");
                      }
                      catch (Exception e)
                      {
                          try
                          {
                              transaction.Rollback();
                          }
                          catch (SqlException ex)
                          {
                              if (transaction.Connection != null)
                              {
                                  Console.WriteLine("An exception of type " + ex.GetType() +
                                      " was encountered while attempting to roll back the transaction.");
                              }
                          }
          
                          Console.WriteLine("An exception of type " + e.GetType() +
                              " was encountered while inserting the data.");
                          Console.WriteLine("Neither record was written to database.");
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).
      </exception><exception cref="T:System.InvalidOperationException">
        Parallel transactions are not supported.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel,System.String)">
            <param name="iso">
        The isolation level under which the transaction should run.
      </param><param name="transactionName">
        The name of the transaction.
      </param><summary>
        Starts a database transaction with the specified isolation level and transaction name.
      </summary><returns>
        An object representing the new transaction.
      </returns><remarks>
        <para>
          This command maps to the SQL Server implementation of <c>BEGIN TRANSACTION</c>. The value in the <paramref name="transactionName" /> parameter can be used in later calls to <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> and in the <c>savePoint</c> parameter of the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Save" /> method. You must explicitly commit or roll back the transaction using the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> or <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> method. To make sure that the SQL Server transaction management model performs correctly, avoid using other transaction management models, such as the one provided by SQL Server.
        </para>
        <note type="note">
          After a transaction is committed or rolled back, the isolation level of the transaction persists for all subsequent commands that are in autocommit mode (the SQL Server default). This can produce unexpected results, such as an isolation level of REPEATABLE READ persisting and locking other users out of a row. To reset the isolation level to the default (READ COMMITTED), execute the Transact-SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED statement, or call <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> followed immediately by <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />. For more information on SQL Server isolation levels, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transaction-isolation-levels">Transaction Isolation Levels</see>.
        </note>
        <para>
          For more information on SQL Server transactions, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transactions-transact-sql">Transactions (Transact-SQL)</see>.
        </para>
        <note type="caution">
          When your query returns a large amount of data and calls <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is thrown because SQL Server does not allow parallel transactions when using MARS. To avoid this problem, always associate a transaction with the command, the connection, or both before any readers are open.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. It also demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, a <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />, and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> methods.
        </para>
        <!-- SqlConnection_BeginTransaction3 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace Transaction1CS
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString =
                          "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      ExecuteSqlTransaction(connectionString);
                      Console.ReadLine();
                  }

                  private static void ExecuteSqlTransaction(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
          
                          SqlCommand command = connection.CreateCommand();
                          SqlTransaction transaction;
          
                          // Start a local transaction.
                          transaction = connection.BeginTransaction(
                              IsolationLevel.ReadCommitted, "SampleTransaction");
          
                          // Must assign both transaction object and connection
                          // to Command object for a pending local transaction.
                          command.Connection = connection;
                          command.Transaction = transaction;
          
                          try
                          {
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')";
                              command.ExecuteNonQuery();
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (101, 'Description')";
                              command.ExecuteNonQuery();
                              transaction.Commit();
                              Console.WriteLine("Both records are written to database.");
                          }
                          catch (Exception e)
                          {
                              try
                              {
                                  transaction.Rollback("SampleTransaction");
                              }
                              catch (SqlException ex)
                              {
                                  if (transaction.Connection != null)
                                  {
                                      Console.WriteLine("An exception of type " + ex.GetType() +
                                          " was encountered while attempting to roll back the transaction.");
                                  }
                              }
          
                              Console.WriteLine("An exception of type " + e.GetType() +
                                  " was encountered while inserting the data.");
                              Console.WriteLine("Neither record was written to database.");
                          }
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).
      </exception><exception cref="T:System.InvalidOperationException">
        Parallel transactions are not supported.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction(System.String)">
            <param name="transactionName">
        The name of the transaction.
      </param><summary>
        Starts a database transaction with the specified transaction name.
      </summary><returns>
        An object representing the new transaction.
      </returns><remarks>
        <para>
          This command maps to the SQL Server implementation of <c>BEGIN TRANSACTION</c>. The length of the <paramref name="transactionName" /> parameter must not exceed 32 characters; otherwise an exception will be thrown. The value in the <paramref name="transactionName" /> parameter can be used in later calls to <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> and in the <c>savePoint</c> parameter of the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Save" /> method. You must explicitly commit or roll back the transaction using the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> or <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> method. To make sure that the .NET Data Provider for SQL Server transaction management model performs correctly, avoid using other transaction management models, such as the one provided by SQL Server. For more information on SQL Server transactions, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transactions-transact-sql">Transactions (Transact-SQL)</see>.
        </para>
        <note type="caution">
          When your query returns a large amount of data and calls <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.BeginTransaction" />, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is thrown because SQL Server does not allow parallel transactions when using MARS. To avoid this problem, always associate a transaction with the command, the connection, or both before any readers are open.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. It also demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, a <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />, and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> methods.
        </para>
        <!-- SqlConnection_BeginTransaction2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace Transaction1CS
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString =
                          "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      ExecuteSqlTransaction(connectionString);
                      Console.ReadLine();
                  }
          
                  private static void ExecuteSqlTransaction(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
          
                          SqlCommand command = connection.CreateCommand();
                          SqlTransaction transaction;
          
                          // Start a local transaction.
                          transaction = connection.BeginTransaction("SampleTransaction");
          
                          // Must assign both transaction object and connection
                          // to Command object for a pending local transaction
                          command.Connection = connection;
                          command.Transaction = transaction;
          
                          try
                          {
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')";
                              command.ExecuteNonQuery();
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (101, 'Description')";
                              command.ExecuteNonQuery();
          
                              // Attempt to commit the transaction.
                              transaction.Commit();
                              Console.WriteLine("Both records are written to database.");
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine("Commit Exception Type: {0}", ex.GetType());
                              Console.WriteLine("  Message: {0}", ex.Message);
          
                              // Attempt to roll back the transaction.
                              try
                              {
                                  transaction.Rollback("SampleTransaction");
                              }
                              catch (Exception ex2)
                              {
                                  // This catch block will handle any errors that may have occurred
                                  // on the server that would cause the rollback to fail, such as
                                  // a closed connection.
                                  Console.WriteLine("Rollback Exception Type: {0}", ex2.GetType());
                                  Console.WriteLine("  Message: {0}", ex2.Message);
                              }
                          }
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).
      </exception><exception cref="T:System.InvalidOperationException">
        Parallel transactions are not supported.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.ChangeDatabase(System.String)">
            <param name="database">
        The name of the database to use instead of the current database.
      </param><summary>
        Changes the current database for an open <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />.
      </summary><remarks>
        The value supplied in the <paramref name="database" /> parameter must be a valid database name. The <paramref name="database" /> parameter cannot contain a null value, an empty string, or a string with only blank characters.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and displays some of its read-only properties.
        </para>
        <!-- SqlConnection_Database -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program1
          {
              static void Main()
              {
                  string s = GetConnectionString();
          
                  ChangeSqlDatabase(s);
                  Console.ReadLine();
              }
          
              private static void ChangeSqlDatabase(string connectionString)
              {
                  // Assumes connectionString represents a valid connection string
                  // to the AdventureWorks sample database.
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("Database: {0}", connection.Database);
          
                      connection.ChangeDatabase("Northwind");
                      Console.WriteLine("Database: {0}", connection.Database);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                      + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The database name is not valid.
      </exception><exception cref="T:System.InvalidOperationException">
        The connection is not open.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Cannot change the database.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.ChangePassword(System.String,Microsoft.Data.SqlClient.SqlCredential,System.Security.SecureString)">
            <param name="connectionString">
        The connection string that contains enough information to connect to a server. The connection string should not use any of the following connection string keywords: <c>Integrated Security = true</c>, <c>UserId</c>, or <c>Password</c> ; or <c>ContextConnection = true</c>.
      </param><param name="credential">
        A <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object.
      </param><param name="newSecurePassword">
        The new password. <paramref name="newSecurePassword" /> must be read only. The password must also comply with any password security policy set on the server (for example, minimum length and requirements for specific characters).
      </param><summary>
        Changes the SQL Server password for the user indicated in the <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object.
      </summary><exception cref="T:System.ArgumentException">
        <list type="bullet">
          <item>
            The connection string contains any combination of <c>UserId</c>, <c>Password</c>, or <c>Integrated Security=true</c>.
          </item>
          <item>
            <paramref name="newSecurePassword" /> is greater than 128 characters.
          </item>
          <item>
            <paramref name="newSecurePassword" /> is not read only.
          </item>
          <item>
            <paramref name="newSecurePassword" /> is an empty string.
          </item>
        </list>
      </exception><exception cref="T:System.ArgumentNullException">
        One of the parameters (<paramref name="connectionString" />, <paramref name="credential" />, or <paramref name="newSecurePassword" />) is null.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)">
            <param name="connectionString">
        The connection string that contains enough information to connect to the server that you want. The connection string must contain the user ID and the current password.
      </param><param name="newPassword">
        The new password to set. This password must comply with any password security policy set on the server, including minimum length, requirements for specific characters, and so on.
      </param><summary>
        Changes the SQL Server password for the user indicated in the connection string to the supplied new password.
      </summary><remarks>
        When you are using SQL Server on Windows Server, developers can take advantage of functionality that lets the client application supply both the current and a new password in order to change the existing password. Applications can implement functionality such as prompting the user for a new password during initial login if the old one has expired, and this operation can be completed without administrator intervention. This method changes the SQL Server password for the user indicated in the supplied <c>connectionString</c> parameter to the value supplied in the <paramref name="newPassword" /> parameter. If the connection string includes the option for integrated security (that is, "Integrated Security=True" or the equivalent), an exception is thrown. To determine that the password has expired, calling the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Open" /> method raises a <see cref="T:Microsoft.Data.SqlClient.SqlException" />. In order to indicate that the password that is contained within the connection string must be reset, the <see cref="P:Microsoft.Data.SqlClient.SqlException.Number" /> property for the exception contains the status value 18487 or 18488. The first value (18487) indicates that the password has expired and the second (18488) indicates that the password must be reset before logging in. This method opens its own connection to the server, requests the password change, and closes the connection as soon as it has completed. This connection is not retrieved from, nor returned to, the SQL Server connection pool.
      </remarks><example>
        <para>
          The following is a simple example of changing a password:
        </para>
        <code language="c#">
          class Program
          {
            static void Main(string[] args)
            {
              Microsoft.Data.SqlClient.SqlConnection.ChangePassword(
                "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",
                "new_password");
            }
          }
        </code>
        <code language="vb">
          Module Module1
            Sub Main()
              Microsoft.Data.SqlClient.SqlConnection.ChangePassword(
                "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",
                "new_password")
            End Sub
          End Module
        </code>
      </example><example>
        <para>
          The following console application demonstrates the issues involved in changing a user's password because the current password has expired.
        </para>
        <!-- SqlConnection_ConnectionString1 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  try
                  {
                      DemonstrateChangePassword();
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine("Error: " + ex.Message);
                  }
                  Console.WriteLine("Press ENTER to continue...");
                  Console.ReadLine();
              }
          
              private static void DemonstrateChangePassword()
              {
                  // Retrieve the connection string. In a production application,
                  // this string should not be contained within the source code.
                  string connectionString = GetConnectionString();
          
                  using (SqlConnection cnn = new SqlConnection())
                  {
                      for (int i = 0; i &lt;= 1; i++)
                      {
                          // Run this loop at most two times. If the first attempt fails, 
                          // the code checks the Number property of the SqlException object.
                          // If that contains the special values 18487 or 18488, the code 
                          // attempts to set the user's password to a new value. 
                          // Assuming this succeeds, the second pass through 
                          // successfully opens the connection.
                          // If not, the exception handler catches the exception.
                          try
                          {
                              cnn.ConnectionString = connectionString;
                              cnn.Open();
                              // Once this succeeds, just get out of the loop.
                              // No need to try again if the connection is already open.
                              break;
                          }
                          catch (SqlException ex)
                          {
                              if (i == 0 &amp;&amp; ((ex.Number == 18487) || (ex.Number == 18488)))
                              {
                                  // You must reset the password. 
                                  connectionString =
                                      ModifyConnectionString(connectionString,
                                      GetNewPassword());
          
                              }
                              else
                                  // Bubble all other SqlException occurrences
                                  // back up to the caller.
                                  throw;
                          }
                      }
                      SqlCommand cmd = new SqlCommand(
                          "SELECT ProductID, Name FROM Product", cnn);
                      // Use the connection and command here...
                  }
              }
          
              private static string ModifyConnectionString(
                  string connectionString, string NewPassword)
              {
          
                  // Use the SqlConnectionStringBuilder class to modify the
                  // password portion of the connection string. 
                  SqlConnectionStringBuilder builder =
                      new SqlConnectionStringBuilder(connectionString);
                  builder.Password = NewPassword;
                  return builder.ConnectionString;
              }
          
              private static string GetNewPassword()
              {
                  // In a real application, you might display a modal
                  // dialog box to retrieve the new password. The concepts
                  // are the same as for this simple console application, however.
                  Console.Write("Your password must be reset. Enter a new password: ");
                  return Console.ReadLine();
              }
          
              private static string GetConnectionString()
              {
                  // For this demonstration, the connection string must
                  // contain both user and password information. In your own
                  // application, you might want to retrieve this setting
                  // from a config file, or from some other source.
          
                  // In a production application, you would want to 
                  // display a modal form that could gather user and password
                  // information.
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(
                      "Data Source=(local);Initial Catalog=AdventureWorks");
          
                  Console.Write("Enter your user id: ");
                  builder.UserID = Console.ReadLine();
                  Console.Write("Enter your password: ");
                  builder.Password = Console.ReadLine();
          
                  return builder.ConnectionString;
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        <list type="bullet">
          <item>
            The connection string includes the option to use integrated security.
          </item>
          <item>
            The <paramref name="newPassword" /> exceeds 128 characters.
          </item>
        </list>
      </exception><exception cref="T:System.ArgumentNullException">
        Either the <paramref name="connectionString" /> or the <paramref name="newPassword" /> parameter is null.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.ClearAllPools">
            <summary>
        Empties the connection pool.
      </summary><remarks>
        <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ClearAllPools" /> resets (or empties) the connection pool. If there are connections in use at the time of the call, they are marked appropriately and will be discarded (instead of being returned to the pool) when <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> is called on them.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.ClearPool(Microsoft.Data.SqlClient.SqlConnection)">
            <param name="connection">
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> to be cleared from the pool.
      </param><summary>
        Empties the connection pool associated with the specified connection.
      </summary><remarks>
        <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ClearPool" /> clears the connection pool that is associated with the <paramref name="connection" />. If additional connections associated with <paramref name="connection" /> are in use at the time of the call, they are marked appropriately and are discarded (instead of being returned to the pool) when <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> is called on them.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.Close">
            <summary>
        Closes the connection to the database. This is the preferred method of closing any open connection.
      </summary><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> method rolls back any pending transactions. It then releases the connection to the connection pool, or closes the connection if connection pooling is disabled.
        </para>
        <note type="note">
          Pending transactions started using Transact-SQL or <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> are automatically rolled back when the connection is reset if connection pooling is enabled. If connection pooling is off, the transaction is rolled back after <c>SqlConnection.Close</c> is called. Transactions started through <see cref="T:System.Transactions" /> are controlled through the <see cref="T:System.Transactions" /> infrastructure, and are not affected by <c>SqlConnection.Close</c>.
        </note>
        <para>
          An application can call <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> more than one time. No exception is generated. If the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> goes out of scope, it won't be closed. Therefore, you must explicitly close the connection by calling <c>Close</c> or <c>Dispose</c>. <c>Close</c> and <c>Dispose</c> are functionally equivalent. If the connection pooling value <c>Pooling</c> is set to <c>true</c> or <c>yes</c>, the underlying connection is returned back to the connection pool. On the other hand, if <c>Pooling</c> is set to <c>false</c> or <c>no</c>, the underlying connection to the server is closed.
        </para>
        <note type="note">
          Login and logout events will not be raised on the server when a connection is fetched from or returned to the connection pool, because the connection is not actually closed when it is returned to the connection pool. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-connection-pooling">SQL Server Connection Pooling (ADO.NET)</see>.
        </note>
        <note type="caution">
          Do not call <c>Close</c> or <c>Dispose</c> on a Connection, a DataReader, or any other managed object in the <c>Finalize</c> method of your class. In a finalizer, you should only release unmanaged resources that your class owns directly. If your class does not own any unmanaged resources, do not include a <c>Finalize</c> method in your class definition. For more information, see <see href="https://learn.microsoft.com/dotnet/standard/garbage-collection/">Garbage Collection</see>.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, opens it, displays some of its properties. The connection is automatically closed at the end of the <c>using</c> block.
        </para>
        <!-- SqlConnection_Open -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program1
          {
              static void Main()
              {
                  string s = GetConnectionString();
          
                  OpenSqlConnection(s);
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection(string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("State: {0}", connection.State);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        The connection-level error that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.CreateCommand">
            <summary>
        Creates and returns a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object associated with the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
      </returns><example>
        <!-- SqlConnection_CreateCommand -->
        <code language="c#">
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          public class A
          {
              public static void Main()
              {
                  using (SqlConnection connection = new SqlConnection("Data Source=(local);Initial Catalog=Northwind;Integrated Security=SSPI;"))
                  {
                      connection.Open();
                      SqlCommand command = connection.CreateCommand();
                      command.CommandText = "SELECT * FROM Categories ORDER BY CategoryID";
                      command.CommandTimeout = 15;
                      command.CommandType = CommandType.Text;
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.CreateDbCommand">
            <summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema">
            <summary>
        Returns schema information for the data source of this <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. For more information about scheme, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-schema-collections">SQL Server Schema Collections</see>.
      </summary><returns>
        A <see cref="T:System.Data.DataTable" /> that contains schema information.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String)">
            <param name="collectionName">
        Specifies the name of the schema to return.
      </param><summary>
        Returns schema information for the data source of this <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> using the specified string for the schema name.
      </summary><returns>
        A <see cref="T:System.Data.DataTable" /> that contains schema information.
      </returns><remarks>
        <para>
          You may need the schema information of the database, tables or columns. This sample:
        </para>
        <list type="bullet">
          <item>Uses GetSchema to get schema information.</item>
          <item>Use schema restrictions to get the specified information.</item>
          <item>Gets schema information of the database, tables, and some columns.</item>
        </list>
      </remarks><example>
        <para>
          Before you run the sample, you need to create the sample database, using the following Transact-SQL:
        </para>
        <code language="sql">
          USE [master]
          GO

          CREATE DATABASE [MySchool]
          GO

          USE [MySchool]
          GO

          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO

          CREATE TABLE [dbo].[Course](
            [CourseID] [nvarchar](10) NOT NULL,
            [Year] [smallint] NOT NULL,
            [Title] [nvarchar](100) NOT NULL,
            [Credits] [int] NOT NULL,
            [DepartmentID] [int] NOT NULL,
            CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED (
              [CourseID] ASC,
              [Year] ASC
            ) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
          ) ON [PRIMARY]
          GO

          SET ANSI_NULLS ON
          GO
          SET QUOTED_IDENTIFIER ON
          GO

          CREATE TABLE [dbo].[Department](
            [DepartmentID] [int] IDENTITY(1,1) NOT NULL,
            [Name] [nvarchar](50) NOT NULL,
            [Budget] [money] NOT NULL,
            [StartDate] [datetime] NOT NULL,
            [Administrator] [int] NULL,
            CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED (
              [DepartmentID] ASC
            ) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
          ) ON [PRIMARY]
          GO

          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID])
            VALUES (N'C1045', 2012, N'Calculus', 4, 7)
          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID])
            VALUES (N'C1061', 2012, N'Physics', 4, 1)
          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID])
            VALUES (N'C2021', 2012, N'Composition', 3, 2)
          INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID])
            VALUES (N'C2042', 2012, N'Literature', 4, 2)
          SET IDENTITY_INSERT [dbo].[Department] ON
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator])
            VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator])
            VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator])
            VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)
          INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator])
            VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)
          SET IDENTITY_INSERT [dbo].[Department] OFF

          ALTER TABLE [dbo].[Course]
          WITH CHECK ADD
            CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])
              REFERENCES [dbo].[Department] ([DepartmentID])
          GO

          ALTER TABLE [dbo].[Course]
          CHECK CONSTRAINT [FK_Course_Department]
          GO
        </code>
        <para>
          <see href="https://learn.microsoft.com/dotnet/api/microsoft.data.sqlclient.sqlconnection.getschema">How to Get Schema Information from Database</see> has C# and Visual Basic versions of this code sample in a Visual Studio project.
        </para>
        <!-- SqlConnection_GetSchema -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main(string[] args)
              {
                  using (SqlConnection conn = new SqlConnection("Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;"))
                  {
                      conn.Open();
          
                      // Get the Meta Data for Supported Schema Collections  
                      DataTable metaDataTable = conn.GetSchema("MetaDataCollections");
          
                      Console.WriteLine("Meta Data for Supported Schema Collections:");
                      ShowDataTable(metaDataTable, 25);
                      Console.WriteLine();
          
                      // Get the schema information of Databases in your instance  
                      DataTable databasesSchemaTable = conn.GetSchema("Databases");
          
                      Console.WriteLine("Schema Information of Databases:");
                      ShowDataTable(databasesSchemaTable, 25);
                      Console.WriteLine();
          
                      // First, get schema information of all the tables in current database;  
                      DataTable allTablesSchemaTable = conn.GetSchema("Tables");
          
                      Console.WriteLine("Schema Information of All Tables:");
                      ShowDataTable(allTablesSchemaTable, 20);
                      Console.WriteLine();
          
                      // You can specify the Catalog, Schema, Table Name, Table Type to get   
                      // the specified table(s).  
                      // You can use four restrictions for Table, so you should create a 4 members array.  
                      String[] tableRestrictions = new String[4];
          
                      // For the array, 0-member represents Catalog; 1-member represents Schema;   
                      // 2-member represents Table Name; 3-member represents Table Type.   
                      // Now we specify the Table Name of the table what we want to get schema information.  
                      tableRestrictions[2] = "Course";
          
                      DataTable courseTableSchemaTable = conn.GetSchema("Tables", tableRestrictions);
          
                      Console.WriteLine("Schema Information of Course Tables:");
                      ShowDataTable(courseTableSchemaTable, 20);
                      Console.WriteLine();
          
                      // First, get schema information of all the columns in current database.  
                      DataTable allColumnsSchemaTable = conn.GetSchema("Columns");
          
                      Console.WriteLine("Schema Information of All Columns:");
                      ShowColumns(allColumnsSchemaTable);
                      Console.WriteLine();
          
                      // You can specify the Catalog, Schema, Table Name, Column Name to get the specified column(s).  
                      // You can use four restrictions for Column, so you should create a 4 members array.  
                      String[] columnRestrictions = new String[4];
          
                      // For the array, 0-member represents Catalog; 1-member represents Schema;   
                      // 2-member represents Table Name; 3-member represents Column Name.   
                      // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
                      columnRestrictions[2] = "Course";
                      columnRestrictions[3] = "DepartmentID";
          
                      DataTable departmentIDSchemaTable = conn.GetSchema("Columns", columnRestrictions);
          
                      Console.WriteLine("Schema Information of DepartmentID Column in Course Table:");
                      ShowColumns(departmentIDSchemaTable);
                      Console.WriteLine();
          
                      // First, get schema information of all the IndexColumns in current database  
                      DataTable allIndexColumnsSchemaTable = conn.GetSchema("IndexColumns");
          
                      Console.WriteLine("Schema Information of All IndexColumns:");
                      ShowIndexColumns(allIndexColumnsSchemaTable);
                      Console.WriteLine();
          
                      // You can specify the Catalog, Schema, Table Name, Constraint Name, Column Name to   
                      // get the specified column(s).  
                      // You can use five restrictions for Column, so you should create a 5 members array.  
                      String[] indexColumnsRestrictions = new String[5];
          
                      // For the array, 0-member represents Catalog; 1-member represents Schema;   
                      // 2-member represents Table Name; 3-member represents Constraint Name;4-member represents Column Name.   
                      // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
                      indexColumnsRestrictions[2] = "Course";
                      indexColumnsRestrictions[4] = "CourseID";
          
                      DataTable courseIdIndexSchemaTable = conn.GetSchema("IndexColumns", indexColumnsRestrictions);
          
                      Console.WriteLine("Index Schema Information of CourseID Column in Course Table:");
                      ShowIndexColumns(courseIdIndexSchemaTable);
                      Console.WriteLine();
                  }
          
                  Console.WriteLine("Please press any key to exit...");
                  Console.ReadKey();
              }
          
              private static void ShowDataTable(DataTable table, Int32 length)
              {
                  foreach (DataColumn col in table.Columns)
                  {
                      Console.Write("{0,-" + length + "}", col.ColumnName);
                  }
                  Console.WriteLine();
          
                  foreach (DataRow row in table.Rows)
                  {
                      foreach (DataColumn col in table.Columns)
                      {
                          if (col.DataType.Equals(typeof(DateTime)))
                          {
                              Console.Write("{0,-" + length + ":d}", row[col]);
                          }
                          else if (col.DataType.Equals(typeof(Decimal)))
                          {
                              Console.Write("{0,-" + length + ":C}", row[col]);
                          }
                          else {
                              Console.Write("{0,-" + length + "}", row[col]);
                          }
                      }
                      Console.WriteLine();
                  }
              }
          
              private static void ShowDataTable(DataTable table)
              {
                  ShowDataTable(table, 14);
              }
          
              private static void ShowColumns(DataTable columnsTable)
              {
                  var selectedRows = from info in columnsTable.AsEnumerable()
                                     select new
                                     {
                                         TableCatalog = info["TABLE_CATALOG"],
                                         TableSchema = info["TABLE_SCHEMA"],
                                         TableName = info["TABLE_NAME"],
                                         ColumnName = info["COLUMN_NAME"],
                                         DataType = info["DATA_TYPE"]
                                     };
          
                  Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", "TableCatalog", "TABLE_SCHEMA",
                      "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE");
                  foreach (var row in selectedRows)
                  {
                      Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", row.TableCatalog,
                          row.TableSchema, row.TableName, row.ColumnName, row.DataType);
                  }
              }
          
              private static void ShowIndexColumns(DataTable indexColumnsTable)
              {
                  var selectedRows = from info in indexColumnsTable.AsEnumerable()
                                     select new
                                     {
                                         TableSchema = info["table_schema"],
                                         TableName = info["table_name"],
                                         ColumnName = info["column_name"],
                                         ConstraintSchema = info["constraint_schema"],
                                         ConstraintName = info["constraint_name"],
                                         KeyType = info["KeyType"]
                                     };
          
                  Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", "table_schema", "table_name", "column_name", "constraint_schema", "constraint_name", "KeyType");
                  foreach (var row in selectedRows)
                  {
                      Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", row.TableSchema,
                          row.TableName, row.ColumnName, row.ConstraintSchema, row.ConstraintName, row.KeyType);
                  }
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        <paramref name="collectionName" /> is specified as null.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema(System.String,System.String[])">
            <param name="collectionName">
        Specifies the name of the schema to return.
      </param><param name="restrictionValues">
        A set of restriction values for the requested schema.
      </param><summary>
        Returns schema information for the data source of this <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> using the specified string for the schema name and the specified string array for the restriction values.
      </summary><returns>
        A <see cref="T:System.Data.DataTable" /> that contains schema information.
      </returns><remarks>
        <para>
          The <paramref name="restrictionValues" /> parameter can supply <i>n</i> depth of values, which are specified by the restrictions collection for a specific collection. In order to set values on a given restriction, and not set the values of other restrictions, you need to set the preceding restrictions to <see langword="null" /> and then put the appropriate value in for the restriction that you would like to specify a value for.
        </para>
        <para>
          An example of this is the "Tables" collection. If the "Tables" collection has three restrictions--database, owner, and table name--and you want to get back only the tables associated with the owner "Carl", you need to pass in the following values: null, "Carl". If a restriction value is not passed in, the default values are used for that restriction. This is the same mapping as passing in <see langword="null" />, which is different from passing in an empty string for the parameter value. In that case, the empty string ("") is considered to be the value for the specified parameter.
        </para>
      </remarks><example>
        For a code sample demonstrating <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema" />, see <see cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema" />.
      </example><exception cref="T:System.ArgumentException">
        <paramref name="collectionName" /> is specified as null.
      </exception><seealso cref="M:Microsoft.Data.SqlClient.SqlConnection.GetSchema" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.Open">
            <summary>
        Opens a database connection with the property settings specified by the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />.
      </summary><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> draws an open connection from the connection pool if one is available. Otherwise, it establishes a new connection to an instance of SQL Server.
        </para>
        <note type="note">
          If the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> goes out of scope, it is not closed. Therefore, you must explicitly close the connection by calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" />.
        </note>
        <note type="note">
          If you specify a port number other than 1433 when you are trying to connect to an instance of SQL Server and using a protocol other than TCP/IP, the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Open" /> method fails. To specify a port number other than 1433, include "server=machinename,port number" in the connection string, and use the TCP/IP protocol.
        </note>
        <note type="note">
          The .NET Framework Data Provider for SQL Server requires the Security permission with "Allows calls to unmanaged assemblies" enabled (<see cref="T:System.Security.Permission.SecurityPermission" /> with <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /> set to <c>UnmanagedCode</c>) to open a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> with SQL Debugging enabled.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, opens it, and displays some of its properties. The connection is automatically closed at the end of the <c>using</c> block.
        </para>
        <!-- SqlConnection_Open -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program1
          {
              static void Main()
              {
                  string s = GetConnectionString();
          
                  OpenSqlConnection(s);
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection(string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("State: {0}", connection.State);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Cannot open a connection without specifying a data source or server.</item>
          <item>The connection is already open.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        <para>
          A connection-level error occurred while opening the connection. If the <see cref="P:Microsoft.Data.SqlClient.SqlException.Number" /> property contains the value 18487 or 18488, this indicates that the specified password has expired or must be reset. See the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" /> method for more information.
        </para>
        <para>
          The <c>&lt;system.data.localdb&gt;</c> tag in the app.config file has invalid or unknown elements.
        </para>
      </exception><exception cref="T:System.Configuration.ConfigurationErrorsException">
        There are two entries with the same name in the <c>&lt;localdbinstances&gt;</c> section.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.Open(Microsoft.Data.SqlClient.SqlConnectionOverrides)">
            <param name="overrides">
        Options to override default connection open behavior.
      </param><summary>
        Opens a database connection with the property settings specified by the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />.
      </summary><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> draws an open connection from the connection pool if one is available. Otherwise, it establishes a new connection to an instance of SQL Server. If overrides are specified, the first open attempt will apply the specified overrides to the open action.
        </para>
        <note type="note">
          If the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> goes out of scope, it is not closed. Therefore, you must explicitly close the connection by calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" />.
        </note>
        <note type="note">
          If you specify a port number other than 1433 when you are trying to connect to an instance of SQL Server and using a protocol other than TCP/IP, the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Open" /> method fails. To specify a port number other than 1433, include "server=machinename,port number" in the connection string, and use the TCP/IP protocol.
        </note>
        <note type="note">
          The .NET Framework Data Provider for SQL Server requires the Security permission with "Allows calls to unmanaged assemblies" enabled (<see cref="T:System.Security.Permissions.SecurityPermission" /> with <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /> set to <c>UnmanagedCode</c>) to open a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> with SQL Debugging enabled.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, opens it, and displays some of its properties. The connection is automatically closed at the end of the <c>using</c> block.
        </para>
        <!-- SqlConnection_Open -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program1
          {
              static void Main()
              {
                  string s = GetConnectionString();
          
                  OpenSqlConnection(s);
                  Console.ReadLine();
              }
          
              private static void OpenSqlConnection(string connectionString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
                      Console.WriteLine("ServerVersion: {0}", connection.ServerVersion);
                      Console.WriteLine("State: {0}", connection.State);
                  }
              }
          
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property 
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI;";
              }
          }
        </code>
      </example><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>Cannot open a connection without specifying a data source or server.</item>
          <item>The connection is already open.</item>
        </list>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        A connection-level error occurred while opening the connection. If the <see cref="P:Microsoft.Data.SqlClient.SqlException.Number" /> property contains the value 18487 or 18488, this indicates that the specified password has expired or must be reset. See the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" /> method for more information. The <c>&lt;system.data.localdb&gt;</c> tag in the app.config file has invalid or unknown elements.
      </exception><exception cref="T:System.Configuration.ConfigurationErrorsException">
        There are two entries with the same name in the <c>&lt;localdbinstances&gt;</c> section.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Open" />, which opens a database connection with the property settings specified by the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />. The cancellation token can be used to request that the operation be abandoned before the connection timeout elapses. Exceptions will be propagated via the returned Task. If the connection timeout time elapses without successfully connecting, the returned Task will be marked as faulted with an Exception. The implementation returns a Task without blocking the calling thread for both pooled and non-pooled connections.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        <para>
          After calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />, <see cref="P:Microsoft.Data.SqlClient.SqlConnection.State" /> must return <see cref="F:System.Data.ConnectionState.Connecting" /> until the returned <see cref="T:System.Threading.Tasks.Task" /> is completed. Then, if the connection was successful, <see cref="P:Microsoft.Data.SqlClient.SqlConnection.State" /> must return <see cref="F:System.Data.ConnectionState.Open" />. If the connection fails, <see cref="P:Microsoft.Data.SqlClient.SqlConnection.State" /> must return <see cref="F:System.Data.ConnectionState.Closed" />.
        </para>
        <para>
          A call to <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> will attempt to cancel or close the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" /> call. For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        <para>
          Calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
        </para>
        <para>
          A connection was not available from the connection pool before the connection time out elapsed.
        </para>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(Microsoft.Data.SqlClient.SqlConnectionOverrides,System.Threading.CancellationToken)">
            <param name="overrides">
        Options to override default connection open behavior.
      </param><param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Open" />, which opens a database connection with the property settings specified by the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />. The cancellation token can be used to request that the operation be abandoned before the connection timeout elapses.  Exceptions will be propagated via the returned Task. If the connection timeout time elapses without successfully connecting, the returned Task will be marked as faulted with an Exception. The implementation returns a Task without blocking the calling thread for both pooled and non-pooled connections.
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        <para>
          After calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync" />, <see cref="P:Microsoft.Data.SqlClient.SqlConnection.State" /> must return <see cref="F:System.Data.ConnectionState.Connecting" /> until the returned <see cref="T:System.Threading.Tasks.Task" /> is completed. Then, if the connection was successful, <see cref="P:Microsoft.Data.SqlClient.SqlConnection.State" /> must return <see cref="F:System.Data.ConnectionState.Open" />. If the connection fails, <see cref="P:Microsoft.Data.SqlClient.SqlConnection.State" /> must return <see cref="F:System.Data.ConnectionState.Closed" />.
        </para>
        <para>
          A call to <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> will attempt to cancel or close the corresponding <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync" /> call. For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        <para>
          Calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.OpenAsync(Microsoft.Data.SqlClient.SqlConnectionOverrides, System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
        </para>
        <para>
          A connection was not available from the connection pool before the connection time out elapsed.
        </para>
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        Any error returned by SQL Server that occurred while opening the connection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.ResetStatistics">
            <summary>
        If statistics gathering is enabled, all values are reset to zero.
      </summary><remarks>
        If statistics gathering is not enabled and this method is called, no error is thrown.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.RetrieveStatistics">
            <summary>
        Returns a name value pair collection of statistics at the point in time the method is called.
      </summary><returns>
        Returns a reference of type <see cref="T:System.Collections.IDictionary" /> of <see cref="T:System.Collections.DictionaryEntry" /> items.
      </returns><remarks>
        When this method is called, the values retrieved are those at the current point in time. If you continue using the connection, the values are incorrect. You need to re-execute the method to obtain the most current values.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.RetrieveInternalInfo">
            <summary>
        Returns a name value pair collection of internal properties at the point in time the method is called.
      </summary><returns>
        Returns a reference of type <see cref="T:System.Collections.Generic.IDictionary`2" /> of (string, object) items.
      </returns><remarks>
        <para>
          When this method is called, the values retrieved are those at the current point in time. If you continue using the connection, the values are incorrect. You need to re-execute the method to obtain the most current values.
        </para>
        <list type="table">
          <listheader>
            <term>Supported internal properties</term>
            <term>Type</term>
            <term>Information provided</term>
            <term>Return value</term>
          </listheader>
          <item>
            <description><c>SQLDNSCachingSupportedState</c></description>
            <description>string</description>
            <description>To indicate the IsSupported flag sent by the server for DNS Caching</description>
            <description>"true", "false", "innerConnection is null!"</description>
          </item>
          <item>
            <description><c>SQLDNSCachingSupportedStateBeforeRedirect</c></description>
            <description>string</description>
            <description>To indicate the IsSupported flag sent by the server for DNS Caching before redirection.</description>
            <description>"true", "false", "innerConnection is null!"</description>
          </item>
        </list>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.RetryLogicProvider">
            <summary>
        Gets or sets a value that specifies the <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object bound to this command.
      </summary><value>
        When set to null (default), the default non-retryable provider will be applied.
      </value><remarks>
        <para>
          You must set the value for this property before opening the connection to take effect.
        </para>
        <para>
          To apply the retry logic, do the following steps before opening the connection:
        </para>
        <list type="number">
          <item>
            Define the configuration parameters by using <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicOption" /> type.
          </item>
          <item>
            Create a <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> by using one of the following static methods of the <see cref="T:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory" /> class:
            <list type="bullet">
              <item><see cref="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateFixedRetryProvider(Microsoft.Data.SqlClient.SqlRetryLogicOption)" /></item>
              <item><see cref="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateIncrementalRetryProvider(Microsoft.Data.SqlClient.SqlRetryLogicOption)" /></item>
              <item><see cref="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateExponentialRetryProvider(Microsoft.Data.SqlClient.SqlRetryLogicOption)" /></item>
              <item><see cref="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateNoneRetryProvider" /></item>
            </list>
          </item>
          <item>
            Assign the <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object to the <c>RetryLogicProvider</c> property.
          </item>
        </list>
        <note type="note">
          Detecting retryable exceptions is a vital part of the retry pattern. Before applying retry logic, it is important to investigate exceptions and choose a retry provider that best fits your scenario. First, log your exceptions and find transient faults.
        </note>
        <note type="note">
          The connection <b>timeout</b> restarts for each execution of a connection open. There is no timing overlap between these two actions.
        </note>
        <note type="note">
          The default retry logic provider is not enabled unless it is configured in an application configuration file. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/configurable-retry-logic-config-file-sqlclient">Configurable retry logic and configuration file</see>.
        </note>
      </remarks><example>
        <para>
          The following sample tries to open a connection to an invalid database to simulate a condition that the database service is temporarily unavailable . You should manually create the database while the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> tries to establish the connection.
        </para>
        <!-- SqlConfigurableRetryLogic_OpenConnection -->
        <code language="c#">
          using System;
          using Microsoft.Data.SqlClient;
          
          /// Detecting retriable exceptions is a vital part of the retry pattern.
          /// Before applying retry logic it is important to investigate exceptions and choose a retry provider that best fits your scenario.
          /// First, log your exceptions and find transient faults.
          /// The purpose of this sample is to illustrate how to use this feature and the condition might not be realistic.
          class RetryLogicSample
          {
              private const string DefaultDB = "Northwind";
              private const string CnnStringFormat = "Server=localhost; Initial Catalog={0}; Integrated Security=true; pooling=false;";
              private const string DropDatabaseFormat = "DROP DATABASE {0}";
          
              // For general use
              private static SqlConnection s_generalConnection = new SqlConnection(string.Format(CnnStringFormat, DefaultDB));
          
              static void Main(string[] args)
              {
                  // 1. Define the retry logic parameters
                  var options = new SqlRetryLogicOption()
                  {
                      NumberOfTries = 5,
                      MaxTimeInterval = TimeSpan.FromSeconds(20),
                      DeltaTime = TimeSpan.FromSeconds(1)
                  };
          
                  // 2. Create a retry provider
                  var provider = SqlConfigurableRetryFactory.CreateExponentialRetryProvider(options);
          
                  // define the retrying event to report the execution attempts
                  provider.Retrying += (object s, SqlRetryingEventArgs e) =&gt;
                      {
                          int attempts = e.RetryCount + 1;
                          Console.ForegroundColor = ConsoleColor.Yellow;
                          Console.WriteLine($"attempt {attempts} - current delay time:{e.Delay} \n");
                          Console.ForegroundColor = ConsoleColor.DarkGray;
                          if (e.Exceptions[e.Exceptions.Count - 1] is SqlException ex)
                          {
                              Console.WriteLine($"{ex.Number}-{ex.Message}\n");
                          }
                          else
                          {
                              Console.WriteLine($"{e.Exceptions[e.Exceptions.Count - 1].Message}\n");
                          }
          
                          // It is not a good practice to do time-consuming tasks inside the retrying event which blocks the running task.
                          // Use parallel programming patterns to mitigate it.
                          if (e.RetryCount == provider.RetryLogic.NumberOfTries - 1)
                          {
                              Console.WriteLine("This is the last chance to execute the command before throwing the exception.");
                              Console.WriteLine("Press Enter when you're ready:");
                              Console.ReadLine();
                              Console.WriteLine("continue ...");
                          }
                      };
          
                  // Open the general connection.
                  s_generalConnection.Open();
          
                  try
                  {
                      // Assume the database is being created and other services are going to connect to it.
                      RetryConnection(provider);
                  }
                  catch
                  {
                      // exception is thrown if connecting to the database isn't successful.
                      throw;
                  }
              }
          
              private static void ExecuteCommand(SqlConnection cn, string command)
              {
                  using var cmd = cn.CreateCommand();
                  cmd.CommandText = command;
                  cmd.ExecuteNonQuery();
              }
          
              private static void RetryConnection(SqlRetryLogicBaseProvider provider)
              {
                  // Change this if you already have a database with the same name in your database.
                  string dbName = "Invalid_DB_Open";
          
                  // Create a connection to an invalid database.
                  using var cnn = new SqlConnection(string.Format(CnnStringFormat, dbName));
                  // 3. Assign the `provider` to the connection
                  cnn.RetryLogicProvider = provider;
                  Console.WriteLine($"Connecting to the [{dbName}] ...");
                  // Manually execute the following command in SSMS to create the invalid database while the SqlConnection is attempting to connect to it.
                  // &gt;&gt; CREATE DATABASE Invalid_DB_Open;
                  Console.WriteLine($"Manually, run the 'CREATE DATABASE {dbName};' in the SQL Server before exceeding the {provider.RetryLogic.NumberOfTries} attempts.");
                  // the connection tries to connect to the database 5 times
                  Console.WriteLine("The first attempt, before getting into the retry logic.");
                  cnn.Open();
                  Console.WriteLine($"Connected to the [{dbName}] successfully.");
          
                  cnn.Close();
          
                  // Drop it after test
                  ExecuteCommand(s_generalConnection, string.Format(DropDatabaseFormat, dbName));
                  Console.WriteLine($"The [{dbName}] is removed.");
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.Dispose(System.Boolean)">
            <param name="disposing">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnection.CanCreateBatch">
            <summary>
        Gets a value that indicates whether this <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> instance supports the <see cref="T:System.Data.Common.DbBatch" /> class.
      </summary><value>
        <see langword="true" /> if this instance supports the <see cref="T:System.Data.Common.DbBatch" /> class; otherwise, <see langword="false" />. The default is <see langword="true" />.
      </value><remarks>
        ADO.net SQL provider implemented <see cref="T:System.Data.Common.DbBatch" /> and overrides <c>CanCreateBatch</c> property to return <see langword="true" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnection.CreateDbBatch">
            <summary>
        Returns a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlBatch" /> class that implements the <see cref="T:System.Data.Common.DbBatch" /> class.
      </summary><returns>
        A new instance of <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConnectionColumnEncryptionSetting">
            <summary>
        Note that these settings cannot be used to bypass encryption and gain access to plaintext data. For details, see <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted (Database Engine)</see>.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionColumnEncryptionSetting.Disabled">
            <summary>
        Specifies the connection does not use Always Encrypted. Should be used if no queries sent over the connection access encrypted columns.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionColumnEncryptionSetting.Enabled">
            <summary>
        Enables Always Encrypted functionality for the connection. Query parameters that correspond to encrypted columns will be transparently encrypted and query results from encrypted columns will be transparently decrypted.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConnectionOverrides">
            <summary>
        Specifies a value for Overrides.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionOverrides.None">
            <summary>
        No overrides.
      </summary><value>
        0
      </value>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlConnectionOverrides.OpenWithoutRetry">
            <summary>
        Disable transient fault handling during the initial <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Open" /> attempt.
      </summary><value>
        1
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder">
            <summary>
        Provides a simple way to create and manage the contents of connection strings used by the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> class.
      </summary><remarks>
        <para>
          The connection string builder lets developers programmatically create syntactically correct connection strings, and parse and rebuild existing connection strings, using properties and methods of the class. The connection string builder provides strongly typed properties corresponding to the known key/value pairs allowed by SQL Server. Developers needing to create connection strings as part of applications can use the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class to build and modify connection strings. The class also makes it easy to manage connection strings stored in an application configuration file.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> performs checks for valid key/value pairs. Therefore, you cannot use this class to create invalid connection strings; trying to add invalid pairs will throw an exception. The class maintains a fixed collection of synonyms and can translate from a synonym to the corresponding well-known key name. 
        </para>
        <para>
          For example, when you use the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Item[System.String]" /> property to retrieve a value, you can specify a string that contains any synonym for the key you need. For example, you can specify "Network Address", "addr", or any other acceptable synonym for this key within a connection string when you use any member that requires a string that contains the key name, such as the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Item[System.String]" /> property or the <see cref="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Remove(System.String)" /> method. See the <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> property for a full list of acceptable synonyms.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Item[System.String]" /> property handles tries to insert malicious entries. For example, the following code, using the default Item property (the indexer, in C#) correctly escapes the nested key/value pair:
        </para>
        <code language="vb">
          Dim builder As New Microsoft.Data.SqlClient.SqlConnectionStringBuilder
          builder("Data Source") = "(local)"
          builder("Integrated Security") = True
          builder("Initial Catalog") = "AdventureWorks;NewValue=Bad"
          Console.WriteLine(builder.ConnectionString)
        </code>
        <code language="c#">
          Microsoft.Data.SqlClient.SqlConnectionStringBuilder builder =
              new Microsoft.Data.SqlClient.SqlConnectionStringBuilder();
          builder["Data Source"] = "(local)";
          builder["Integrated Security"] = true;
          builder["Initial Catalog"] = "AdventureWorks;NewValue=Bad";
          Console.WriteLine(builder.ConnectionString);
        </code>
        <para>
          The result is the following connection string that handles the invalid value in a safe manner:
        </para>
        <code>
          Source=(local);Initial Catalog="AdventureWorks;NewValue=Bad"; Integrated Security=True
        </code>
      </remarks><example>
        <para>
          The following console application builds connection strings for a SQL Server database. The code uses a <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class to create the connection string, and then passes the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> instance to the constructor of the connection class. The example also parses an existing connection string and demonstrates various ways of manipulating the connection string's contents.
        </para>
        <note type="note">
          This example includes a password to demonstrate how <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> works with connection strings. In your applications, we recommend that you use Windows Authentication. If you must use a password, do not include a hard-coded password in your application.
        </note>
        <!-- SqlConnectionStringBuilder -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  // Create a new SqlConnectionStringBuilder and
                  // initialize it with a few name/value pairs.
                  SqlConnectionStringBuilder builder =
                      new SqlConnectionStringBuilder(GetConnectionString());
          
                  // The input connection string used the 
                  // Server key, but the new connection string uses
                  // the well-known Data Source key instead.
                  Console.WriteLine(builder.ConnectionString);
          
                  // Pass the SqlConnectionStringBuilder an existing 
                  // connection string, and you can retrieve and
                  // modify any of the elements.
                  builder.ConnectionString = "server=(local);integrated security=SSPI;
                    initial catalog=AdventureWorks";
          
                  // Now that the connection string has been parsed,
                  // you can work with individual items.
                  Console.WriteLine(builder.InitialCatalog);
                  builder.InitialCatalog = "Northwind";
          
                  // You can refer to connection keys using strings, 
                  // as well. When you use this technique (the default
                  // Item property in Visual Basic, or the indexer in C#),
                  // you can specify any synonym for the connection string key
                  // name.
                  builder["Server"] = ".";
                  builder["Connect Timeout"] = 1000;
                  builder["Trusted_Connection"] = true;
                  Console.WriteLine(builder.ConnectionString);
          
                  Console.WriteLine("Press Enter to finish.");
                  Console.ReadLine();
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file. 
                  return "Server=(local);Integrated Security=SSPI;" +
                         "Initial Catalog=AdventureWorks";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.#ctor(System.String)">
            <param name="connectionString">
        The basis for the object's internal connection information. Parsed into name/value pairs. Invalid key names raise <see cref="T:System.Collections.Generic.KeyNotFoundException" /> .
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class. The provided connection string provides the data for the instance's internal connection information.
      </summary><remarks>
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class provides a fixed internal collection of key/value pairs. Even if you supply only a small subset of the possible connection string values in the constructor, the object always provides default values for each key/value pair. When the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" /> property of the object is retrieved, the string contains only key/value pairs in which the value is not the default value for the item.
      </remarks><example>
        <para>
          The following example supplies a simple SQL Server connection string in the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> object's constructor, and then iterates through all the key/value pairs within the object. Note that the collection provides default values for each item. Also note that the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class converts synonyms for the well-known keys so that they are consistent with the well-known names.
        </para>
        <note type="note">
          This example includes a password to demonstrate how <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> works with connection strings. In your applications, we recommend that you use Windows Authentication. If you must use a password, do not include a hard-coded password in your application.
        </note>
        <!-- SqlConnectionStringBuilder3 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  try
                  {
                      string connectString = "Server=(local);Database=AdventureWorks;UID=ab;Pwd= a!Pass@@";
                      Console.WriteLine("Original: " + connectString);
                      SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);
                      Console.WriteLine("Modified: " + builder.ConnectionString);
                      
                      foreach (string key in builder.Keys)
                      {
                          Console.WriteLine(key + "=" + builder[key].ToString());
                      }
                      
                      Console.WriteLine("Press any key to finish.");
                      Console.ReadLine();
          
                  }
                  catch (System.Collections.Generic.KeyNotFoundException ex)
                  {
                      Console.WriteLine("KeyNotFoundException: " + ex.Message);
                  }
                  catch (System.FormatException ex)
                  {
                      Console.WriteLine("Format exception: " + ex.Message);
                  }
              }
          }
        </code>
      </example><exception cref="T:System.Collections.Generic.KeyNotFoundException">
        Invalid key name within the connection string.
      </exception><exception cref="T:System.FormatException">
        Invalid value within the connection string (specifically, when a Boolean or numeric value was expected but not supplied).
      </exception><exception cref="T:System.ArgumentException">
        The supplied <paramref name="connectionString" /> is not valid.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ApplicationIntent">
            <summary>
        Declares the application workload type when connecting to a database in an SQL Server Availability Group. You can set the value of this property with <see cref="T:Microsoft.Data.SqlClient.ApplicationIntent" />. For more information about SqlClient support for Always On Availability Groups, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/sqlclient-support-high-availability-disaster-recovery">SqlClient Support for High Availability, Disaster Recovery</see>.
      </summary><value>
        Returns the current value of the property.
      </value><remarks>
        <para>
          This property corresponds to the <c>Application Intent</c> and <c>ApplicationIntent</c> keys within the connection string.
        </para>
        <para>
          The default value is <c>ApplicationIntent.ReadWrite</c> .
        </para>
      </remarks><seealso href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ApplicationName">
            <summary>
        Gets or sets the name of the application associated with the connection string.
      </summary><value>
        The name of the application. If no name has been supplied, "Framework Microsoft SqlClient Data Provider" when running on .NET Framework and "Core Microsoft SqlClient Data Provider" otherwise.
      </value><remarks>
        <para>
          This property corresponds to the "Application Name" and "app" keys within the connection string.
        </para>
        <para>
          An application name can be 128 characters or fewer.
        </para>
      </remarks><example>
        <para>
          The following example creates a new <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> and assigns a connection string in the object's constructor. The code displays the parsed and recreated version of the connection string, and then modifies the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ApplicationName" /> property of the object. Finally, the code displays the new connection string, including the new key/value pair.
        </para>
        <!-- SqlConnectionStringBuilder_ApplicationName -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  try
                  {
                      string connectString = "Server=(local);Initial Catalog=AdventureWorks;" +
                          "Integrated Security=true";
                      SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);
                      Console.WriteLine("Original: " + builder.ConnectionString);
                      Console.WriteLine("ApplicationName={0}", builder.ApplicationName);
          
                      builder.ApplicationName = "My Application";
                      Console.WriteLine("Modified: " + builder.ConnectionString);
          
                      Console.WriteLine("Press any key to finish.");
                      Console.ReadLine();
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine(ex.Message);
                  }
              }
          }
        </code>
        <para>
          The sample displays the following text in the console window:
        </para>
        <code>
          Original: Data Source=(local);Initial Catalog=AdventureWorks;Integrated Security=True;ApplicationName="Core Microsoft SqlClient Data Provider"
          Modified: Data Source=(local);Initial Catalog=AdventureWorks;Integrated Security=True;Application Name="My Application"
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.AttachDBFilename">
            <summary>
        Gets or sets a string that contains the name of the primary data file. This includes the full path name of an attachable database.
      </summary><value>
        The value of the <see langword="AttachDBFilename" /> property, or <see cref="P:System.String.Empty" /> if no value has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "AttachDBFilename", "extended properties", and "initial file name" keys within the connection string. <c>AttachDBFilename</c> is only supported for primary data files with an .mdf extension.
        </para>
        <para>
          If the value of the AttachDBFileName key is specified in the connection string, the database is attached and becomes the default database for the connection. If this key is not specified and if the database was previously attached, the database will not be reattached. The previously attached database will be used as the default database for the connection. If this key is specified together with the AttachDBFileName key, the value of this key will be used as the alias. However, if the name is already used in another attached database, the connection will fail.
        </para>
        <para>
          The path may be absolute or relative by using the DataDirectory substitution string. If DataDirectory is used, the database file must exist within a subdirectory of the directory pointed to by the substitution string. <b>Note:</b> Remote server, HTTP, and UNC path names are not supported.
        </para>
        <para>
          The database name must be specified with the keyword 'database' (or one of its aliases) as in the following: <c>"AttachDbFileName=|DataDirectory|\data\YourDB.mdf;integrated security=true;database=YourDatabase"</c> An error will be generated if a log file exists in the same directory as the data file and the 'database' keyword is used when attaching the primary data file. In this case, remove the log file. Once the database is attached, a new log file will be automatically generated based on the physical path.
        </para>
      </remarks><example>
        <para>
          The following example creates a new <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> instance, and sets the <c>AttachDBFilename</c> property in order to specify the name of an attached data file.
        </para>
        <!-- SqlConnectionStringBuilder_AttachDBFilename -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  try
                  {
                      string connectString =
                          "Server=(local);" +
                          "Integrated Security=true";
                      SqlConnectionStringBuilder builder =
                          new SqlConnectionStringBuilder(connectString);
                      Console.WriteLine("Original: " + builder.ConnectionString);
                      Console.WriteLine("AttachDBFileName={0}", builder.AttachDBFilename);
          
                      builder.AttachDBFilename = @"C:\MyDatabase.mdf";
                      Console.WriteLine("Modified: " + builder.ConnectionString);
          
                      using (SqlConnection connection = new SqlConnection(builder.ConnectionString))
                      {
                          connection.Open();
                          // Now use the open connection.
                          Console.WriteLine("Database = " + connection.Database);
                      }
                      Console.WriteLine("Press any key to finish.");
                      Console.ReadLine();
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine(ex.Message);
                  }
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception><seealso href="https://learn.microsoft.com/sql/connect/ado-net/connection-strings">
        Working with Connection Strings
      </seealso><seealso href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Authentication">
            <summary>
        Gets or sets the authentication method used for <see href="https://learn.microsoft.com/azure/azure-sql/database/authentication-aad-overview#connect-with-microsoft-entra-to-azure-sql-resources">Connect with Microsoft Entra to Azure SQL resources</see>.
      </summary><value>
        The authentication method of the connection string.
      </value><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/azure-active-directory-authentication">Connect to Azure SQL with Microsoft Entra authentication and SqlClient</see>.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ColumnEncryptionSetting">
            <summary>
        Gets or sets the column encryption settings for the connection string builder.
      </summary><value>
        The column encryption settings for the connection string builder.This property enables or disables <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see> functionality for the connection.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.CommandTimeout">
            <summary>
        The default wait time (in seconds) before terminating the attempt to execute a command and generating an error. The default is 30 seconds.
      </summary><value>
        The time in seconds to wait for the command to execute. The default is 30 seconds.
      </value><remarks>
        <para>
          This property corresponds to the <c>Command Timeout</c> key within the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> connection string.
        </para>
        <para>
          Valid values are greater than or equal to 0 and less than or equal to 2147483647.
        </para>
      </remarks><exception cref="T:System.ArgumentException">
        The value set is less than 0.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ConnectRetryCount">
            <summary>
        The number of reconnections attempted after identifying that there was an idle connection failure. This must be an integer between 0 and 255. The default value for non Azure endpoints is 1. For Azure SQL endpoints, the default is 2. Starting in version 5.x, for Azure SQL serverless or on demand endpoints, the default is 5 to improve connection success for connections to an idle or paused instance. Set to 0 to disable reconnecting on idle connection failures. An <see cref="T:System.ArgumentException" /> will be thrown if set to a value outside the allowed range.
      </summary><value>
        The number of reconnections attempted after identifying that there was an idle connection failure.
      </value><remarks>
        <para>
          This property corresponds to the <c>Connect Retry Count</c> key within the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> connection string.
        </para>
        <note type="note">
          Since version 5.x the default value for none Azure endpoints is 1 and for Azure SQL and Azure Synapse has increased to 2 and 5 to improve the recovery against on high demand Azure endpoints. It should be detected first, and Synapse could be detected as a regular Azure SQL DB endpoint.
        </note>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ConnectRetryInterval">
            <summary>
        Amount of time (in seconds) between each reconnection attempt after identifying that there was an idle connection failure. This must be an integer between 1 and 60. The default is 10 seconds.
      </summary><value>
        Amount of time (in seconds) between each reconnection attempt after identifying that there was an idle connection failure.
      </value><exception cref="T:System.ArgumentException">
        Value is outside the allowed range.
      </exception><remarks>
        <para>
          This property corresponds to the "Connect Retry Interval" key within the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> connection string.
        </para>
        <para>
          This value is applied after the first reconnection attempt. When a broken connection is detected, the client immediately attempts to reconnect; this is the first reconnection attempt and only occurs if <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ConnectRetryCount" /> is greater than 0. If the first reconnection attempt fails and <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ConnectRetryCount" /> is greater than 1, the client waits <c>ConnectRetryInterval</c> to try the second and subsequent reconnection attempts.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ConnectTimeout">
            <summary>
        Gets or sets the length of time (in seconds) to wait for a connection to the server before terminating the attempt and generating an error.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ConnectTimeout" /> property, or 15 seconds if no value has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Connect Timeout", "connection timeout", and "timeout" keys within the connection string.
        </para>
        <para>
          When opening a connection to a Azure SQL Database, set the connection timeout to 30 seconds. Valid values are greater than or equal to 0 and less than or equal to 2147483647.
        </para>
      </remarks><example>
        <para>
          The following example first displays the contents of a connection string that does not specify the "Connect Timeout" value, sets the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ConnectTimeout" /> property, and then displays the new connection string.
        </para>
        <!-- SqlConnectionStringBuilder_ConnectTimeout -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  try
                  {
                      string connectString =
                          "Server=(local);Initial Catalog=AdventureWorks;" +
                          "Integrated Security=true";
                      SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);
                      Console.WriteLine("Original: " + builder.ConnectionString);
                      Console.WriteLine("ConnectTimeout={0}",
                          builder.ConnectTimeout);
                      builder.ConnectTimeout = 100;
                      Console.WriteLine("Modified: " + builder.ConnectionString);
          
                      Console.WriteLine("Press any key to finish.");
                      Console.ReadLine();
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine(ex.Message);
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.CurrentLanguage">
            <summary>
        Gets or sets the language used for database server warning or error messages..
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.CurrentLanguage" /> property, or <c>string.Empty</c> if no value has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Current Language" and "language" keys within the connection string.
        </para>
        <para>
          The language name can be 128 characters or fewer.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.DataSource">
            <summary>
        Gets or sets the name or network address of the instance of SQL Server to connect to.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.DataSource" /> property, or <see langword="String.Empty" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Data Source", "server", "address", "addr", and "network address" keys within the connection string. Regardless of which of these values has been supplied within the supplied connection string, the connection string created by the <c>SqlConnectionStringBuilder</c> will use the well-known "Data Source" key. The port number can be specified after the server name: <c>server=tcp:servername,portnumber</c> .
        </para>
        <para>
          When specifying a local instance, always use (local). To force a protocol, add one of the following prefixes: <c>np:(local),  tcp:(local), lpc:(local)</c> .
        </para>
        <para>
          You can also connect to a LocalDB database as follows: <c>server=(localdb)\\myInstance</c> . For more information about LocalDB, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/sqlclient-support-localdb">SqlClient Support for LocalDB</see> . <b>Data Source</b> must use the TCP format or the Named Pipes format. TCP format is as follows:
        </para>
        <list type="bullet">
          <item><c>tcp:\&lt;host name&gt;\\&lt;instance name&gt;</c></item>
          <item><c>tcp:\&lt;host name&gt;,\&lt;TCP/IP port number&gt;</c></item>
        </list>
        <para>
          The TCP format must start with the prefix "tcp:" and is followed by the database instance, as specified by a host name and an instance name. This format is not applicable when connecting to Azure SQL Database. TCP is automatically selected for connections to Azure SQL Database when no protocol is specified.
        </para>
        <para>
          The host name MUST be specified in one of the following ways:   
        </para>
        <list type="bullet">
          <item>NetBIOSName</item>
          <item>IPv4Address</item>
          <item>IPv6Address</item>
        </list>
        <para>
          The instance name is used to resolve to a particular TCP/IP port number on which a database instance is hosted. Alternatively, specifying a TCP/IP port number directly is also allowed. If both instance name and port number are not present, the default database instance is used.
        </para>
        <para>
          The Named Pipes format is as follows: -   
        </para>
        <list type="bullet">
          <item><c>np:\\\\&lt;host name&gt;\pipe\\&lt;pipe name&gt;</c></item>
        </list>
        <para>
          The Named Pipes format MUST start with the prefix "np:" and is followed by a named pipe name.
        </para>
        <para>
          The host name MUST be specified in one of the following ways:
        </para>
        <list type="bullet">
          <item>NetBIOSName</item>
          <item>IPv4Address</item>
          <item>IPv6Address</item>
        </list>
        <para>
          The pipe name is used to identify the database instance to which the .NET application will connect.
        </para>
        <para>
          If the value of the <b>Network</b> key is specified, the prefixes "tcp:" and "np:" should not be specified. <b>Note:</b> You can force the use of TCP instead of shared memory, either by prefixing <b>tcp:</b> to the server name in the connection string, or by using <b>localhost</b>.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates that the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class converts synonyms for the "Data Source" connection string key into the well-known key:
        </para>
        <!-- SqlConnectionStringBuilder_DataSource -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(
                      "Network Address=(local);Integrated Security=SSPI;" +
                      "Initial Catalog=AdventureWorks");
          
                  // Display the connection string, which should now 
                  // contain the "Data Source" key, as opposed to the 
                  // supplied "Network Address".
                  Console.WriteLine(builder.ConnectionString);
          
                  // Retrieve the DataSource property.
                  Console.WriteLine("DataSource = " + builder.DataSource);
          
                  Console.WriteLine("Press any key to continue.");
                  Console.ReadLine();
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.AttestationProtocol">
            <summary>
        Gets or sets the value of Attestation Protocol.
      </summary><value>
        The attestation protocol.
      </value><remarks>
        When no value is specified, secure enclaves are disabled on the connection.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.EnclaveAttestationUrl">
            <summary>
        Gets or sets the enclave attestation URL to be used with enclave based Always Encrypted.
      </summary><value>
        The enclave attestation URL.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.IPAddressPreference">
            <summary>
        Gets or sets the IP address family preference when establishing TCP connections.
      </summary><returns>
        Returns the IP address preference.
      </returns><remarks>
        If <c>Transparent Network IP Resolution</c> (in .NET Framework) or <c>Multi Subnet Failover</c> is set to true, this setting has no effect.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Encrypt">
            <summary>
        Gets or sets a <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> value since version 5.0 or a <see cref="T:System.Boolean" /> value for the earlier versions that indicates whether TLS encryption is required for all data sent between the client and server.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Encrypt" /> property.
      </value><remarks>
        <para>
          This property corresponds to the "Encrypt" key within the connection string.
        </para>
        <para>
          When <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TrustServerCertificate" /> is <see langword="false" /> and <b>Encrypt</b> is <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" />, <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Strict" /> or <see langword="true" />, the server name (or IP address) in a server's TLS certificate must exactly match the server name (or IP address) specified in the connection string. Otherwise, the connection attempt will fail. For information about support for certificates whose subject starts with a wildcard character (*), see <see href="https://learn.microsoft.com/sql/database-engine/configure-windows/enable-encrypted-connections-to-the-database-engine#certificate-requirements">Enable encrypted connections to the Database Engine</see> .
        </para>
        <note type="note">
          Starting from <b>version 4.0</b>, the default value of the property <b>Encrypt</b> is set to <see langword="true" /> while it is <see langword="false" /> for earlier versions.
        </note>
        <note type="note">
          Starting from <b>version 5.0</b>, the data type is updated to <see cref="T:Microsoft.Data.SqlClient.SqlConnectionEncryptOption" /> , and the default value of the <c>Encrypt</c> property is set to <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" /> .
        </note>
      </remarks><seealso href="https://learn.microsoft.com/sql/connect/ado-net/connection-strings">
        Working with Connection Strings
      </seealso><seealso href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.HostNameInCertificate">
            <summary>
        Gets or sets the host name to use when validating the server certificate for the connection. When not specified, the server name from the <c>Data Source</c> is used for certificate validation. (Only available in v5.0+)
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.HostNameInCertificate" /> property, or <see langword="String.Empty" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "HostNameInCertificate" and "Host Name in Certificate" keys within the connection string.
        </para>
        <note type="note">
          This property only applies when using <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Encrypt" /> in <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" /> or <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Strict" /> mode, otherwise it is ignored.
        </note>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ServerCertificate">
            <summary>
        Gets or sets the path to a certificate file to match against the SQL Server TLS/SSL certificate for the connection. The accepted certificate formats are PEM, DER, and CER. If specified, the SQL Server certificate is checked by verifying if the `ServerCertificate` provided is an exact match. (Only available in v5.1+)
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ServerCertificate" /> property, or <c>string.Empty</c> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "ServerCertificate" and "Server Certificate" keys within the connection string.
        </para>
        <note type="note">
          This property only applies when using <c>Encrypt</c> in <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Mandatory" /> or <see cref="P:Microsoft.Data.SqlClient.SqlConnectionEncryptOption.Strict" /> mode, otherwise it is ignored.
        </note>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Enlist">
            <summary>
        Gets or sets a Boolean value that indicates whether the SQL Server connection pooler automatically enlists the connection in the creation thread's current transaction context.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Enlist" /> property, or <see langword="true" /> if none has been supplied.
      </value><remarks>
        This property corresponds to the "Enlist" key within the connection string.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.FailoverPartner">
            <summary>
        Gets or sets the name or address of the partner server to connect to if the primary server is down.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.FailoverPartner" /> property, or <see langword="String.Empty" /> if none has been supplied.
      </value><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception><remarks>
        <para>
          If the value of this key is "", then <b>Initial Catalog</b> must be present, and its value must not be "".
        </para>
        <para>
          The server name can be 128 characters or fewer.
        </para>
        <para>
          If you specify a failover partner but the failover partner server is not configured for database mirroring and the primary server (specified with the Server keyword) is not available, then the connection will fail.
        </para>
        <para>
          If you specify a failover partner and the primary server is not configured for database mirroring, the connection to the primary server (specified with the Server keyword) will succeed if the primary server is available.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.FailoverPartnerSPN">
            <summary>
        Gets or sets the service principal name (SPN) of the failover partner for the connection.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.FailoverPartnerSPN" /> property, or <see langword="String.Empty" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "FailoverPartnerSPN" and "Failover Partner SPN" keys within the connection string.
        </para>
        <note type="note">
          This property only applies when using Integrated Security mode, otherwise it is ignored.
        </note>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.InitialCatalog">
            <summary>
        Gets or sets the name of the database associated with the connection.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.InitialCatalog" /> property, or <c>string.Empty</c> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Initial Catalog" and "database" keys within the connection string.
        </para>
        <para>
          The database name can be 128 characters or fewer.
        </para>
      </remarks><example>
        <para>
          The following example creates a simple connection string and then uses the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> class to add the name of the database to the connection string. The code displays the contents of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.InitialCatalog" /> property, just to verify that the class was able to convert from the synonym ("Database") to the appropriate property value.
        </para>
        <!-- SqlConnectionStringBuilder_InitialCatalog -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  try
                  {
                      string connectString = "Data Source=(local);" +
                          "Integrated Security=true";
          
                      SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);
                      Console.WriteLine("Original: " + builder.ConnectionString);
          
                      // Normally, you could simply set the InitialCatalog
                      // property of the SqlConnectionStringBuilder object. This
                      // example uses the default Item property (the C# indexer)
                      // and the "Database" string, simply to demonstrate that
                      // setting the value in this way results in the same
                      // connection string:
                      builder["Database"] = "AdventureWorks";
                      Console.WriteLine("builder.InitialCatalog = " + builder.InitialCatalog);
                      Console.WriteLine("Modified: " + builder.ConnectionString);
          
                      using (SqlConnection connection = new SqlConnection(builder.ConnectionString))
                      {
                          connection.Open();
                          // Now use the open connection.
                          Console.WriteLine("Database = " + connection.Database);
                      }
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine(ex.Message);
                  }
          
                  Console.WriteLine("Press any key to finish.");
                  Console.ReadLine();
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.IntegratedSecurity">
            <summary>
        Gets or sets a Boolean value that indicates whether User ID and Password are specified in the connection (when <see langword="false" /> ) or whether the current Windows account credentials are used for authentication (when <see langword="true" /> ).
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.IntegratedSecurity" /> property, or <see langword="false" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Integrated Security" and "trusted_connection" keys within the connection string.
        </para>
        <para>
          If User ID and Password are specified and Integrated Security is set to true, the User ID and Password will be ignored and Integrated Security will be used. <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> is a more secure way to specify credentials for a connection that uses SQL Server Authentication ( <c>Integrated Security=false</c> ). 
        </para>
      </remarks><example>
        <para>
          The following example converts an existing connection string from using SQL Server Authentication to using integrated security. The example does its work by removing the username and password from the connection string and then setting the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.IntegratedSecurity" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> object.
        </para>
        <note type="note">
          This example includes a password to demonstrate how <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> works with connection strings. In your applications, we recommend that you use Windows Authentication. If you must use a password, do not include a hard-coded password in your application.
        </note>
        <!-- SqlConnectionStringBuilder_IntegratedSecurity -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  try
                  {
                      string connectString =
                          "Data Source=(local);Integrated Security=SSPI" +
                          "Initial Catalog=AdventureWorks";
          
                      SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);
                      Console.WriteLine("Original: " + builder.ConnectionString);
          
                      // Use the Remove method
                      // in order to reset the user ID and password back to their
                      // default (empty string) values. Simply setting the 
                      // associated property values to an empty string won't
                      // remove them from the connection string; you must
                      // call the Remove method.
                      builder.Remove("User ID");
                      builder.Remove("Password");
          
                      // Turn on integrated security:
                      builder.IntegratedSecurity = true;
          
                      Console.WriteLine("Modified: " + builder.ConnectionString);
          
                      using (SqlConnection connection = new SqlConnection(builder.ConnectionString))
                      {
                          connection.Open();
                          // Now use the open connection.
                          Console.WriteLine("Database = " + connection.Database);
                      }
          
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine(ex.Message);
                  }
          
                  Console.WriteLine("Press any key to finish.");
                  Console.ReadLine();
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.IsFixedSize">
            <summary>
        Gets a value that indicates whether the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> has a fixed size.
      </summary><value>
        <see langword="true" /> in every case, because the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> supplies a fixed-size collection of key/value pairs.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/connection-strings">
        Working with Connection Strings
      </seealso><seealso href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Item(System.String)">
            <param name="keyword">
        The key of the item to get or set.
      </param><summary>
        Gets or sets the value associated with the specified key. In C#, this property is the indexer.
      </summary><value>
        The value associated with the specified key.
      </value><remarks>
        Because the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> contains a fixed-size dictionary, trying to add a key that does not exist within the dictionary throws a <see cref="T:System.Collections.Generic.KeyNotFoundException" />.
      </remarks><example>
        <para>
          The following code, in a console application, creates a new <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> and adds key/value pairs to its connection string, using the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Item[System.String]" /> property.
        </para>
        <!-- SqlConnectionStringBuilder2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();
                  builder["Data Source"] = "(local)";
                  builder["Integrated Security"] = true;
                  builder["Initial Catalog"] = "AdventureWorks";
          
                  // Overwrite the existing value for the Data Source value.
                  builder["Data Source"] = ".";
          
                  Console.WriteLine(builder.ConnectionString);
                  Console.WriteLine();
                  Console.WriteLine("Press Enter to continue.");
                  Console.ReadLine();
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        <paramref name="keyword" /> is a null reference (<see langword="Nothing" /> in Visual Basic).
      </exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">
        Tried to add a key that does not exist within the available keys.
      </exception><exception cref="T:System.FormatException">
        Invalid value within the connection string (specifically, a Boolean or numeric value was expected but not supplied).
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Keys">
            <summary>
        Gets an <see cref="T:System.Collections.ICollection" /> that contains the keys in the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" />.
      </summary><value>
        An <see cref="T:System.Collections.ICollection" /> that contains the keys in the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" />.
      </value><remarks>
        The order of the values in the <see cref="T:System.Collections.ICollection" /> is unspecified, but it is the same order as the associated values in the <see cref="T:System.Collections.ICollection" /> returned by the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Values" /> property.
      </remarks><example>
        <para>
          The following console application example creates a new <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" />. The code loops through the <see cref="T:System.Collections.ICollection" /> returned by the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Keys" /> property displaying the key/value pairs.
        </para>
        <!-- SqlConnectionStringBuilder_Keys -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();
                  builder.DataSource = "(local)";
                  builder.IntegratedSecurity = true;
                  builder.InitialCatalog = "AdventureWorks";
          
                  // Loop through the collection of keys, displaying 
                  // the key and value for each item:
                  foreach (string key in builder.Keys)
                  {
                      Console.WriteLine("{0}={1}", key, builder[key]);
                  }
          
                  Console.WriteLine();
                  Console.WriteLine("Press Enter to continue.");
                  Console.ReadLine();
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Values" /><seealso cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Item(System.String)" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.LoadBalanceTimeout">
            <summary>
        Gets or sets the minimum time, in seconds, for the connection to live in the connection pool before being destroyed.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.LoadBalanceTimeout" /> property, or 0 if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Load Balance Timeout" and "connection lifetime" keys within the connection string.
        </para>
        <para>
          When a connection is returned to the pool, its creation time is compared with the current time, and the connection is destroyed if that time span (in seconds) exceeds the value specified by <c>Connection Lifetime</c>. This is useful in clustered configurations to force load balancing between a running server and a server just brought online.
        </para>
        <para>
          A value of zero (0) causes pooled connections to have the maximum connection timeout.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.MaxPoolSize">
            <summary>
        Gets or sets the maximum number of connections allowed in the connection pool for this specific connection string.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.MaxPoolSize" /> property, or 100 if none has been supplied.
      </value><remarks>
        This property corresponds to the "Max Pool Size" key within the connection string.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.MinPoolSize">
            <summary>
        Gets or sets the minimum number of connections allowed in the connection pool for this specific connection string.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.MinPoolSize" /> property, or 0 if none has been supplied.
      </value><remarks>
        This property corresponds to the "Min Pool Size" key within the connection string.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.MultipleActiveResultSets">
            <summary>
        When true, an application can maintain multiple active result sets (MARS). When false, an application must process or cancel all result sets from one batch before it can execute any other batch on that connection. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/multiple-active-result-sets-mars">Multiple Active Result Sets (MARS)</see>.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.MultipleActiveResultSets" /> property, or <see langword="false" /> if none has been supplied.
      </value><remarks>
        This property corresponds to the "Multiple Active Result Sets" key within the connection string.
      </remarks><example>
        <para>
          The following example explicitly enables the Multiple Active Result Sets feature.
        </para>
        <!-- SqlConnectionStringBuilder_MultipleActiveResultSets -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();
                  builder.DataSource = "(local)";
                  builder.IntegratedSecurity = true;
                  builder.InitialCatalog = "AdventureWorks";
          
                  // The connection does not allow multiple active result sets
                  // by default, so this line of code explicitly
                  // enables this feature. Note that this feature is 
                  // only available when programming against SQL Server 2005
                  // or later.
                  builder.MultipleActiveResultSets = true;
          
                  Console.WriteLine(builder.ConnectionString);
                  Console.WriteLine();
          
                  Console.WriteLine("Press Enter to continue.");
                  Console.ReadLine();
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.MultiSubnetFailover">
            <summary>
        If your application is connecting to an AlwaysOn availability group (AG) on different subnets, setting <c>MultiSubnetFailover=true</c> provides faster detection of and connection to the (currently) active server. For more information about SqlClient support for Always On Availability Groups, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/sqlclient-support-high-availability-disaster-recovery">SqlClient Support for High Availability, Disaster Recovery</see>.
      </summary><value>
        Returns <see cref="T:System.Boolean" /> indicating the current value of the property.
      </value><remarks>
        Always specify <c>multiSubnetFailover=True</c> when connecting to the availability group listener of a SQL Server 2012 (or later) availability group or a SQL Server 2012 (or later) Failover Cluster Instance.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.PacketSize">
            <summary>
        Gets or sets the size in bytes of the network packets used to communicate with an instance of SQL Server.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.PacketSize" /> property, or 8000 if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Packet Size" key within the connection string.
        </para>
        <para>
          The packet size can be greater than or equal to 512 and less than or equal to 32768.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Password">
            <summary>
        Gets or sets the password for the SQL Server account.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Password" /> property, or <see langword="String.Empty" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Password" and "pwd" keys within the connection string.
        </para>
        <para>
          Setting this property is not recommended. To maintain a high level of security, we strongly recommend that you use the <c>Integrated Security</c> or <c>Trusted_Connection</c> keyword instead. <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> is a more secure way to specify credentials for a connection that uses SQL Server Authentication.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Password" /> has not been set, and you retrieve the value, the return value is <see cref="P:System.String.Empty" />. To reset the password for the connection string, pass null to the Item property.
        </para>
        <para>
          The password must be 128 characters or fewer.
        </para>
      </remarks><example>
        <para>
          The following example shows how to set <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Password" />.
        </para>
        <!-- SqlConnectionStringBuilder_Password -->
        <code language="c#">
          using System;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              public static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();
          
                  builder["Password"] = null;
                  string aa = builder.Password;
                  Console.WriteLine(aa.Length);
          
                  builder["Password"] = "??????";
                  aa = builder.Password;
                  Console.WriteLine(aa.Length);
          
                  try
                  {
                      builder.Password = null;
                  }
                  catch (ArgumentNullException e)
                  {
                      Console.WriteLine("{0}", e);
                  }
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        The password was incorrectly set to null.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.PersistSecurityInfo">
            <summary>
        Gets or sets a Boolean value indicating if security-sensitive information, such as the password or access token, should be returned as part of the connection string on a connection created with this <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> after that connection has ever been in an open state. This property should only be set to <see langword="true" /> if your application has a specific need to read the password out of an already-opened database connection. The default value of <see langword="false" /> is the more secure setting; using <see langword="true" /> for this property opens your application to security risks such as accidentally logging or tracing the database password.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.PersistSecurityInfo" /> property, or <see langword="false" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Persist Security Info" and "persistsecurityinfo" keys within the connection string.
        </para>
        <para>
          Resetting the connection string resets all connection string values including the password.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.PoolBlockingPeriod">
            <summary>
        The blocking period behavior for a connection pool.
      </summary><value>
        The available blocking period settings.
      </value><remarks>
        <para>
          This property corresponds to the "Pool Blocking Period" key within the connection string.
        </para>
        <para>
          When connection pooling is enabled and a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the "blocking period". If the application attempts to connect within the blocking period, the first exception will be thrown again. Subsequent failures after a blocking period ends will result in a new blocking period that is twice as long as the previous blocking period, up to a maximum of one minute.
        </para>
        <para>
          Attempting to connect to Azure SQL databases can fail with transient errors which are typically recovered within a few seconds. However, with the connection pool blocking period behavior, you may not be able to reach your database for extensive periods even though the database is  available. This is especially problematic for apps that need to render fast. The <b>PoolBlockingPeriod</b> enables you to select the blocking period best suited for your app. See the <see cref="T:Microsoft.Data.SqlClient.PoolBlockingPeriod" /> enumeration for available settings.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Pooling">
            <summary>
        Gets or sets a Boolean value that indicates whether the connection will be pooled or explicitly opened every time that the connection is requested.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Pooling" /> property, or <see langword="true" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Pooling" key within the connection string.
        </para>
        <para>
          Connections are considered the same if they have the same connection string. Different connections have different connection strings.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Replication">
            <summary>
        Gets or sets a Boolean value that indicates whether replication is supported using the connection.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Replication" /> property, or false if none has been supplied.
      </value><remarks>
        This property corresponds to the "Replication" key within the connection string.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ServerSPN">
            <summary>
        Gets or sets the service principal name (SPN) of the data source.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ServerSPN" /> property, or <see langword="String.Empty" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "ServerSPN" and "Server SPN" keys within the connection string.
        </para>
        <note type="note">
          This property only applies when using Integrated Security mode, otherwise it is ignored.
        </note>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding">
            <summary>
        Gets or sets a string value that indicates how the connection maintains its association with an enlisted <see langword="System.Transactions" /> transaction.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding" /> property, or <c>Implicit Unbind</c> if none has been supplied.
      </value><remarks>
        <para>
          The Transaction Binding keywords in a <see cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" /> control how a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> binds to an enlisted <see cref="T:System.Transactions.Transaction" />.
        </para>
        <para>
          The following table shows the possible values for the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding" /> property:
        </para>
        <list type="table">
          <listheader>
            <term>Value</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>Implicit Unbind</term>
            <description>
              The default. Causes the connection to detach from the transaction when it ends. After detaching, additional requests on the connection are performed in autocommit mode. The <see cref="P:System.Transactions.Transaction.Current" /> property is not checked when executing requests while the transaction is active. After the transaction has ended, additional requests are performed in autocommit mode.
            </description>
          </item>
          <item>
            <term>Explicit Unbind</term>
            <description>
              Causes the connection to remain attached to the transaction until the connection is closed or until <see cref="M:Microsoft.Data.SqlClient.SqlConnection.EnlistTransaction(System.Transactions.Transaction)" /> is called with a <see langword="null" /> (<c>Nothing</c> in Visual Basic) value. An <see cref="T:System.InvalidOperationException" /> is thrown if <see cref="P:System.Transactions.Transaction.Current" /> is not the enlisted transaction or if the enlisted transaction is not active. This behavior enforces the strict scoping rules required for <see cref="T:System.Transactions.TransactionScope" /> support.
            </description>
          </item>
        </list>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TrustServerCertificate">
            <summary>
        Gets or sets a value that indicates whether the channel will be encrypted while bypassing walking the certificate chain to validate trust.
      </summary><value>
        A boolean. The default is <see langword="false" />.
      </value><remarks>
        <para>
          This property corresponds to the "Trust Server Certificate" and "TrustServerCertificate" keys within the connection string.
        </para>
        <para>
          When <c>Trust Server Certificate</c> is set to <see langword="true" />, the transport layer will use TLS to encrypt the channel and bypass walking the certificate chain to validate trust. If <c>Trust Server Certificate</c> is set to <see langword="true" /> and encryption is enforced by target server, the encryption level specified on the server will be used even if <c>Encrypt</c> is set to <see langword="false" /> . The connection will fail otherwise.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/encryption-hierarchy">Encryption Hierarchy</see> and <see href="https://learn.microsoft.com/sql/relational-databases/native-client/features/using-encryption-without-validation">Using Encryption Without Validation</see>.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TypeSystemVersion">
            <summary>
        Gets or sets a string value that indicates the type system the application expects.
      </summary><value>
        The following table shows the possible values for the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TypeSystemVersion" /> property:
        <list type="table">
          <listheader>
            <term>Value</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>SQL Server 2005</term>
            <description>Uses the SQL Server 2005 type system. No conversions are made for the current version of ADO.NET.</description>
          </item>
          <item>
            <term>SQL Server 2008</term>
            <description>Uses the SQL Server 2008 type system.</description>
          </item>
          <item>
            <term>Latest</term>
            <description>
              Use the latest version than this client-server pair can handle. This will automatically move forward as the client and server components are upgraded.
            </description>
          </item>
        </list>
      </value><remarks>
        The <c>TypeSystemVersion</c> property can be used to specify a down-level version of SQL Server for applications written against that version. This avoids possible problems with incompatible types in a newer version of SQL Server that may cause the application to break.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.UserID">
            <summary>
        Gets or sets the user ID to be used when connecting to SQL Server.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.UserID" /> property, or <c>string.Empty</c> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "User ID", "user", and "uid" keys within the connection string.
        </para>
        <para>
          Setting this property is not recommended. To maintain a high level of security, we strongly recommend that you use the <c>Integrated Security</c> or <c>Trusted_Connection</c> keywords instead. <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> is a more secure way to specify credentials for a connection that uses SQL Server Authentication.
        </para>
        <para>
            The user ID must be 128 characters or fewer.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" />.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.UserInstance">
            <summary>
        Gets or sets a value that indicates whether to redirect the connection from the default SQL Server Express instance to a runtime-initiated instance running under the account of the caller.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.UserInstance" /> property, or <see langword="false" /> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "User Instance" key within the connection string.
        </para>
        <note type="note">
          This feature is available only with the SQL Server Express Edition. For more information on user instances, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/sql-server-express-user-instances">SQL Server Express User Instances</see>.
        </note>
      </remarks><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Values">
            <summary>
        Gets an <see cref="T:System.Collections.ICollection" /> that contains the values in the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> .
      </summary><value>
        An <see cref="T:System.Collections.ICollection" /> that contains the values in the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> .
      </value><remarks>
        The order of the values in the <see cref="T:System.Collections.ICollection" /> is unspecified, but it is the same order as the associated keys in the <see cref="T:System.Collections.ICollection" /> returned by the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Keys" /> property. Because each instance of the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> always contains the same fixed set of keys, the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Values" /> property always returns the values corresponding to the fixed set of keys, in the same order as the keys.
      </remarks><example>
        <para>
          The following example first creates a new <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" />, and then iterates through all the values within the object.
        </para>
        <!-- SqlConnectionStringBuilder_Values -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(GetConnectionString());
          
                  // Loop through each of the values, displaying the contents.
                  foreach (object value in builder.Values)
                  {
                      Console.WriteLine(value);
                  }
          
                  Console.WriteLine("Press any key to continue.");
                  Console.ReadLine();
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file. 
                  return "Data Source=(local);Integrated Security=SSPI;" +
                      "Initial Catalog=AdventureWorks";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Keys" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.WorkstationID">
            <summary>
        Gets or sets the name of the workstation connecting to SQL Server.
      </summary><value>
        The value of the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.WorkstationID" /> property, or <c>string.Empty</c> if none has been supplied.
      </value><remarks>
        <para>
          This property corresponds to the "Workstation ID" and "wsid" keys within the connection string.
        </para>
        <para>
          The ID must be 128 characters or fewer.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        To set the value to null, use <see cref="F:System.DBNull.Value" /> .
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Clear">
            <summary>
        Clears the contents of the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> instance.
      </summary><remarks>
        The <see cref="M:System.Data.Common.DbConnectionStringBuilder.Clear" /> method removes all key/value pairs from the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> , and resets all corresponding properties. This includes setting the <see cref="P:System.Data.Common.DbConnectionStringBuilder.Count" /> property to 0, and setting the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" /> property to an empty string.
      </remarks><example>
        <para>
          The following example demonstrates calling the <see cref="M:System.Data.Common.DbConnectionStringBuilder.Clear" /> method. This example populates the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> with some key/value pairs, and then calls the <see cref="M:System.Data.Common.DbConnectionStringBuilder.Clear" /> method and shows the results.
        </para>
        <!-- SqlConnectionStringBuilder_Clear -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();
                  builder.DataSource = "(local)";
                  builder.IntegratedSecurity = true;
                  builder.InitialCatalog = "AdventureWorks";
                  Console.WriteLine("Initial connection string: " + builder.ConnectionString);
          
                  builder.Clear();
                  Console.WriteLine("After call to Clear, count = " + builder.Count);
                  Console.WriteLine("Cleared connection string: " + builder.ConnectionString);
                  Console.WriteLine();
          
                  Console.WriteLine("Press Enter to continue.");
                  Console.ReadLine();
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ContainsKey(System.String)">
            <param name="keyword">
        The key to locate in the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> .
      </param><summary>
        Determines whether the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> contains a specific key.
      </summary><returns>
        <see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> contains an element that has the specified key; otherwise, <see langword="false" />.
      </returns><remarks>
        <para>
          Because the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> contains a fixed-size collection of key/value pairs, the <see cref="M:System.Data.Common.DbConnectionStringBuilder.ContainsKey" /> method determines only if a particular key name is valid.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> instance, sets some of its properties, and then tries to determine whether various keys exist within the object by calling the <b>ContainsKey</b> method.
        </para>
        <!-- SqlConnectionStringBuilder_ContainsKey -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(GetConnectionString());
                  Console.WriteLine("Connection string = " + builder.ConnectionString);
          
                  // Keys you have provided return true.
                  Console.WriteLine(builder.ContainsKey("Server"));
          
                  // Comparison is case-insensitive, and synonyms
                  // are automatically converted to their "well-known"
                  // names.
                  Console.WriteLine(builder.ContainsKey("Database"));
          
                  // Keys that are valid but have not been set return true.
                  Console.WriteLine(builder.ContainsKey("Max Pool Size"));
          
                  // Keys that do not exist return false.
                  Console.WriteLine(builder.ContainsKey("MyKey"));
          
                  Console.WriteLine("Press Enter to continue.");
                  Console.ReadLine();
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file. 
                  return "Server=(local);Integrated Security=SSPI;" +
                         "Initial Catalog=AdventureWorks";
              }
          }
        </code>
        <para>
          The example displays the following output in the console window:
        </para>
        <code>
          Connection string = Data Source=(local);Initial Catalog=AdventureWorks;Integrated Security=True
          True
          True
          True
          False
        </code>
      </example><exception cref="T:System.ArgumentNullException"><paramref name="keyword" /> is null (<see langword="Nothing" /> in Visual Basic)</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.Remove(System.String)">
            <param name="keyword">
        The key of the key/value pair to be removed from the connection string in this <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" />.
      </param><summary>
        Removes the entry with the specified key from the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> instance.
      </summary><returns>
        <see langword="true" /> if the key existed within the connection string and was removed; <see langword="false" /> if the key did not exist.
      </returns><remarks>
        <para>
          Because the <b>Remove</b> method returns a value that indicates its success, it is not required to look for a key before trying to remove the key/value pair from the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> instance. Because the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> maintains a fixed-size collection of key/value pairs, calling the <b>Remove</b> method simply resets the value of the key/value pair back to its default value.
        </para>
        <para>
          Because the collection of keys supported by the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> is fixed, every item within the collection has a known default value. The following table lists the keys, and the value for each when the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> is first initialized, or after the <b>Remove</b> method has been called.
        </para>
        <list type="table">
          <listheader>
            <term>Key</term>
            <description>Default value</description>
          </listheader>
          <item>
            <term>Application Name</term>
            <description>
              "Framework Microsoft SqlClient Data Provider" when running on .NET Framework. "Core Microsoft SqlClient Data Provider" otherwise.
            </description>
          </item>
          <item>
            <term>AttachDBFilename</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>Connection Timeout</term>
            <description>15</description>
          </item>
          <item>
            <term>Context Connection(Obsolete)</term>
            <description>False</description>
          </item>
          <item>
            <term>Current Language</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>Data Source</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>Encrypt</term>
            <description>False in versions prior to 4.0, True in versions 4.0 and up</description>
          </item>
          <item>
            <term>Enlist</term>
            <description>True</description>
          </item>
          <item>
            <term>Failover Partner</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>Initial Catalog</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>Integrated Security</term>
            <description>False</description>
          </item>
          <item>
            <term>Load Balance Timeout</term>
            <description>0</description>
          </item>
          <item>
            <term>Max Pool Size</term>
            <description>100</description>
          </item>
          <item>
            <term>Min Pool Size</term>
            <description>0</description>
          </item>
          <item>
            <term>MultipleActiveResultSets</term>
            <description>False</description>
          </item>
          <item>
            <term>Network Library</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>Packet Size</term>
            <description>8000</description>
          </item>
          <item>
            <term>Password</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>Persist Security Info</term>
            <description>False</description>
          </item>
          <item>
            <term>Pooling</term>
            <description>True</description>
          </item>
          <item>
            <term>Replication</term>
            <description>False</description>
          </item>
          <item>
            <term>Transaction Binding</term>
            <description>Implicit Unbind</description>
          </item>
          <item>
            <term>User ID</term>
            <description>Empty string</description>
          </item>
          <item>
            <term>User Instance</term>
            <description>False</description>
          </item>
          <item>
            <term>Workstation ID</term>
            <description>Empty string</description>
          </item>
        </list>
      </remarks><example>
        <para>
          The following example converts an existing connection string from using Windows Authentication to using integrated security. The example works by removing the username and password from the connection string, and then setting the <see cref="P:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.IntegratedSecurity" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> object.
        </para>
        <note type="note">
          This example includes a password to demonstrate how <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> works with connection strings. In your applications, we recommend that you use Windows Authentication. If you must use a password, do not include a hard-coded password in your application.
        </note>
        <!-- SqlConnectionStringBuilder_Remove -->
        <code language="c#">
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  try
                  {
                      string connectString =
                          "Data Source=(local);User ID=ab;";

                      SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);
                      Console.WriteLine("Original: " + builder.ConnectionString);

                      // Use the Remove method
                      // in order to reset the user ID back to its
                      // default (empty string) value. 
                      builder.Remove("User ID");

                      // Turn on integrated security:
                      builder.IntegratedSecurity = true;

                      // Turn off encryption for local db
                      builder.Encrypt = false;

                      Console.WriteLine("Modified: " + builder.ConnectionString);

                      using (SqlConnection connection = new SqlConnection(builder.ConnectionString))
                      {
                          connection.Open();
                          // Now use the open connection.
                          Console.WriteLine("Database = " + connection.Database);
                      }
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine(ex.Message);
                  }

                  Console.WriteLine("Press any key to finish.");
                  Console.ReadLine();
              }
          }
        </code>
        <para>
          The example displays the following text in the console window:
        </para>
        <code>
          Original: Data Source=(local);User ID=ab;
          Modified: Data Source=(local);Integrated Security=True; Encrypt=false
          Database = master
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        <paramref name="keyword" /> is null (<see langword="Nothing" /> in Visual Basic)
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ShouldSerialize(System.String)">
            <param name="keyword">
        The key to locate in the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> .
      </param><summary>
        Indicates whether the specified key exists in this <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> instance.
      </summary><returns> <see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> contains an entry with the specified key; otherwise, <see langword="false" />.</returns><remarks>
        This method behaves identically to the <see cref="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.ContainsKey(System.String)" /> method.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TryGetValue(System.String,System.Object@)">
            <param name="keyword">
        The key of the item to retrieve.
      </param><param name="value">
        The value corresponding to <paramref name="keyword" /> .
      </param><summary>
        Retrieves a value corresponding to the supplied key from this <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> .
      </summary><returns>
        <see langword="true" /> if <paramref name="keyword" /> was found within the connection string; otherwise, <see langword="false" />.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlConnectionStringBuilder.TryGetValue" /> method lets developers safely retrieve a value from a <see cref="T:Microsoft.Data.SqlClient.SqlConnectionStringBuilder" /> without needing to verify that the supplied key name is a valid key name. Because <b>TryGetValue</b> does not raise an exception when you call it, passing in a nonexistent key, you do not have to look for a key before retrieving its value. Calling <b>TryGetValue</b> with a nonexistent key will place the value null (<c>Nothing</c> in Visual Basic) in the <paramref name="value" /> parameter.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates the behavior of the <b>TryGetValue</b> method.
        </para>
        <!-- SqlConnectionStringBuilder_TryGetValue -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();
                  builder.ConnectionString = GetConnectionString();
          
                  // Call TryGetValue method for multiple
                  // key names. Note that these keys are converted
                  // to well-known synonynms for data retrieval.
                  DisplayValue(builder, "Data Source");
                  DisplayValue(builder, "Trusted_Connection");
                  DisplayValue(builder, "InvalidKey");
                  DisplayValue(builder, null);
          
                  Console.WriteLine("Press any key to continue.");
                  Console.ReadLine();
              }
          
              private static void DisplayValue(SqlConnectionStringBuilder builder, string key)
              {
                  object value = null;
          
                  // Although TryGetValue handles missing keys,
                  // it doesn't handle passing in a null
                  // key. This example traps for that particular error, but
                  // passes any other unknown exceptions back out to the
                  // caller. 
                  try
                  {
                      if (builder.TryGetValue(key, out value))
                      {
                          Console.WriteLine("{0}='{1}'", key, value);
                      }
                      else
                      {
                          Console.WriteLine("Unable to retrieve value for '{0}'", key);
                      }
                  }
                  catch (ArgumentNullException)
                  {
                      Console.WriteLine("Unable to retrieve value for null key.");
                  }
              }
          
              private static string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file. 
                  return "Server=(local);Integrated Security=SSPI;" +
                         "Initial Catalog=AdventureWorks";
              }
          }
        </code>
        <para>
          The sample displays the following results:
        </para>
        <code>
          Data Source=(local)
          Trusted_Connection=True
          Unable to retrieve value for 'InvalidKey'
          Unable to retrieve value for null key.
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        <paramref name="keyword" /> contains a null value (<see langword="Nothing" /> in Visual Basic).
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlCredential">
            <summary> 
        <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> provides a more secure way to specify the password for a login attempt using SQL Server Authentication. <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> is comprised of a user id and a password that will be used for SQL Server Authentication. The password in a <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object is of type <see cref="T:System.Security.SecureString" />. <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> cannot be inherited. Windows Authentication (<c>Integrated Security = true</c>) remains the most secure way to log in to a SQL Server database.
      </summary><remarks>
        <para>
          Use <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" /> to get or set a connection's <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object. Use <see cref="M:Microsoft.Data.SqlClient.SqlConnection.ChangePassword(System.String, System.String)" /> to change the password for a <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object. For information on how a <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object affects connection pool behavior, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql-server-connection-pooling">SQL Server Connection Pooling (ADO.NET)</see>.
          </para>
        <para>
          An <see cref="T:System.InvalidOperationException" /> exception will be raised if a non-null <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object is used in a connection with any of the following connection string keywords:
        </para>
        <list type="bullet">
          <item><c>Integrated Security = true</c></item>
          <item><c>Password</c></item>
          <item><c>User ID</c></item>
        </list>
      </remarks><example>
        <para>
          The following sample connects to a SQL Server database using <see cref="P:Microsoft.Data.SqlClient.SqlConnection.Credential" />:
        </para>
        <para>change connection string in the APP.CONFIG file</para>
        <code language="xml">
          &lt;connectionStrings&gt;
            &lt;add name="MyConnString" connectionString="Initial Catalog=myDB;Server=myServer" providerName="Microsoft.Data.SqlClient" /&gt;
          &lt;/connectionStrings&gt;
        </code>
        <para>Then use the following snippet:</para>
        <code language="c#">
          using System.Configuration;

          System.Windows.Controls.TextBox txtUserId = new System.Windows.Controls.TextBox();
          System.Windows.Controls.PasswordBox txtPwd = new System.Windows.Controls.PasswordBox();
          Configuration config = Configuration.WebConfigurationManager.OpenWebConfiguration(null);
          ConnectionStringSettings connString = config.ConnectionStrings.ConnectionString["MyConnString"];
         
          using (SqlConnection conn = new SqlConnection(connString.ConnectionString))
          {
              SecureString pwd = txtPwd.SecurePassword;
              pwd.MakeReadOnly();
            
              SqlCredential cred = new SqlCredential(txtUserId.Text, pwd);
              conn.Credential = cred;
            
              conn.Open();
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlCredential.#ctor(System.String,System.Security.SecureString)">
            <param name="userId">
        The user id.
      </param><param name="password">
        The password; a <see cref="T:System.Security.SecureString" /> value marked as read-only.  Passing a read/write <see cref="T:System.Security.SecureString" /> parameter will raise an <see cref="T:System.ArgumentException" /> .
      </param><summary>
        Creates an object of type <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> .
      </summary><remarks>
        The constructor does not accept null parameters. An <c>string.Empty</c> value is allowed. An attempt to pass a null parameter in the constructor will raise an <see cref="T:System.ArgumentNullException" /> exception.
      </remarks><seealso href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCredential.Password">
            <summary>
        Gets the password component of the <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object.
      </summary><value>
        The password component of the <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlCredential.UserId">
            <summary>
        Gets the user ID component of the <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object.
      </summary><value>
        The user ID component of the <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> object.
      </value><seealso href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">
        Overview of the SqlClient driver
      </seealso>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlDataAdapter">
            <summary>
        Represents a set of data commands and a database connection that are used to fill the <see cref="T:System.Data.DataSet" /> and update a SQL Server database. This class cannot be inherited.
      </summary><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />, serves as a bridge between a <see cref="T:System.Data.DataSet" /> and SQL Server for retrieving and saving data. The <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> provides this bridge by mapping <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />, which changes the data in the <see cref="T:System.Data.DataSet" /> to match the data in the data source, and <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, which changes the data in the data source to match the data in the <see cref="T:System.Data.DataSet" />, using the appropriate Transact-SQL statements against the data source. The update is performed on a by-row basis. For every inserted, modified, and deleted row, the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> method determines the type of change that has been performed on it (<c>Insert</c>, <c>Update</c>, or <c>Delete</c>). Depending on the type of change, the <c>Insert</c>, <c>Update</c>, or <c>Delete</c> command template executes to propagate the modified row to the data source. When the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> fills a <see cref="T:System.Data.DataSet" />, it creates the necessary tables and columns for the returned data if they do not already exist. However, primary key information is not included in the implicitly created schema unless the <see cref="P:System.Data.Common.DataAdapter.MissingSchemaAction" /> property is set to <see cref="F:System.Data.MissingSchemaAction.AddWithKey" />. You may also have the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> create the schema of the <see cref="T:System.Data.DataSet" />, including primary key information, before filling it with data using <c>FillSchema</c>. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/add-existing-constraints-to-dataset">Adding Existing Constraints to a DataSet</see>. <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is used in conjunction with <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> to increase performance when connecting to a SQL Server database.
        </para>
        <note type="note">
          If you are using SQL Server stored procedures to edit or delete data using a <c>DataAdapter</c>, make sure that you do not use SET NOCOUNT ON in the stored procedure definition. This causes the rows affected count returned to be zero, which the <c>DataAdapter</c> interprets as a concurrency conflict. In this event, a <see cref="T:System.Data.DBConcurrencyException" /> will be thrown.
        </note>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> also includes the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />, and <see cref="P:System.Data.Common.DataAdapter.TableMappings" /> properties to facilitate the loading and updating of data.
        </para>
        <para>
          When an instance of <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is created, the read/write properties are set to initial values. For a list of these values, see the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> constructor.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" />, and <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" /> are generic templates that are automatically filled with individual values from every modified row through the parameters mechanism.
        </para>
        <para>
          For every column that you propagate to the data source on <see cref="P:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, a parameter should be added to the <c>InsertCommand</c>, <c>UpdateCommand</c>, or <c>DeleteCommand</c>. The <see cref="P:System.Data.Common.DbParameter.SourceColumn" /> property of the <see cref="T:System.Data.Common.DbParameter" /> object should be set to the name of the column. This setting indicates that the value of the parameter is not set manually, but is taken from the particular column in the currently processed row.
        </para>
        <note type="note">
          An <see cref="T:System.InvalidOperationException" /> will occur if the <see cref="M:System.Data.Common.DbDataAdapter.Fill" /> method is called and the table contains a user-defined type that is not available on the client computer. For more information, see <see href="https://learn.microsoft.com/sql/relational-databases/clr-integration-database-objects-user-defined-types/clr-user-defined-types">CLR User-Defined Types</see>.
        </note>
      </remarks><example>
        <para>
          The following example uses the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />, and <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> to select records from a database and populate a <see cref="T:System.Data.DataSet" /> with the selected rows. The filled <see cref="T:System.Data.DataSet" /> is then returned. To accomplish this, the method is passed an initialized <see cref="T:System.Data.DataSet" />, a connection string, and a query string that is a Transact-SQL SELECT statement.
        </para>
        <!-- SqlDataAdapter_SelectCommand -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              protected DataSet DataSet1;
              protected DataGrid dataGrid1;
          
              private static DataSet SelectRows(DataSet dataset,
                  string connectionString, string queryString)
              {
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlDataAdapter adapter = new SqlDataAdapter();
                      adapter.SelectCommand = new SqlCommand(
                          queryString, connection);
                      adapter.Fill(dataset);
                      return dataset;
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataAdapter.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> class.
      </summary><remarks>
        <para>
          When an instance of <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is created, the following read/write properties are set to the following initial values.
        </para>
        <list type="table">
          <listheader>
            <term>
              Properties
            </term>
            <description>
              Initial value
            </description>
          </listheader>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingMappingAction" /></term>
            <description><see cref="F:System.Data.MissingMappingAction.Passthrough" /></description>
          </item>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingSchemaAction" /></term>
            <description><see cref="F:System.Data.MissingSchemaAction.Add" /></description>
          </item>
        </list>
        <para>
          You can change the value of these properties through a separate call to the property.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets some of its properties.
        </para>
        <!-- SqlDataAdapter_SqlDataAdapter -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }

              public static SqlDataAdapter CreateSqlDataAdapter(SqlConnection connection)
              {
                  // Assumes that connection is a valid SqlConnection object
                  SqlDataAdapter adapter = new SqlDataAdapter();
                  adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;
          
                  // Create the commands.
                  adapter.SelectCommand = new SqlCommand(
                      "SELECT CustomerID, CompanyName FROM CUSTOMERS", connection);
                  adapter.InsertCommand = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)", connection);
                  adapter.UpdateCommand = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID", connection);
                  adapter.DeleteCommand = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);
          
                  // Create the parameters.
                  adapter.InsertCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.InsertCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
          
                  adapter.UpdateCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.UpdateCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
                  adapter.UpdateCommand.Parameters.Add(
                      "@oldCustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand.Parameters.Add(
                    "@CustomerID",
                    SqlDbType.Char,
                    5,
                    "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  return adapter;
              }
          
              public static SqlDataAdapter CustomerUpdateCommand(SqlDataAdapter adapter)
              {
                  // Assumes that connection is a valid SqlAdapter object
                  adapter.UpdateCommand.Parameters.Add(
                      "@CompanyName", 
                      SqlDbType.VarChar,
                      15,
                      "CompanyName");
                  SqlParameter parameter = adapter.UpdateCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataAdapter.#ctor(Microsoft.Data.SqlClient.SqlCommand)">
            <param name="selectCommand">
        A <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> that is a Transact-SQL SELECT statement or stored procedure and is set as the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> class with the specified <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> as the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property.
      </summary><remarks>
        <para>
          This implementation of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> constructor sets the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property to the value specified in the <paramref name="selectCommand" /> parameter. When an instance of <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is created, the following read/write properties are set to the following initial values.
        </para>
        <list type="table">
          <listheader>
            <term>Properties</term>
            <description>Initial value</description>
          </listheader>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingMappingAction" /></term>
            <description><see cref="F:System.Data.MissingMappingAction.Passthrough" /></description>
          </item>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingSchemaAction" /></term>
            <description><see cref="F:System.Data.MissingSchemaAction.Add" /></description>
          </item>
        </list>
        <para>
          You can change the value of these properties through a separate call to the property.
        </para>
        <para>
          When <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> (or any of the other command properties) is assigned to a previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> is not cloned. The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> maintains a reference to the previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets some of its properties.
        </para>
        <!-- SqlDataAdapter_SqlDataAdapter1 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }

              public static SqlDataAdapter CreateSqlDataAdapter(SqlCommand selectCommand, SqlConnection connection)
              {
                  SqlDataAdapter adapter = new SqlDataAdapter(selectCommand);
                  adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;
          
                  // Create the other commands.
                  adapter.InsertCommand = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)", connection);
          
                  adapter.UpdateCommand = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID", connection);
          
                  adapter.DeleteCommand = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);
          
                  // Create the parameters.
                  adapter.InsertCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.InsertCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
          
                  adapter.UpdateCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.UpdateCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
                  adapter.UpdateCommand.Parameters.Add(
                      "@oldCustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataAdapter.#ctor(System.String,Microsoft.Data.SqlClient.SqlConnection)">
            <param name="selectCommandText">
        A <see cref="T:System.String" /> that is a Transact-SQL SELECT statement or stored procedure to be used by the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
      </param><param name="selectConnection">
        A <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> that represents the connection. If your connection string does not use <see langword="Integrated Security = true" />, you can use <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> class with a <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object.
      </summary><remarks>
        <para>
          This implementation of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> opens and closes a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> if it is not already open. This can be useful in an application that must call the <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> method for two or more <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> objects. If the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is already open, you must explicitly call <see cref="M:Microsoft.Data.SqlClient.SqlConnection.Close" /> or <see cref="M:System.IDisposable.Dispose" /> to close it.
        </para>
        <para>
          When an instance of <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is created, the following read/write properties are set to the following initial values.
        </para>
        <list type="table">
          <listheader>
            <term>
              Properties
            </term>
            <description>
              Initial value
            </description>
          </listheader>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingMappingAction" /></term>
            <description><see cref="F:System.Data.MissingMappingAction.Passthrough" /></description>
          </item>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingSchemaAction" /></term>
            <description><see cref="F:System.Data.MissingSchemaAction.Add" /></description>
          </item>
        </list>
        <para>
          You can change the value of either of these properties through a separate call to the property.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets some of its properties.
        </para>
        <!-- SqlDataAdapter_SqlDataAdapter3 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }
            
              public static SqlDataAdapter CreateSqlDataAdapter(string commandText, SqlConnection connection)
              {
                  SqlDataAdapter adapter = new SqlDataAdapter(commandText, connection);
          
                  adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;
          
                  // Create the other commands.
                  adapter.InsertCommand = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)");
          
                  adapter.UpdateCommand = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID");
          
                  adapter.DeleteCommand = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID");
          
                  // Create the parameters.
                  adapter.InsertCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.InsertCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
          
                  adapter.UpdateCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.UpdateCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
                  adapter.UpdateCommand.Parameters.Add(
                      "@oldCustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataAdapter.#ctor(System.String,System.String)">
            <param name="selectCommandText">
        A <see cref="T:System.String" /> that is a Transact-SQL SELECT statement or stored procedure to be used by the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
      </param><param name="selectConnectionString">
        The connection string. If your connection string does not use <see langword="Integrated Security = true" />, you can use <see cref="M:Microsoft.Data.SqlClient.SqlDataAdapter.#ctor(System.String,Microsoft.Data.SqlClient.SqlConnection)" /> and <see cref="T:Microsoft.Data.SqlClient.SqlCredential" /> to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> class with a <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> and a connection string.
      </summary><remarks>
        <para>
          This overload of the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> constructor uses the <paramref name="selectCommandText" /> parameter to set the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property. The <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> will create and maintain the connection created with the <paramref name="selectConnectionString" /> parameter.
        </para>
        <para>
          When an instance of <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> is created, the following read/write properties are set to the following initial values.
        </para>
        <list type="table">
          <listheader>
            <term>
              Properties
            </term>
            <description>
              Initial value
            </description>
          </listheader>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingMappingAction" /></term>
            <description><see cref="F:System.Data.MissingMappingAction.Passthrough" /></description>
          </item>
          <item>
            <term><see cref="P:System.Data.Common.DataAdapter.MissingSchemaAction" /></term>
            <description><see cref="F:System.Data.MissingSchemaAction.Add" /></description>
          </item>
        </list>
        <para>
          You can change the value of these properties through a separate call to the property.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets some of its properties.
        </para>
        <!-- SqlDataAdapter_SqlDataAdapter2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }
            
              public static SqlDataAdapter CreateSqlDataAdapter(string commandText, string connectionString)
              {
                  SqlDataAdapter adapter = new SqlDataAdapter(commandText, connectionString);
                  SqlConnection connection = adapter.SelectCommand.Connection;
          
                  adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;
          
                  // Create the commands.
                  adapter.InsertCommand = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)", connection);
          
                  adapter.UpdateCommand = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID", connection);
          
                  adapter.DeleteCommand = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);
          
                  // Create the parameters.
                  adapter.InsertCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.InsertCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
          
                  adapter.UpdateCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID");
                  adapter.UpdateCommand.Parameters.Add(
                      "@CompanyName",
                      SqlDbType.VarChar,
                      40,
                      "CompanyName");
                  adapter.UpdateCommand.Parameters.Add(
                      "@oldCustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand.Parameters.Add(
                      "@CustomerID",
                      SqlDbType.Char,
                      5,
                      "CustomerID"
                  ).SourceVersion = DataRowVersion.Original;
          
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand">
            <summary>
        Gets or sets a Transact-SQL statement or stored procedure to delete records from the data set.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to delete records in the database that correspond to deleted rows in the <see cref="T:System.Data.DataSet" />.
      </value><remarks>
        <para>
          During <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, if this property is not set and primary key information is present in the <see cref="T:System.Data.DataSet" />, the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> can be generated automatically if you set the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property and use the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />. Then, any additional commands that you do not set are generated by the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />. This generation logic requires key column information to be present in the <see cref="T:System.Data.DataSet" />. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
        <para>
          When <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> is assigned to a previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> is not cloned. The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> maintains a reference to the previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </para>
        <para>
          For every column that you propagate to the data source on <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, a parameter should be added to the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />, or <b>DeleteCommand</b>. The <c>SourceColumn</c> property of the parameter should be set to the name of the column. This indicates that the value of the parameter is not set manually, but is taken from the particular column in the currently processed row.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />, and <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> properties. It assumes you have already created a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object.
        </para>
        <!-- SqlDataAdapter -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }

              public static SqlDataAdapter CreateCustomerAdapter(SqlConnection connection)
              {
                  SqlDataAdapter adapter = new SqlDataAdapter();
          
                  // Create the SelectCommand.
                  SqlCommand command = new SqlCommand("SELECT * FROM Customers " +
                      "WHERE Country = @Country AND City = @City", connection);
          
                  // Add the parameters for the SelectCommand.
                  command.Parameters.Add("@Country", SqlDbType.NVarChar, 15);
                  command.Parameters.Add("@City", SqlDbType.NVarChar, 15);
          
                  adapter.SelectCommand = command;
          
                  // Create the InsertCommand.
                  command = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)", connection);
          
                  // Add the parameters for the InsertCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
          
                  adapter.InsertCommand = command;
          
                  // Create the UpdateCommand.
                  command = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID", connection);
          
                  // Add the parameters for the UpdateCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
                  SqlParameter parameter = command.Parameters.Add(
                      "@oldCustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.UpdateCommand = command;
          
                  // Create the DeleteCommand.
                  command = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);
          
                  // Add the parameters for the DeleteCommand.
                  parameter = command.Parameters.Add(
                      "@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand = command;
          
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand">
            <summary>
        Gets or sets a Transact-SQL statement or stored procedure to insert new records into the data source.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to insert records into the database that correspond to new rows in the <see cref="T:System.Data.DataSet" />.
      </value><remarks>
        <para>
          During <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, if this property is not set and primary key information is present in the <see cref="T:System.Data.DataSet" />, the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" /> can be generated automatically if you set the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property and use the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />. Then, any additional commands that you do not set are generated by the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />. This generation logic requires key column information to be present in the <see cref="T:System.Data.DataSet" />. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
        <para>
          When <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" /> is assigned to a previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> is not cloned. The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" /> maintains a reference to the previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </para>
        <para>
          If execution of this command returns rows, these rows can be added to the <see cref="T:System.Data.DataSet" /> depending on how you set the <b>UpdatedRowSource</b> property of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </para>
        <para>
          For every column that you propagate to the data source on <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, a parameter should be added to <b>InsertCommand</b>, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />, or <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" />. The <c>SourceColumn</c> property of the parameter should be set to the name of the column. This indicates that the value of the parameter is not set manually, but is taken from the particular column in the currently processed row.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />, and <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> properties. It assumes you have already created a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object.
        </para>
        <!-- SqlDataAdapter -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }
            
              public static SqlDataAdapter CreateCustomerAdapter(SqlConnection connection)
              {
                  SqlDataAdapter adapter = new SqlDataAdapter();
          
                  // Create the SelectCommand.
                  SqlCommand command = new SqlCommand("SELECT * FROM Customers " +
                      "WHERE Country = @Country AND City = @City", connection);
          
                  // Add the parameters for the SelectCommand.
                  command.Parameters.Add("@Country", SqlDbType.NVarChar, 15);
                  command.Parameters.Add("@City", SqlDbType.NVarChar, 15);
          
                  adapter.SelectCommand = command;
          
                  // Create the InsertCommand.
                  command = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)", connection);
          
                  // Add the parameters for the InsertCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
          
                  adapter.InsertCommand = command;
          
                  // Create the UpdateCommand.
                  command = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID", connection);
          
                  // Add the parameters for the UpdateCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
                  SqlParameter parameter = command.Parameters.Add(
                      "@oldCustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.UpdateCommand = command;
          
                  // Create the DeleteCommand.
                  command = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);
          
                  // Add the parameters for the DeleteCommand.
                  parameter = command.Parameters.Add(
                      "@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand = command;
          
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand">
            <summary>
        Gets or sets a Transact-SQL statement or stored procedure used to select records in the data source.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> to select records from the database for placement in the <see cref="T:System.Data.DataSet" />.
      </value><remarks>
        <para>
          When <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> is assigned to a previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> is not cloned. The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> maintains a reference to the previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </para>
        <para>
          If the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> does not return any rows, no tables are added to the <see cref="T:System.Data.DataSet" />, and no exception is raised.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />, and <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> properties. It assumes you have already created a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object.
        </para>
        <!-- SqlDataAdapter -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }
            
              public static SqlDataAdapter CreateCustomerAdapter(SqlConnection connection)
              {
                  SqlDataAdapter adapter = new SqlDataAdapter();
          
                  // Create the SelectCommand.
                  SqlCommand command = new SqlCommand("SELECT * FROM Customers " +
                      "WHERE Country = @Country AND City = @City", connection);
          
                  // Add the parameters for the SelectCommand.
                  command.Parameters.Add("@Country", SqlDbType.NVarChar, 15);
                  command.Parameters.Add("@City", SqlDbType.NVarChar, 15);
          
                  adapter.SelectCommand = command;
          
                  // Create the InsertCommand.
                  command = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)", connection);
          
                  // Add the parameters for the InsertCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
          
                  adapter.InsertCommand = command;
          
                  // Create the UpdateCommand.
                  command = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID", connection);
          
                  // Add the parameters for the UpdateCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
                  SqlParameter parameter = command.Parameters.Add(
                      "@oldCustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.UpdateCommand = command;
          
                  // Create the DeleteCommand.
                  command = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);
          
                  // Add the parameters for the DeleteCommand.
                  parameter = command.Parameters.Add(
                      "@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand = command;
          
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.System#Data#IDbDataAdapter#DeleteCommand">
            <summary>
        For a description of this member, see <see cref="P:System.Data.IDbDataAdapter.DeleteCommand" />.
      </summary><value>
        An <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to delete records in the data source for deleted rows in the data set.
      </value><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> instance is cast to an <see cref="T:System.Data.IDbDataAdapter" /> interface.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.System#Data#IDbDataAdapter#InsertCommand">
            <summary>
        For a description of this member, see <see cref="P:System.Data.IDbDataAdapter.InsertCommand" />.
      </summary><value>
        An <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to insert records in the data source for new rows in the data set.
      </value><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> instance is cast to an <see cref="T:System.Data.IDbDataAdapter" /> interface.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.System#Data#IDbDataAdapter#SelectCommand">
            <summary>
        For a description of this member, see <see cref="P:System.Data.IDbDataAdapter.SelectCommand" />.
      </summary><value>
        An <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to select records from data source for placement in the data set.
      </value><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> instance is cast to an <see cref="T:System.Data.IDbDataAdapter" /> interface.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.System#Data#IDbDataAdapter#UpdateCommand">
            <summary>
        For a description of this member, see <see cref="P:System.Data.IDbDataAdapter.UpdateCommand" />.
      </summary><value>
        An <see cref="T:System.Data.IDbCommand" /> that is used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to update records in the data source for modified rows in the data set.
      </value><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> instance is cast to an <see cref="T:System.Data.IDbDataAdapter" /> interface.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateBatchSize">
            <summary>
        Gets or sets the number of rows that are processed in each round-trip to the server.
      </summary><value>
        <para>
          The number of rows to process per-batch.
        </para>
        <list type="table">
          <listheader>
            <term>When value is</term>
            <description>Effect</description>
          </listheader>
          <item>
            <term>0</term>
            <description>There is no limit on the batch size.</description>
          </item>
          <item>
            <term>1</term>
            <description>Disables batch updating.</description>
          </item>
          <item>
            <term>&gt;1</term>
            <description>
              Changes are sent using batches of <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateBatchSize" /> operations at a time.
            </description>
          </item>
        </list>
        <para>
          When setting this to a value other than 1, all the commands associated with the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> have to have their <see cref="P:Microsoft.Data.SqlClient.SqlCommand.UpdatedRowSource" /> property set to <see cref="F:System.Data.UpdateRowSource.None" /> or <see cref="F:System.Data.UpdateRowSource.OutputParameters" />. An exception is thrown otherwise.
        </para>
      </value><remarks>
        <para>
          Gets or sets a value that enables or disables batch processing support, and specifies the number of commands that can be executed in a batch.
        </para>
        <para>
          Use the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateBatchSize" /> property to update a data source with changes from a <see cref="T:System.Data.DataSet" />. This can increase application performance by reducing the number of round-trips to the server.
        </para>
        <para>
          Executing an extremely large batch could decrease performance. Therefore, you should test for the optimum batch size setting before implementing your application.
        </para>
        <para>
          An <see cref="T:System.ArgumentOutOfRangeException" /> is thrown if the value is set to a number less than zero.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand">
            <summary>
        Gets or sets a Transact-SQL statement or stored procedure used to update records in the data source.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to update records in the database that correspond to modified rows in the <see cref="T:System.Data.DataSet" />.
      </value><remarks>
        <para>
          During <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, if this property is not set and primary key information is present in the <see cref="T:System.Data.DataSet" />, the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" /> can be generated automatically if you set the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" /> property and use the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />. Then, any additional commands that you do not set are generated by the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />. This generation logic requires key column information to be present in the <see cref="T:System.Data.DataSet" />. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/generate-commands-with-commandbuilders">Generating Commands with CommandBuilders</see>.
        </para>
        <para>
          When <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" /> is assigned to a previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> is not cloned. The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" /> maintains a reference to the previously created <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </para>
        <note type="note">
          If execution of this command returns rows, the updated rows may be merged with the <see cref="T:System.Data.DataSet" /> depending on how you set the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.UpdatedRowSource" /> property of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </note>
        <para>
          For every column that you propagate to the data source on <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, a parameter should be added to <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <b>UpdateCommand</b>, or <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" />.
        </para>
        <para>
          The <c>SourceColumn</c> property of the parameter should be set to the name of the column. This indicates that the value of the parameter is not set manually, but taken from the particular column in the currently processed row.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> and sets the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.SelectCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.InsertCommand" />, <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" /> and <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.DeleteCommand" /> properties. It assumes you have already created a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object.
        </para>
        <!-- SqlDataAdapter -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
              }
            
              public static SqlDataAdapter CreateCustomerAdapter(SqlConnection connection)
              {
                  SqlDataAdapter adapter = new SqlDataAdapter();
          
                  // Create the SelectCommand.
                  SqlCommand command = new SqlCommand("SELECT * FROM Customers " +
                      "WHERE Country = @Country AND City = @City", connection);
          
                  // Add the parameters for the SelectCommand.
                  command.Parameters.Add("@Country", SqlDbType.NVarChar, 15);
                  command.Parameters.Add("@City", SqlDbType.NVarChar, 15);
          
                  adapter.SelectCommand = command;
          
                  // Create the InsertCommand.
                  command = new SqlCommand(
                      "INSERT INTO Customers (CustomerID, CompanyName) " +
                      "VALUES (@CustomerID, @CompanyName)", connection);
          
                  // Add the parameters for the InsertCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
          
                  adapter.InsertCommand = command;
          
                  // Create the UpdateCommand.
                  command = new SqlCommand(
                      "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
                      "WHERE CustomerID = @oldCustomerID", connection);
          
                  // Add the parameters for the UpdateCommand.
                  command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
                  SqlParameter parameter = command.Parameters.Add(
                      "@oldCustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.UpdateCommand = command;
          
                  // Create the DeleteCommand.
                  command = new SqlCommand(
                      "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);
          
                  // Add the parameters for the DeleteCommand.
                  parameter = command.Parameters.Add(
                      "@CustomerID", SqlDbType.NChar, 5, "CustomerID");
                  parameter.SourceVersion = DataRowVersion.Original;
          
                  adapter.DeleteCommand = command;
          
                  return adapter;
              }
          }
        </code>
      </example>
        </member>
        <member name="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated">
            <summary>
        Occurs during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> after a command is executed against the data source. The attempt to update is made, so the event fires.
      </summary><remarks>
        <para>
          When using <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, there are two events that occur per data row updated. The order of execution is as follows:
        </para>
        <list type="number">
          <item>The values in the <see cref="T:System.Data.DataRow" /> are moved to the parameter values.</item>
          <item>The <see cref="M:Microsoft.Data.SqlClient.SqlDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> event is raised.</item>
          <item>The command executes.</item>
          <item>If the command is set to <c>FirstReturnedRecord</c>, the first returned result is placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>If there are output parameters, they are placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>The <see cref="M:Microsoft.Data.SqlClient.SqlDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> event is raised.</item>
          <item><see cref="M:System.Data.DataRow.AcceptChanges" /> is called.</item>
        </list>
      </remarks><example>
        <para>
          The following example shows how to use both the <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> and <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> events.
        </para>
        <!-- SqlDataAdapter_RowUpdated -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              private DataSet DataSet1;
              private DataGrid dataGrid1;
          
              // handler for RowUpdating event
              private static void OnRowUpdating(object sender, SqlRowUpdatingEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              // handler for RowUpdated event
              private static void OnRowUpdated(object sender, SqlRowUpdatedEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              public static int Main()
              {
                  const string connectionString = "Integrated Security=SSPI;database=Northwind;server=MSSQL1";
                  const string queryString = "SELECT * FROMProducts";
          
                  // create DataAdapter
                  SqlDataAdapter adapter = new SqlDataAdapter(queryString, connectionString);
                  SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
          
                  // Create and fill DataSet (select only first 5 rows)
                  DataSet dataSet = new DataSet();
                  adapter.Fill(dataSet, 0, 5, "Table");
          
                  // Modify DataSet
                  DataTable table = dataSet.Tables["Table"];
                  table.Rows[0][1] = "new product";
          
                  // add handlers
                  adapter.RowUpdating += new SqlRowUpdatingEventHandler(OnRowUpdating);
                  adapter.RowUpdated += new SqlRowUpdatedEventHandler(OnRowUpdated);
          
                  // update, this operation fires two events 
                  // (RowUpdating/RowUpdated) per changed row 
                  adapter.Update(dataSet, "Table");
          
                  // remove handlers
                  adapter.RowUpdating -= new SqlRowUpdatingEventHandler(OnRowUpdating);
                  adapter.RowUpdated -= new SqlRowUpdatedEventHandler(OnRowUpdated);
                  return 0;
              }
          
              private static void PrintEventArgs(SqlRowUpdatingEventArgs args)
              {
                  Console.WriteLine("OnRowUpdating");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " status=" + args.Status + ")");
              }
          
              private static void PrintEventArgs(SqlRowUpdatedEventArgs args)
              {
                  Console.WriteLine("OnRowUpdated");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " recordsAffected=" + args.RecordsAffected +
                      " status=" + args.Status + ")");
              }
          }
        </code>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> event returns this output:
        </para>
        <code>
          event args: (command=Microsoft.Data.SqlClient.SqlCommand commandType=2 status=0)
        </code>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> event returns this output:
        </para>
        <code>
          event args: (command=Microsoft.Data.SqlClient.SqlCommand commandType=2 recordsAffected=1 row=System.Data.DataRow[37] status=0)
        </code>
      </example>
        </member>
        <member name="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating">
            <summary>
        Occurs during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> before a command is executed against the data source. The attempt to update is made, so the event fires.
      </summary><remarks>
        <para>
          When using <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, there are two events that occur per data row updated. The order of execution is as follows:
        </para>
        <list type="number">
          <item>The values in the <see cref="T:System.Data.DataRow" /> are moved to the parameter values.</item>
          <item>The <see cref="M:Microsoft.Data.SqlClient.SqlDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> event is raised.</item>
          <item>The command executes.</item>
          <item>If the command is set to <c>FirstReturnedRecord</c>, the first returned result is placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>If there are output parameters, they are placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>The <see cref="M:Microsoft.Data.SqlClient.SqlDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> event is raised.</item>
          <item><see cref="M:System.Data.DataRow.AcceptChanges" /> is called.</item>
        </list>
      </remarks><example>
        <para>
          The following example shows how to use both the <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> and <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> events.
        </para>
        <!-- SqlDataAdapter_RowUpdated -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              private DataSet DataSet1;
              private DataGrid dataGrid1;
          
              // handler for RowUpdating event
              private static void OnRowUpdating(object sender, SqlRowUpdatingEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              // handler for RowUpdated event
              private static void OnRowUpdated(object sender, SqlRowUpdatedEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              public static int Main()
              {
                  const string connectionString = "Integrated Security=SSPI;database=Northwind;server=MSSQL1";
                  const string queryString = "SELECT * FROMProducts";
          
                  // create DataAdapter
                  SqlDataAdapter adapter = new SqlDataAdapter(queryString, connectionString);
                  SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
          
                  // Create and fill DataSet (select only first 5 rows)
                  DataSet dataSet = new DataSet();
                  adapter.Fill(dataSet, 0, 5, "Table");
          
                  // Modify DataSet
                  DataTable table = dataSet.Tables["Table"];
                  table.Rows[0][1] = "new product";
          
                  // add handlers
                  adapter.RowUpdating += new SqlRowUpdatingEventHandler(OnRowUpdating);
                  adapter.RowUpdated += new SqlRowUpdatedEventHandler(OnRowUpdated);
          
                  // update, this operation fires two events 
                  // (RowUpdating/RowUpdated) per changed row 
                  adapter.Update(dataSet, "Table");
          
                  // remove handlers
                  adapter.RowUpdating -= new SqlRowUpdatingEventHandler(OnRowUpdating);
                  adapter.RowUpdated -= new SqlRowUpdatedEventHandler(OnRowUpdated);
                  return 0;
              }
          
              private static void PrintEventArgs(SqlRowUpdatingEventArgs args)
              {
                  Console.WriteLine("OnRowUpdating");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " status=" + args.Status + ")");
              }
          
              private static void PrintEventArgs(SqlRowUpdatedEventArgs args)
              {
                  Console.WriteLine("OnRowUpdated");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " recordsAffected=" + args.RecordsAffected +
                      " status=" + args.Status + ")");
              }
          }
        </code>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> event returns this output:
        </para>
        <code>
          event args: (command=Microsoft.Data.SqlClient.SqlCommand commandType=2 status=0)
        </code>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> event returns this output:
        </para>
        <code>
          event args: (command=Microsoft.Data.SqlClient.SqlCommand commandType=2 recordsAffected=1 row=System.Data.DataRow[37] status=0)
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)">
            <param name="value">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)">
            <param name="value">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataAdapter.System#ICloneable#Clone">
            <summary>
        For a description of this member, see <see cref="M:System.ICloneable.Clone" />.
      </summary><returns>
        A new object that is a copy of the current instance.
      </returns><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> instance is cast to an <see cref="T:System.ICloneable" /> interface.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlDataReader">
            <summary>
        Provides a way of reading a forward-only stream of rows from a SQL Server database. This class cannot be inherited.
      </summary><remarks>
        <para>
          To create a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />, you must call the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> method of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object, instead of directly using a constructor.
        </para>
        <para>
          While the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is being used, the associated <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is busy serving the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />, and no other operations can be performed on the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> other than closing it. This is the case until the <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Close" /> method of the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is called. For example, you cannot retrieve output parameters until after you call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Close" />.
        </para>
        <para>
          Changes made to a result set by another process or thread while data is being read may be visible to the user of the <c>SqlDataReader</c>. However, the precise behavior is timing dependent. <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.IsClosed" /> and <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.RecordsAffected" /> are the only properties that you can call after the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed. Although the <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.RecordsAffected" /> property may be accessed while the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> exists, always call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Close" /> before returning the value of <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.RecordsAffected" /> to guarantee an accurate return value.
        </para>
        <para>
          When using sequential access (<see cref="F:System.Data.CommandBehavior.SequentialAccess" />), an <see cref="T:System.InvalidOperationException" /> will be raised if the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> position is advanced and another read operation is attempted on the previous column.
        </para>
        <note type="note">
          For optimal performance, <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> avoids creating unnecessary objects or making unnecessary copies of data. Therefore, multiple calls to methods such as <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetValue(System.Int32)" /> return a reference to the same object. Use caution if you are modifying the underlying value of the objects returned by methods such as <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetValue(System.Int32)" />.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, and a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the data, writing it out to the console window. The code then closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is closed automatically at the end of the <c>using</c> code block.
        </para>
        <!-- SqlDataReader_Read -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI";
                  ReadOrderData(str);
              }
          
              private static void ReadOrderData(string connectionString)
              {
                  string queryString = "SELECT OrderID, CustomerID FROM dbo.Orders;";
          
                  using (SqlConnection connection =
                             new SqlConnection(connectionString))
                  {
                      SqlCommand command =
                          new SqlCommand(queryString, connection);
                      connection.Open();
          
                      SqlDataReader reader = command.ExecuteReader();
          
                      // Call Read before accessing data.
                      while (reader.Read())
                      {
                          ReadSingleRow((IDataRecord)reader);
                      }
          
                      // Call Close when done reading.
                      reader.Close();
                  }
              }
          
              private static void ReadSingleRow(IDataRecord record)
              {
                  Console.WriteLine(String.Format("{0}, {1}", record[0], record[1]));
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.Connection">
            <summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> associated with the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> associated with the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.Depth">
            <summary>
        Gets a value that indicates the depth of nesting for the current row.
      </summary><value>
        The depth of nesting for the current row.
      </value><remarks>
        The outermost table has a depth of zero. The .NET Framework Data Provider for SQL Server does not support nesting and always returns zero.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.FieldCount">
            <summary>
        Gets the number of columns in the current row.
      </summary><value>
        When not positioned in a valid recordset, 0; otherwise the number of columns in the current row. The default is -1.
      </value><remarks>
        Executing a query that, by its nature, does not return rows (such as a DELETE query), sets <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.FieldCount" /> to 0. However. this should not be confused with a query that returns 0 rows (such as <c>SELECT * FROM &lt;table&gt; WHERE 1 = 2</c>) in which case <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.FieldCount" /> returns the number of columns in the table, including hidden fields. Use <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.VisibleFieldCount" /> to exclude hidden fields.
      </remarks><exception cref="T:System.NotSupportedException">
        There is no current connection to an instance of SQL Server.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.HasRows">
            <summary>
        Gets a value that indicates whether the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> contains one or more rows.
      </summary><value><see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> contains one or more rows; otherwise <see langword="false" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.IsClosed">
            <summary>
        Retrieves a Boolean value that indicates whether the specified <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance has been closed.
      </summary><value>
        <see langword="true" /> if the specified <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance is closed; otherwise <see langword="false" />.
      </value><remarks>
        It is not possible to read from a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> instance that is closed.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.Item(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column in its native format given the column ordinal.
      </summary><value>
        The value of the specified column in its native format.
      </value><exception cref="T:System.IndexOutOfRangeException">
        The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.Item(System.String)">
            <param name="name">
        The column name.
      </param><summary>
        Gets the value of the specified column in its native format given the column name.
      </summary><value>
        The value of the specified column in its native format.
      </value><remarks>
        <para>
          A case-sensitive lookup is performed first. If it fails, a second case-insensitive search is made (a case-insensitive comparison is done using the database collation). Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter 'i' in "file".
        </para>
        <para>
          This method is kana-width insensitive.
        </para>
      </remarks><exception cref="T:System.IndexOutOfRangeException">
        No column with the specified name was found.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.RecordsAffected">
            <summary>
        Gets the number of rows changed, inserted, or deleted by execution of the Transact-SQL statement.
      </summary><value>
        The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.
      </value><remarks>
        The value of this property is cumulative. For example, if two records are inserted in batch mode, the value of <c>RecordsAffected</c> will be two. <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.IsClosed" /> and <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.RecordsAffected" /> are the only properties that you can call after the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.SensitivityClassification">
            <summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification" /> information with the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification" /> associated with the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDataReader.VisibleFieldCount">
            <summary>
        Gets the number of fields in the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> that are not hidden.
      </summary><value>
        The number of fields that are not hidden.
      </value><remarks>
        This value is used to determine how many fields in the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> are visible. For example, a SELECT on a partial primary key returns the remaining parts of the key as hidden fields. The hidden fields are always appended behind the visible fields.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.Close">
            <summary>
        Closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> object.
      </summary><remarks>
        <para>
          You must ensure the <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Close" /> method is called when you are through using the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> before using the associated <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> for any other purpose. The <b>Close</b> method may either be called directly or through the <see cref="M:System.IDisposable.Dispose" /> method, disposing directly or in the context of <see href="https://learn.microsoft.com/dotnet/csharp/language-reference/language-specification/statements#the-using-statement">
            the using statement
          </see> block.
        </para>
        <para>
          The <b>Close</b> method populates the values for output parameters, return values and <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.RecordsAffected" /> on the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> by consuming any pending results. This may be a long operation depending on the amount of data to be consumed. If output values, return values, and <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.RecordsAffected" /> are not important to your application, the time to close may be shortened by calling the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.Cancel" /> method of the associated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object before the <b>Close</b> method is called.
        </para>
        <note type="caution">
          Do not call <b>Close</b> or <see cref="M:System.IDisposable.Dispose" /> on a Connection, a DataReader, or any other managed object in the finalizer method of your class. In a finalizer, you should only release unmanaged resources that your class owns directly. If your class does not own any unmanaged resources, do not include a finalizer method in your class definition. For more information, see <see href="https://learn.microsoft.com/dotnet/standard/garbage-collection/">Garbage Collection</see>.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, and a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the data, writing it out to the console window. The code then closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is closed automatically at the end of the <c>using</c> code block.
        </para>
        <!-- SqlDataReader_Close -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI";
                  ReadOrderData(str);
              }
            
              private static void ReadOrderData(string connectionString)
              {
                  string queryString = "SELECT OrderID, CustomerID FROM dbo.Orders;";
          
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      connection.Open();
          
                      using (SqlCommand command = new SqlCommand(queryString, connection))
                      {
                          using (SqlDataReader reader = command.ExecuteReader())
                          {
                              // Call Read before accessing data.
                              while (reader.Read())
                              {
                                  Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));
                              }
          
                              // Call Close when done reading.
                              reader.Close();
                          }
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetBoolean(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a Boolean.
      </summary><returns>
        The value of the column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a Boolean, or an exception is generated.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetByte(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a byte.
      </summary><returns>
        The value of the specified column as a byte.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a byte.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><param name="dataIndex">
        The index within the field from which to begin the read operation.
      </param><param name="buffer">
        The buffer into which to read the stream of bytes.
      </param><param name="bufferIndex">
        The index within the <paramref name="buffer" /> where the write operation is to start.
      </param><param name="length">
        The maximum length to copy into the buffer.
      </param><summary>
        Reads a stream of bytes from the specified column offset into the buffer an array starting at the given buffer offset.
      </summary><returns>
        The actual number of bytes read.
      </returns><remarks>
        <para>
          <b>GetBytes</b> returns the number of available bytes in the field. Most of the time this is the exact length of the field. However, the number returned may be less than the true length of the field if <b>GetBytes</b> has already been used to obtain bytes from the field. This may be the case, for example, if the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is reading a large data structure into a buffer. For more information, see the <see cref="F:System.Data.CommandBehavior.SequentialAccess" /> setting for <see cref="T:System.Data.CommandBehavior" />.
        </para>
        <para>
          If you pass a buffer that is <see langword="null" />, <b>GetBytes</b> returns the length of the entire field in bytes, not the remaining size based on the buffer offset parameter.
        </para>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a byte array.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetChar(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a single character.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        Not supported for <see cref="T:Microsoft.Data.SqlClient" />.
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><param name="dataIndex">
        The index within the field from which to begin the read operation.
      </param><param name="buffer">
        The buffer into which to read the stream of bytes.
      </param><param name="bufferIndex">
        The index within the <paramref name="buffer" /> where the write operation is to start.
      </param><param name="length">
        The maximum length to copy into the buffer.
      </param><summary>
        Reads a stream of characters from the specified column offset into the buffer as an array starting at the given buffer offset.
      </summary><returns>
        The actual number of characters read.
      </returns><remarks>
        <para>
          <b>GetChars</b> returns the number of available characters in the field. Frequently this is the exact length of the field. However, the number returned may be less than the true length of the field if <b>GetChars</b> has already been used to obtain characters from the field. This may be the case, for example, if the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is reading a large data structure into a buffer. For more information, see the <see cref="F:System.Data.CommandBehavior.SequentialAccess" /> setting for <see cref="T:System.Data.CommandBehavior" />.
        </para>
        <para>
          The actual number of characters read can be less than the requested length, if the end of the field is reached. If you pass a buffer that is <see langword="null" />, <b>GetChars</b> returns the length of the entire field in characters, not the remaining size based on the buffer offset parameter.
        </para>
        <para>
          No conversions are performed; therefore. the data retrieved must already be a character array.
        </para>
        <note type="note">
          The <b>GetChars</b> method returns 0 when <paramref name="dataIndex" /> is negative.
        </note>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetColumnSchema">
            <summary>
        Gets the read-only column schema collection.
      </summary><returns>
        The read-only column schema collection).
      </returns><remarks>
        This method is an implementation of <see cref="M:System.Data.Common.IDbColumnSchemaGenerator.GetColumnSchema" /> method, which enables the use of the <see cref="T:System.Data.Common.IDbColumnSchemaGenerator" /> interface to populate the <see cref="T:System.Data.Common.DbColumn" /> schema metadata without using a <see cref="T:System.Data.DataTable" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetDataTypeName(System.Int32)">
            <param name="i">
        The zero-based ordinal position of the column to find.
      </param><summary>
        Gets a string representing the data type of the specified column.
      </summary><returns>
        The string representing the data type of the specified column.
      </returns><remarks>
        Returns the name of the back-end data type. <c>numeric</c> is a synonym in SQL Server for the <c>decimal</c> data type. <b>GetDataTypeName</b> will return "decimal" for a column defined as either decimal or numeric.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetDateTime(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.DateTime" /> object.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a <see cref="T:System.DateTime" /> object.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetDateTimeOffset(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Retrieves the value of the specified column as a <see cref="T:System.DateTimeOffset" /> object.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a <see cref="T:System.DateTimeOffset" /> object.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetDecimal(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Decimal" /> object.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a <see cref="T:System.Decimal" /> object.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetDouble(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a double-precision floating point number.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed. Therefore, the data retrieved must already be a double-precision floating point number.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetEnumerator">
            <summary>
        Returns an <see cref="T:System.Collections.IEnumerator" /> that iterates through the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><returns>
        An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </returns><remarks>
        Although you can use this method to retrieve an explicit enumerator, in languages that support a <c>foreach</c> construct, it is simpler to use the looping construct directly in order to iterate through the rows in the data reader.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetFieldType(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the <see cref="T:System.Type" /> that is the data type of the object.
      </summary><returns>
        The <see cref="T:System.Type" /> that is the data type of the object. If the type does not exist on the client, in the case of a User-Defined Type (UDT) returned from the database, <b>GetFieldType</b> returns null.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetFieldValue``1(System.Int32)">
            <typeparam name="T">
        The type of the value to be returned.
      </typeparam><param name="i">
        The column to be retrieved.
      </param><summary>
        Synchronously gets the value of the specified column as a type. <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetFieldValueAsync``1(System.Int32,System.Threading.CancellationToken)" /> is the asynchronous version of this method.
      </summary><returns>
        The returned type object.
      </returns><remarks>
        <para>
          <typeparamref name="T" /> can be one of the following types:
        </para>
        <list type="bullet">
          <item>Boolean (<c>bool</c>)</item>
          <item>Byte</item>
          <item>Char</item>
          <item>DateOnly (.NET 6 or later)</item>
          <item>DateTime</item>
          <item>DateTimeOffset</item>
          <item>Decimal</item>
          <item>Double</item>
          <item>Single (<c>float</c>)</item>
          <item>Guid</item>
          <item>Int16 (<c>short</c>)</item>
          <item>Int32 (<c>int</c>)</item>
          <item>Int64 (<c>long</c>)</item>
          <item>SqlBoolean</item>
          <item>SqlByte</item>
          <item>SqlDateTime</item>
          <item>SqlDecimal</item>
          <item>SqlDouble</item>
          <item>SqlGuid</item>
          <item>SqlInt16</item>
          <item>SqlInt32</item>
          <item>SqlInt64</item>
          <item>SqlMoney</item>
          <item>SqlSingle</item>
          <item>SqlString</item>
          <item>Stream</item>
          <item>String</item>
          <item>TextReader</item>
          <item>TimeOnly (.NET 6 or later)</item>
          <item>XmlReader</item>
          <item>UDT, which can be any CLR type marked with <see cref="T:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute" />.</item>
        </list>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The connection drops or is closed during the data retrieval.</item>
          <item>The <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed during the data retrieval.</item>
          <item>There is no data ready to be read (for example, the first <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> hasn't been called, or returned false).</item>
          <item>Tried to read a previously-read column in sequential mode.</item>
          <item>There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</item>
        </list>
      </exception><exception cref="T:System.IndexOutOfRangeException">
        Trying to read a column that does not exist.
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The value of the column was null (<see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> == <see langword="true" />), retrieving a non-SQL type.
      </exception><exception cref="T:System.InvalidCastException"><typeparamref name="T" /> doesn't match the type returned by SQL Server or cannot be cast.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetFieldValueAsync``1(System.Int32,System.Threading.CancellationToken)">
            <typeparam name="T">
        The type of the value to be returned.
      </typeparam><param name="i">
        The column to be retrieved.
      </param><param name="cancellationToken">
        The cancellation instruction, which propagates a notification that operations should be canceled. This does not guarantee the cancellation. A setting of <see langword="CancellationToken.None" /> makes this method equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" />. The returned task must be marked as cancelled.
      </param><summary>
        Asynchronously gets the value of the specified column as a type. <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetFieldValue``1(System.Int32)" /> is the synchronous version of this method.
      </summary><returns>
        The returned type object.
      </returns><remarks>
        <para>
          <typeparamref name="T" /> can be one of the following types:
        </para>
        <list type="bullet">
          <item>Boolean (<c>bool</c>)</item>
          <item>Byte</item>
          <item>Char</item>
          <item>DateOnly (.NET 6 or later)</item>
          <item>DateTime</item>
          <item>DateTimeOffset</item>
          <item>Decimal</item>
          <item>Double</item>
          <item>Single (<c>float</c>)</item>
          <item>Guid</item>
          <item>Int16 (<c>short</c>)</item>
          <item>Int32 (<c>int</c>)</item>
          <item>Int64 (<c>long</c>)</item>
          <item>SqlBoolean</item>
          <item>SqlByte</item>
          <item>SqlDateTime</item>
          <item>SqlDecimal</item>
          <item>SqlDouble</item>
          <item>SqlGuid</item>
          <item>SqlInt16</item>
          <item>SqlInt32</item>
          <item>SqlInt64</item>
          <item>SqlMoney</item>
          <item>SqlSingle</item>
          <item>SqlString</item>
          <item>Stream</item>
          <item>String</item>
          <item>TextReader</item>
          <item>TimeOnly (.NET 6 or later)</item>
          <item>XmlReader</item>
          <item>UDT, which can be any CLR type marked with <see cref="T:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute" />.</item>
        </list>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The connection drops or is closed during the data retrieval.</item>
          <item>The <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed during the data retrieval.</item>
          <item>There is no data ready to be read (for example, the first <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> hasn't been called, or returned false).</item>
          <item>Tried to read a previously-read column in sequential mode.</item>
          <item>There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</item>
        </list>
      </exception><exception cref="T:System.IndexOutOfRangeException">
        Trying to read a column that does not exist.
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The value of the column was null (<see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> == <see langword="true" />), retrieving a non-SQL type.
      </exception><exception cref="T:System.InvalidCastException"><typeparamref name="T" /> doesn't match the type returned by SQL Server or cannot be cast.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetFloat(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a single-precision floating point number.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed. Therefore, the data retrieved must already be a single-precision floating point number.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetGuid(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a globally unique identifier (GUID).
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a GUID.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetInt16(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a 16-bit signed integer.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a 16-bit signed integer.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetInt32(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a 32-bit signed integer.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a 32-bit signed integer.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetInt64(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a 64-bit signed integer.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a 64-bit signed integer.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetName(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the name of the specified column.
      </summary><returns>
        The name of the specified column.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetOrdinal(System.String)">
            <param name="name">
        The name of the column.
      </param><summary>
        Gets the column ordinal, given the name of the column.
      </summary><returns>
        The zero-based column ordinal.
      </returns><remarks>
        <para>
          <b>GetOrdinal</b> performs a case-sensitive lookup first. If it fails, a second, case-insensitive search occurs (a case-insensitive comparison is done using the database collation). Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter 'i' in "file". The method throws an <see cref="T:System.IndexOutOfRangeException" /> exception if the zero-based column ordinal is not found. <b>GetOrdinal</b> is kana-width insensitive.
        </para>
        <para>
          Because ordinal-based lookups are more efficient than named lookups, it is inefficient to call <b>GetOrdinal</b> within a loop. Save time by calling <b>GetOrdinal</b> once and assigning the results to an integer variable for use within the loop.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetOrdinal(System.String)" /> method.
        </para>
        <!-- SqlDataReader_GetOrdinal -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI";
                  ReadGetOrdinal(str);
              }
          
              private static void ReadGetOrdinal(string connectionString)
              {
                  string queryString = "SELECT DISTINCT CustomerID FROM dbo.Orders;";
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      connection.Open();
          
                      SqlDataReader reader = command.ExecuteReader();
          
                      // Call GetOrdinal and assign value to variable.
                      int customerID = reader.GetOrdinal("CustomerID");
          
                      // Use variable with GetString inside of loop.
                      while (reader.Read())
                      {
                          Console.WriteLine("CustomerID={0}", reader.GetString(customerID));
                      }
          
                      // Call Close when done reading.
                      reader.Close();
                  }
              }
          }
        </code>
      </example><exception cref="T:System.IndexOutOfRangeException">
        The name specified is not a valid column name.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetProviderSpecificFieldType(System.Int32)">
            <param name="i">
        An <see cref="T:System.Int32" /> representing the column ordinal.
      </param><summary>
        Gets an <see langword="Object" /> that is a representation of the underlying provider-specific field type.
      </summary><returns>
        Gets an <see cref="T:System.Object" /> that is a representation of the underlying provider-specific field type.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetProviderSpecificValue(System.Int32)">
            <param name="i">
        An <see cref="T:System.Int32" /> representing the column ordinal.
      </param><summary>
        Gets an <see langword="Object" /> that is a representation of the underlying provider specific value.
      </summary><returns>
        An <see cref="T:System.Object" /> that is a representation of the underlying provider specific value.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetProviderSpecificValues(System.Object[])">
            <param name="values">
        An array of <see cref="T:System.Object" /> into which to copy the column values.
      </param><summary>
        Gets an array of objects that are a representation of the underlying provider specific values.
      </summary><returns>
        The array of objects that are a representation of the underlying provider specific values.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlBinary(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlBinary" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlBinary" />.
      </returns><remarks>
        No conversions are performed; therefore the data retrieved must already be a binary structure or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlBoolean(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />.
      </summary><returns>
        The value of the column.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a Boolean or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlByte(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlByte" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlByte" />.
      </returns><remarks>
        No conversions are performed; therefore the data retrieved must already be a byte, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlBytes(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as <see cref="T:System.Data.SqlTypes.SqlBytes" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlBytes" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlChars(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as <see cref="T:System.Data.SqlTypes.SqlChars" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlChars" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlDateTime(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a date/time value, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlDecimal(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a decimal value, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlDouble(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlDouble" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlDouble" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a double-precision floating-point number, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlGuid(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlGuid" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlGuid" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a GUID, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlInt16(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlInt16" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlInt16" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a 16-bit signed integer, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlInt32(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlInt32" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlInt32" />.
      </returns><remarks>
        No conversions are performed; therefore the data retrieved must already be a 32-bit signed integer, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlInt64(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlInt64" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlInt64" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a 64-bit signed integer, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlMoney(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlMoney" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlMoney" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a decimal value, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlSingle(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlSingle" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlSingle" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a single precision floating point number, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlString(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlString" />.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlString" />.
      </returns><remarks>
        No conversions are performed; therefore, the data retrieved must already be a string, or an exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlValue(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Returns the data value in the specified column as a SQL Server type.
      </summary><returns>
        The value of the column expressed as a <see cref="T:System.Data.SqlDbType" />.
      </returns><remarks>
        <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlValue" /> returns data using the native SQL Server types. To retrieve data using the .NET Framework types, see <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetValue(System.Int32)" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlValues(System.Object[])">
            <param name="values">
        An array of <see cref="T:System.Object" /> into which to copy the values. The column values are expressed as SQL Server types.
      </param><summary>
        Fills an array of <see cref="T:System.Object" /> that contains the values for all the columns in the record, expressed as SQL Server types.
      </summary><returns>
        An integer indicating the number of columns copied.
      </returns><remarks>
        Returns the values for all the columns in the record in a single call, using the SQL type system instead of the CLR type system. The length of the <see cref="T:System.Object" /> array does not need to match the number of columns in the record. You can pass an <see cref="T:System.Object" /> array that contains fewer than the number of columns contained in the record. Only the amount of data the <see cref="T:System.Object" /> array holds is copied to the array, starting at the column with ordinal 0. You can also pass an <see cref="T:System.Object" /> array whose length is more than the number of columns contained in the resulting row. Any remaining columns are untouched.
      </remarks><exception cref="T:System.ArgumentNullException"><paramref name="values" /> is null.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSqlXml(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as an XML value.
      </summary><returns>
        A <see cref="T:System.Data.SqlTypes.SqlXml" /> value that contains the XML stored within the corresponding field.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be an XML value.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.ArgumentOutOfRangeException">
        The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1
      </exception><exception cref="T:System.InvalidOperationException">
        An attempt was made to read or access columns in a closed <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </exception><exception cref="T:System.InvalidCastException">
        The retrieved data is not compatible with the <see cref="T:System.Data.SqlTypes.SqlXml" /> type.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetSchemaTable">
            <summary>
        Returns a <see cref="T:System.Data.DataTable" /> that describes the column metadata of the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><returns>
        A <see cref="T:System.Data.DataTable" /> that describes the column metadata.
      </returns><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetSchemaTable" /> method returns the following metadata about each column:
        </para>
        <list type="table">
          <listheader>
            <term>DataReader column</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>AllowDBNull</term>
            <description>
              Set if the consumer can set the column to a null value or if the provider cannot determine whether the consumer can set the column to a null value. Otherwise, not set. A column may contain null values, even if it cannot be set to a null value.
            </description>
          </item>
          <item>
            <term>BaseCatalogName</term>
            <description>
              The name of the catalog in the data store that contains the column. NULL if the base catalog name cannot be determined. The default of this column is a null value.
            </description>
          </item>
          <item>
            <term>BaseColumnName</term>
            <description>
              The name of the column in the data store. This might be different than the column name returned in the ColumnName column if an alias was used. A null value if the base column name cannot be determined or if the rowset column is derived, but not identical to, a column in the data store. The default of this column is a null value.
            </description>
          </item>
          <item>
            <term>BaseSchemaName</term>
            <description>
              The name of the schema in the data store that contains the column. A null value if the base schema name cannot be determined. The default of this column is a null value.
            </description>
          </item>
          <item>
            <term>BaseServerName</term>
            <description>
              The name of the instance of Microsoft SQL Server used by the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
            </description>
          </item>
          <item>
            <term>BaseTableName</term>
            <description>
              The name of the table or view in the data store that contains the column. A null value if the base table name cannot be determined. The default of this column is a null value.
            </description>
          </item>
          <item>
            <term>ColumnName</term>
            <description>
              The name of the column; this might not be unique. If this cannot be determined, a null value is returned. This name always reflects the most recent renaming of the column in the current view or command text.
            </description>
          </item>
          <item>
            <term>ColumnOrdinal</term>
            <description>
              The zero-based ordinal of the column. This column cannot contain a null value.
            </description>
          </item>
          <item>
            <term>ColumnSize</term>
            <description>
              <para>
                The maximum possible length of a value in the column. For columns that use a fixed-length data type, this is the size of the data type. For <c>nvarchar(MAX)</c>, <c>varchar(MAX)</c>, and <c>varbinary(MAX)</c> columns stored in a SQL Server database, the maximum size is 2GB. If these columns are stored and accessed as files, the limit on maximum size is imposed by the file system. This value changes when using the <c>Type System Version</c> keyword in the connection string.
              </para>
              <para>
                For new types they are represented as downlevel types. The MAX data types return the normal 4k for <c>nvarchar</c> and 8000 for <c>varchar</c>. For more information, see the <see href="https://learn.microsoft.com/sql/t-sql/language-reference">Transact-SQL reference</see>.
              </para>
            </description>
          </item>
          <item>
            <term>DataTypeName</term>
            <description>
              Returns a string representing the data type of the specified column.
            </description>
          </item>
          <item>
            <term>IsAliased</term>
            <description>
              <para>
                <see langword="true" />: The column name is an alias.
              </para>
              <para>
                <see langword="false" />: The column name is not an alias.
              </para>
            </description>
          </item>
          <item>
            <term>IsAutoIncrement</term>
            <description>
              <para>
                <see langword="true" />: The column assigns values to new rows in fixed increments.
              </para>
              <para>
                <see langword="false" />: The column does not assign values to new rows in fixed increments. The default of this column is <see langword="false" />
              </para>
            </description>
          </item>
          <item>
            <term>IsColumnSet</term>
            <description>
              <see langword="true" />: The column is a sparse column that is a member of a column set.
            </description>
          </item>
          <item>
            <term>IsExpression</term>
            <description>
              <para>
                <see langword="true" />: The column is an expression.
              </para>
              <para>
                <see langword="false" />: The column is not an expression.
              </para>
            </description>
          </item>
          <item>
            <term>IsHidden</term>
            <description>
              <para>
                <see langword="true" />: The column is hidden.
              </para>
              <para>
                <see langword="false" />: The column is not hidden. 
              </para>
            </description>
          </item>
          <item>
            <term>IsIdentity</term>
            <description>
              <para>
                <see langword="true" />: The column is an identity column.
              </para>
              <para>
                <see langword="false" />: The column is not an identity column.
              </para>
            </description>
          </item>
          <item>
            <term>IsKey</term>
            <description>
              <para>
                <see langword="true" />: The column is one of a set of columns in the rowset that, taken together, uniquely identify the row. The set of columns with <c>IsKey</c> set to <see langword="true" /> must uniquely identify a row in the rowset. There is no requirement that this set of columns is a minimal set of columns. This set of columns may be generated from a base table primary key, a unique constraint or a unique index.
              </para>
              <para>
                <see langword="false" />: The column is not required to uniquely identify the row.
              </para>
            </description>
          </item>
          <item>
            <term>IsLong</term>
            <description>
              <para>
                <see langword="true" />: The column contains a Binary Long Object (BLOB) that contains very long data. The definition of very long data is provider-specific.
              </para>
              <para>
                <see langword="false" />: The column does not contain a Binary Long Object (BLOB) that contains very long data.
              </para>
            </description>
          </item>
          <item>
            <term>IsReadOnly</term>
            <description>
              <para>
               <see langword="true" />: The column cannot be modified. 
              </para>
              <para>
                <see langword="false" />: The column can be modified.
              </para>
            </description>
          </item>
          <item>
            <term>IsRowVersion</term>
            <description>
              <para>
                <see langword="true" />: The column contains a persistent row identifier that cannot be written to, and has no meaningful value except to identity the row.
              </para>
              <para>
                <see langword="false" />: The column does not contain a persistent row identifier that cannot be written to, and has no meaningful value except to identity the row.
              </para> 
            </description>
          </item>
          <item>
            <term>IsUnique</term>
            <description>
              <para>
                <see langword="true" />: Column is of type <c>timestamp</c>. 
              </para>
              <para>
                <see langword="false" />: Column is not of type <c>timestamp</c>.
              </para>
            </description>
          </item>
          <item>
            <term>NonVersionedProviderType</term>
            <description>
              The type of the column irrespective of the current <c>Type System Version</c> specified in the connection string. The returned value is from the <see cref="T:System.Data.SqlDbType" /> enumeration.
            </description>
          </item>
          <item>
            <term>NumericPrecision</term>
            <description>
              If <c>ProviderType</c> is a numeric data type, this is the maximum precision of the column. The precision depends on the definition of the column. If <c>ProviderType</c> is not a numeric data type, this is 255.
            </description>
          </item>
          <item>
            <term>NumericScale</term>
            <description>
              If <c>ProviderType</c> is DBTYPE_DECIMAL or DBTYPE_NUMERIC, the number of digits to the right of the decimal point. Otherwise, this is 255.
            </description>
          </item>
          <item>
            <term>ProviderSpecificDataType</term>
            <description>
              Returns the provider-specific data type of the column based on the <c>Type System Version</c> keyword in the connection string.
            </description>
          </item>
          <item>
            <term>ProviderType</term>
            <description>
              The indicator of the column's data type. If the data type of the column varies from row to row, this must be Object. This column cannot contain a null value.
            </description>
          </item>
          <item>
            <term>UdtAssemblyQualifiedName</term>
            <description>
              If the column is a user-defined type (UDT), this is the qualified name of the UDT's assembly as per <see cref="T:System.Type.AssemblyQualifiedName" />. If the column is not a UDT, this is null.
            </description>
          </item>
          <item>
            <term>XmlSchemaCollectionDatabase</term>
            <description>
              The name of the database where the schema collection for this XML instance is located, if the row contains information about an XML column. This value is <c>null</c> (<c>Nothing</c> in Visual Basic) if the collection is defined within the current database. It is also null if there is no schema collection, in which case the <c>XmlSchemaCollectionName</c> and <c>XmlSchemaCollectionOwningSchema</c> columns are also null.
            </description>
          </item>
          <item>
            <term>XmlSchemaCollectionName</term>
            <description>
              The name of the schema collection for this XML instance, if the row contains information about an XML column. This value is <c>null</c> (<c>Nothing</c> in Visual Basic) if there is no associated schema collection. If the value is null, the <c>XmlSchemaCollectionDatabase</c> and <c>XmlSchemaCollectionOwningSchema</c> columns are also null.
            </description>
          </item>
          <item>
            <term>XmlSchemaCollectionOwningSchema</term>
            <description>
              The owning relational schema where the schema collection for this XML instance is located, if the row contains information about an XML column. This value is <c>null</c> (<c>Nothing</c> in Visual Basic) if the collection is defined within the current database. It is also null if there is no schema collection, in which case the <c>XmlSchemaCollectionDatabase</c> and <c>XmlSchemaCollectionName</c> columns are also null.
            </description>
          </item>
        </list>
        <note type="note">
          To make sure that metadata columns return the correct information, you must call <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> with the <c>behavior</c> parameter set to <c>KeyInfo</c>. Otherwise, some of the columns in the schema table may return default, null, or incorrect data.
        </note>
      </remarks><exception cref="T:System.InvalidOperationException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetStream(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Retrieves binary, image, varbinary, UDT, and variant data types as a <see cref="T:System.IO.Stream" />.
      </summary><returns>
        A stream object.
      </returns><remarks>
        <para>
          <see cref="P:System.IO.Stream.ReadTimeout" /> defaults to the value of <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandTimeout" /> ; but you can modify <see cref="P:System.IO.Stream.ReadTimeout" /> via <b>GetStream</b>.
        </para>
        <para>
          Null values will be returned as an empty (zero bytes) <see cref="T:System.IO.Stream" />. <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" /> will raise an <see cref="T:System.InvalidOperationException" /> exception when used on an object returned by <b>GetStream</b> when <see cref="F:System.Data.CommandBehavior.SequentialAccess" /> is in effect. <see cref="T:Microsoft.Data.SqlClient.SqlException" /> exceptions raised from <see cref="T:System.IO.Stream" /> are thrown as <see cref="T:System.IO.IOException" /> exceptions; check the inner exception for the <see cref="T:Microsoft.Data.SqlClient.SqlException" />.
        </para>
        <para>
          The following <see cref="T:System.IO.Stream" /> members are not available for objects returned by <b>GetStream</b>:
        </para>
        <list type="bullet">
          <item>BeginWrite</item>
          <item>EndWrite</item>
          <item>Length</item>
          <item>Position</item>
          <item>Seek</item>
          <item>SetLength</item>
          <item>Write</item>
          <item>WriteByte</item>
          <item>WriteTimeout</item>
        </list>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The connection drops or is closed during the data retrieval.</item>
          <item>The <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed during the data retrieval.</item>
          <item>There is no data ready to be read (for example, the first <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> hasn't been called, or returned false).</item>
          <item>Tried to read a previously-read column in sequential mode.</item>
          <item>There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</item>
        </list>
      </exception><exception cref="T:System.IndexOutOfRangeException">
        Trying to read a column that does not exist.
      </exception><exception cref="T:System.InvalidCastException">
        <para>
          The returned type was not one of the types below:
        </para>
        <list type="bullet">
          <item>binary</item>
          <item>image</item>
          <item>varbinary</item>
          <item>udt</item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetString(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column as a string.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a string.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetTextReader(System.Int32)">
            <param name="i">
        The column to be retrieved.
      </param><summary>
        Retrieves Char, NChar, NText, NVarChar, text, varChar, and Variant data types as a <see cref="T:System.IO.TextReader" />.
      </summary><returns>
        The returned object.
      </returns><remarks>
        <para>
          <see cref="T:Microsoft.Data.SqlClient.SqlException" /> exceptions raised from <see cref="T:System.IO.TextReader" /> are thrown as <see cref="T:System.IO.IOException" /> exceptions; check the inner exception for the <see cref="T:Microsoft.Data.SqlClient.SqlException" />.
        </para>
        <para>
          Null values will be returned as an empty (zero bytes) <see cref="T:System.IO.TextReader" />. <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" /> will raise an <see cref="T:System.InvalidOperationException" /> exception when used on an object returned by <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetTextReader(System.Int32)" /> when <see cref="F:System.Data.CommandBehavior.SequentialAccess" /> is in effect.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The connection drops or is closed during the data retrieval.</item>
          <item>The <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed during the data retrieval.</item>
          <item>There is no data ready to be read (for example, the first <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> hasn't been called, or returned false).</item>
          <item>Tried to read a previously-read column in sequential mode.</item>
          <item>There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</item>
        </list>         
      </exception><exception cref="T:System.IndexOutOfRangeException">
        Trying to read a column that does not exist.
      </exception><exception cref="T:System.InvalidCastException">
        <para>The returned type was not one of the types below:</para>
        <list type="bullet">
          <item>char</item>
          <item>nchar</item>
          <item>ntext</item>
          <item>nvarchar</item>
          <item>text</item>
          <item>varchar</item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetTimeSpan(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Retrieves the value of the specified column as a <see cref="T:System.TimeSpan" /> object.
      </summary><returns>
        The value of the specified column.
      </returns><remarks>
        <para>
          No conversions are performed; therefore, the data retrieved must already be a <see cref="T:System.TimeSpan" /> object.
        </para>
        <para>
          Call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" /> to check for null values before calling this method.
        </para>
      </remarks><exception cref="T:System.InvalidCastException">
        The specified cast is not valid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetValue(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets the value of the specified column in its native format.
      </summary><returns>
        This method returns <see cref="T:System.DBNull" /> for null database columns.
      </returns><remarks>
        <b>GetValue</b> returns data using the .NET Framework types.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetValues(System.Object[])">
            <param name="values">
        An array of <see cref="T:System.Object" /> into which to copy the attribute columns.
      </param><summary>
        Populates an array of objects with the column values of the current row.
      </summary><returns>
        The number of instances of <see cref="T:System.Object" /> in the array.
      </returns><remarks>
        <para>
          For most applications, this method provides an efficient means for retrieving all columns, instead of retrieving each column individually.
        </para>
        <para>
          You can pass an <see cref="T:System.Object" /> array that contains fewer than the number of columns contained in the resulting row. Only the amount of data the <see cref="T:System.Object" /> array holds is copied to the array. You can also pass an <see cref="T:System.Object" /> array whose length is more than the number of columns contained in the resulting row.
        </para>
        <para>
          This method returns <see cref="T:System.DBNull" /> for null database columns.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates using a correctly sized  array  to read all values from the current row in the supplied <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. In addition, the sample demonstrates using a fixed-sized array that could be either smaller or larger than the number of available columns.
        </para>
        <!-- DataTableReader_GetValues #2 -->
        <code language="c#">
          // using Microsoft.Data.SqlClient;
          private static void TestGetValues(SqlDataReader reader)
          {
              // Given a SqlDataReader, use the GetValues
              // method to retrieve a full row of data.
              // Test the GetValues method, passing in an array large
              // enough for all the columns.
              Object[] values = new Object[reader.FieldCount];
              int fieldCount = reader.GetValues(values);
      
              Console.WriteLine("reader.GetValues retrieved {0} columns.",
                  fieldCount);
              for (int i = 0; i &lt; fieldCount; i++)
              {
                  Console.WriteLine(values[i]);
              }
      
              Console.WriteLine();
      
              // Now repeat, using an array that may contain a different 
              // number of columns than the original data. This should work correctly,
              // whether the size of the array is larger or smaller than 
              // the number of columns.
      
              // Attempt to retrieve three columns of data.
              values = new Object[3];
              fieldCount = reader.GetValues(values);
              Console.WriteLine("reader.GetValues retrieved {0} columns.", fieldCount);
              for (int i = 0; i &lt; fieldCount; i++)
              {
                  Console.WriteLine(values[i]);
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.GetXmlReader(System.Int32)">
            <param name="i">
        The value of the specified column.
      </param><summary>
        Retrieves data of type XML as an <see cref="T:System.Xml.XmlReader" />.
      </summary><returns>
        The returned object.
      </returns><remarks>
        <para>
          The <see cref="T:System.Xml.XmlReader" /> object returned by <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetXmlReader" /> does not support asynchronous operations. If you require asynchronous operations on an <see cref="T:System.Xml.XmlReader" />, cast the XML column to an NVARCHAR(MAX) on the server and use <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetTextReader(System.Int32)" /> with <see cref="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />. <see cref="T:Microsoft.Data.SqlClient.SqlException" /> exceptions raised from <see cref="T:System.Xml.XmlReader" /> are thrown as <see cref="T:System.Xml.XmlException" /> exceptions; check the inner exception for the <see cref="T:Microsoft.Data.SqlClient.SqlException" />. <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" /> will raise an <see cref="T:System.InvalidOperationException" /> exception when used on an object returned by <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetXmlReader(System.Int32)" /> when <see cref="F:System.Data.CommandBehavior.SequentialAccess" /> is in effect.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The connection drops or is closed during the data retrieval.</item>
          <item>The <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed during the data retrieval.</item>
          <item>There is no data ready to be read (for example, the first <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> hasn't been called, or returned false).</item>
          <item>Trying to read a previously read column in sequential mode.</item>
          <item>There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</item>
        </list>         
      </exception><exception cref="T:System.IndexOutOfRangeException">
        Trying to read a column that does not exist.
      </exception><exception cref="T:System.InvalidCastException">
        The returned type was not xml.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.IsCommandBehavior(System.Data.CommandBehavior)">
            <param name="condition">
        A <see cref="T:System.Data.CommandBehavior" /> enumeration.
      </param><summary>
        Determines whether the specified <see cref="T:System.Data.CommandBehavior" /> matches that of the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><returns>
        <see langword="true" /> if the specified <see cref="T:System.Data.CommandBehavior" /> is true, <see langword="false" /> otherwise.
      </returns><remarks>
        This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)">
            <param name="i">
        The zero-based column ordinal.
      </param><summary>
        Gets a value that indicates whether the column contains non-existent or missing values.
      </summary><returns>
        <see langword="true" /> if the specified column value is equivalent to <see cref="T:System.DBNull" /> ; otherwise <see langword="false" />.
      </returns><remarks>
        Call this method to check for null column values before calling the typed get methods (for example, <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetByte(System.Int32)" />, <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.GetChar(System.Int32)" />, and so on) to avoid raising an error.
      </remarks><example>
        <!-- SqlDataReader_IsDBNull -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main(string[] args)
              {
                  using (var connection = new SqlConnection(@"Data Source=(local);Initial Catalog=AdventureWorks2012;Integrated Security=SSPI"))
                  {
                      var command = new SqlCommand("SELECT p.FirstName, p.MiddleName, p.LastName FROM HumanResources.Employee AS e" +
                                              " JOIN Person.Person AS p ON e.BusinessEntityID = p.BusinessEntityID;", connection);
                      connection.Open();
                      var reader = command.ExecuteReader();
                      while (reader.Read())
                      {
                          Console.Write(reader.GetString(reader.GetOrdinal("FirstName")));
                          // display middle name only of not null
                          if (!reader.IsDBNull(reader.GetOrdinal("MiddleName")))
                          {
                              Console.Write(" {0}", reader.GetString(reader.GetOrdinal("MiddleName")));
                          }
                          Console.WriteLine(" {0}", reader.GetString(reader.GetOrdinal("LastName")));
                      }
                      connection.Close();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNullAsync(System.Int32,System.Threading.CancellationToken)">
            <param name="i">
        The zero-based column to be retrieved.
      </param><param name="cancellationToken">
        The cancellation instruction, which propagates a notification that operations should be canceled. This does not guarantee the cancellation. A setting of <see langword="CancellationToken.None" /> makes this method equivalent to <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" />. The returned task must be marked as cancelled.
      </param><summary>
        <para>
          An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" />, which gets a value that indicates whether the column contains non-existent or missing values.
        </para>
        <para>
          The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
        </para>
      </summary><returns><see langword="true" /> if the specified column value is equivalent to <see langword="DBNull" /> otherwise <see langword="false" />.</returns><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The connection drops or is closed during the data retrieval.</item>
          <item>The <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed during the data retrieval.</item>
          <item>There is no data ready to be read (for example, the first <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> hasn't been called, or returned false).</item>
          <item>Trying to read a previously read column in sequential mode.</item>
          <item>There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</item>
        </list>         
      </exception><exception cref="T:System.IndexOutOfRangeException">
        Trying to read a column that does not exist.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.NextResult">
            <summary>
        Advances the data reader to the next result, when reading the results of batch Transact-SQL statements.
      </summary><returns><see langword="true" /> if there are more result sets; otherwise <see langword="false" />.</returns><remarks>
        <para>
          Used to process multiple results, which can be generated by executing batch Transact-SQL statements.
        </para>
        <para>
          By default, the data reader is positioned on the first result.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.NextResultAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        <para>
          An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.NextResult" />, which advances the data reader to the next result, when reading the results of batch Transact-SQL statements.
        </para>
        <para>
          The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
        </para>
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        For more information about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
      </remarks><exception cref="T:System.InvalidOperationException">
        Calling <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.NextResultAsync(System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        SQL Server returned an error while executing the command text.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.Read">
            <summary>
        Advances the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> to the next record.
      </summary><returns><see langword="true" /> if there are more rows; otherwise <see langword="false" /></returns><remarks>
        <para>
          The default position of the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is before the first record. Therefore, you must call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> to begin accessing any data.
        </para>
        <para>
          Only one <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> per associated <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> may be open at a time, and any attempt to open another will fail until the first one is closed. Similarly, while the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is being used, the associated <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is busy serving it until you call <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Close" />.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />, a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />, and a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the data, writing it out to the console window. The code then closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> is closed automatically at the end of the <c>using</c> code block.
        </para>
        <!-- SqlDataReader_Read -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI";
                  ReadOrderData(str);
              }

              private static void ReadOrderData(string connectionString)
              {
                  string queryString = "SELECT OrderID, CustomerID FROM dbo.Orders;";

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      connection.Open();

                      SqlDataReader reader = command.ExecuteReader();

                      // Call Read before accessing data.
                      while (reader.Read())
                      {
                          ReadSingleRow((IDataRecord)reader);
                      }

                      // Call Close when done reading.
                      reader.Close();
                  }
              }

              private static void ReadSingleRow(IDataRecord record)
              {
                  Console.WriteLine(String.Format("{0}, {1}", record[0], record[1]));
              }
          }
        </code>
      </example><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        SQL Server returned an error while executing the command text.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDataReader.ReadAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        <para>
          An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" />, which advances the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> to the next record.
        </para>
        <para>
          The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.
        </para>
      </summary><returns>
        A task representing the asynchronous operation.
      </returns><remarks>
        <para>
          If the <c>behavior</c> parameter of <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync" /> is set to <c>Default</c>, <b>ReadAsync</b> reads the entire row before returning the Task.
        </para>
        <para>
          For more information, including code samples, about asynchronous programming in the .NET Framework Data Provider for SQL Server, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
        <note type="note">
          When reading large data (binary/text), it is recommended to use <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.Read" /> for optimal performance.
        </note>
      </remarks><exception cref="T:System.InvalidOperationException">
        Calling <see cref="M:Microsoft.Data.SqlClient.SqlDataReader.ReadAsync(System.Threading.CancellationToken)" /> more than once for the same instance before task completion.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        SQL Server returned an error while executing the command text.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlDependency">
            <summary>
        The <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object represents a query notification dependency between an application and an instance of SQL Server. An application can create a <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object and register to receive notifications via the <see cref="T:Microsoft.Data.SqlClient.OnChangeEventHandler" /> event handler.
      </summary><remarks>
        <para>
          <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> is ideal for caching scenarios, where your ASP.NET application or middle-tier service needs to keep certain information cached in memory. <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> allows you to receive notifications when the original data in the database changes so that the cache can be refreshed.
        </para>
        <para>
          To set up a dependency, you need to associate a <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object to one or more <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> objects. To receive notifications, you need to subscribe to the <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" /> event. For more information about the requirements for creating queries for notifications, see <see href="https://learn.microsoft.com/sql/relational-databases/native-client/features/working-with-query-notifications">Working with Query Notifications</see>.
        </para>
        <note type="note">
          <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> was designed to be used in ASP.NET or middle-tier services where there is a relatively small number of servers having dependencies active against the database. It was not designed for use in client applications, where hundreds or thousands of client computers would have <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> objects set up for a single database server. If you are developing an application where you need reliable sub-second notifications when data changes, review the sections <see href="https://learn.microsoft.com/previous-versions/sql/sql-server-2008-r2/ms187528(v=sql.105)#planning-an-efficient-query-notifications-strategy">Planning an Effective Query Notifications Strategy</see> and <see href="https://learn.microsoft.com/previous-versions/sql/sql-server-2008-r2/ms187528(v=sql.105)#alternatives-to-query-notifications">Alternatives to Query Notifications</see> in the <see href="https://learn.microsoft.com/previous-versions/sql/sql-server-2008-r2/ms187528(v=sql.105)">article</see>
        </note>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/query-notifications-sql-server">Query Notifications in SQL Server</see> and <see href="https://learn.microsoft.com/previous-versions/sql/sql-server-2005/ms171065(v=sql.90)">Building Notification Solutions</see>.
        </para>
        <note type="note">
          The <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" /> event may be generated on a different thread from the thread that initiated command execution.
        </note>
        <para>
          Query notifications are supported only for SELECT statements that meet a list of specific requirements.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.#ctor">
            <summary>
        Creates a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> class with the default settings.
      </summary><remarks>
        <para>
          The constructor initializes the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object using the default Service Broker service name and time-out. At some point after construction, you must use the <see cref="M:Microsoft.Data.SqlClient.SqlDependency.AddCommandDependency(Microsoft.Data.SqlClient.SqlCommand)" /> method to associate one or more commands to this <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object.
        </para>
        <para>
          Query notifications are supported only for SELECT statements that meet a list of specific requirements. For more information, see <see href="https://learn.microsoft.com/sql/database-engine/configure-windows/sql-server-service-broker">SQL Server Service Broker</see> and <see href="https://learn.microsoft.com/sql/connect/oledb/features/working-with-query-notifications">Working with Query Notifications</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.#ctor(Microsoft.Data.SqlClient.SqlCommand)">
            <param name="command">
        The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to associate with this <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object. The constructor will set up a <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> object and bind it to the command.
      </param><summary>
        Creates a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> class and associates it with the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> parameter.
      </summary><remarks>
        <para>
          Internally, this constructor creates an instance of the <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> class, and binds it to a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object.
        </para>
        <para>
          Query notifications are supported only for SELECT statements that meet a list of specific requirements. For more information, see <see href="https://learn.microsoft.com/sql/database-engine/configure-windows/sql-server-service-broker">SQL Server Service Broker</see> and <see href="https://learn.microsoft.com/sql/connect/oledb/features/working-with-query-notifications">Working with Query Notifications</see>.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="command" /> parameter is NULL.
      </exception><exception cref="T:System.InvalidOperationException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object already has a <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> object assigned to its <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Notification" /> property, and that <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> is not associated with this dependency.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.#ctor(Microsoft.Data.SqlClient.SqlCommand,System.String,System.Int32)">
            <param name="command">
        The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object to associate with this <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object. The constructor sets up a <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> object and bind it to the command.
      </param><param name="options">
        The notification request options to be used by this dependency. <see langword="null" /> to use the default service.
      </param><param name="timeout">
        The time-out for this notification in seconds. The default is 0, indicating that the server's time-out should be used.
      </param><summary>
        Creates a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> class, associates it with the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> parameter, and specifies notification options and a time-out value.
      </summary><remarks>
        Query notifications are supported only for SELECT statements that meet a list of specific requirements. For more information, see <see href="https://learn.microsoft.com/sql/database-engine/configure-windows/sql-server-service-broker">SQL Server Service Broker</see> and <see href="https://learn.microsoft.com/sql/connect/oledb/features/working-with-query-notifications">Working with Query Notifications</see>.
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="command" /> parameter is NULL.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        The time-out value is less than zero.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>
            The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object already has a <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> object assigned to its <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Notification" /> property and that <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> is not associated with this dependency.
          </item>
          <item>
            An attempt was made to create a <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> instance from within SQLCLR.
          </item>
        </list>
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDependency.HasChanges">
            <summary>
        Gets a value that indicates whether one of the result sets associated with the dependency has changed.
      </summary><value>
        A Boolean value indicating whether one of the result sets has changed.
      </value><remarks>
        <para>
          If you are not using the <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" /> event, you can check the <see cref="P:Microsoft.Data.SqlClient.SqlDependency.HasChanges" /> property to determine if the query results have changed.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlDependency.HasChanges" /> property does not necessarily imply a change in the data. Other circumstances, such as time-out expired and failure to set the notification request, also generate a change event.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlDependency.Id">
            <summary>
        Gets a value that uniquely identifies this instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> class.
      </summary><value>
        A string representation of a GUID that is generated for each instance of the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> class.
      </value><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlDependency.Id" /> property is used to uniquely identify a given <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> instance.
      </remarks>
        </member>
        <member name="E:Microsoft.Data.SqlClient.SqlDependency.OnChange">
            <summary>
        Occurs when a notification is received for any of the commands associated with this <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object.
      </summary><remarks>
        <para>
          <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" /> occurs when the results for the associated command change. If you are not using <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" />, you can check the <see cref="P:Microsoft.Data.SqlClient.SqlDependency.HasChanges" /> property to determine whether the query results have changed.
        </para>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" /> event does not necessarily imply a change in the data. Other circumstances, such as time-out expired and failure to set the notification request, also generate <see cref="E:Microsoft.Data.SqlClient.SqlDependency.OnChange" />.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.AddCommandDependency(Microsoft.Data.SqlClient.SqlCommand)">
            <param name="command">
        A <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object containing a statement that is valid for notifications.
      </param><summary>
        Associates a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object with this <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> instance.
      </summary><remarks>
        Query notifications are supported only for SELECT statements that meet a list of specific requirements. For more information, see <see href="https://learn.microsoft.com/sql/database-engine/configure-windows/sql-server-service-broker">SQL Server Service Broker</see> and <see href="https://learn.microsoft.com/sql/connect/oledb/features/working-with-query-notifications">Working with Query Notifications</see>.
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="command" /> parameter is null.
      </exception><exception cref="T:System.InvalidOperationException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> object already has a <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> object assigned to its <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Notification" /> property, and that <see cref="T:Microsoft.Data.Sql.SqlNotificationRequest" /> is not associated with this dependency.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String)">
            <param name="connectionString">
        The connection string for the instance of SQL Server from which to obtain change notifications.
      </param><summary>
        Starts the listener for receiving dependency change notifications from the instance of SQL Server specified by the connection string.
      </summary><returns> <see langword="true" /> if the listener initialized successfully; <see langword="false" /> if a compatible listener already exists.</returns><remarks>
        <para>
          This method starts the listener for the <see cref="T:System.AppDomain" /> for receiving dependency notifications from the instance of SQL Server specified by the <paramref name="connectionString" /> parameter. This method may be called more than once with different connection strings for multiple servers.
        </para>
        <para>
          Multiple calls to the <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start" /> method can be made, subject to the following restrictions:
        </para>
        <list type="bullet">
          <item>Multiple calls with identical parameters (the same connection string and Windows credentials in the calling thread) are valid.</item>
          <item>
            Multiple calls with different connection strings are valid as long as:
            <list type="bullet">
              <item>Each connection string specifies a different database, or</item>
              <item>Each connection string specifies a different user, or</item>
              <item>The calls come from different application domains.</item>
            </list>
          </item>
        </list>
        <para>
          You can make the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> work correctly for applications that use multiple threads to represent different user credentials without giving the dbo role to the group, because different users can subscribe and listen (using <see cref="T:System.Web.Caching.SqlCacheDependency" /> or <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />) to a notification queue created by an administrator. When the relevant application domain starts, call Start with the (Windows) credentials of a user that has permission to initialize a service/queue (the CREATE QUEUE and CREATE SERVICE permissions for the database). Ensure that Start is only called once per AppDomain, otherwise an ambiguity exception is raised.  The user thread must have permission to subscribe to the notification (the <c>SUBSCRIBE QUERY NOTIFICATIONS</c> permission for the database). <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> will associate the subscription request of a non-administrator user to the service/queue created by the administrator.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="connectionString" /> parameter is NULL.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The <paramref name="connectionString" /> parameter is the same as a previous call to this method, but the parameters are different.</item>
          <item>The method was called from within the CLR.</item>
        </list>
      </exception><exception cref="T:System.Security.SecurityException">
        The caller does not have the required <see cref="T:Microsoft.Data.SqlClient.SqlClientPermission" /> code access security (CAS) permission.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        A subsequent call to the method has been made with an equivalent <paramref name="connectionString" /> parameter with a different user, or a user that does not default to the same schema. Also, any underlying <b>SqlClient</b> exceptions.
      </exception><seealso cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String,System.String)">
            <param name="connectionString">
        The connection string for the instance of SQL Server from which to obtain change notifications.
      </param><param name="queue">
        An existing SQL Server Service Broker queue to be used. If <see langword="null" />, the default queue is used.
      </param><summary>
        Starts the listener for receiving dependency change notifications from the instance of SQL Server specified by the connection string using the specified SQL Server Service Broker queue.
      </summary><returns><see langword="true" /> if the listener initialized successfully; <see langword="false" /> if a compatible listener already exists.</returns><remarks>
        <para>
          This method starts the listener for the <see cref="T:System.AppDomain" /> for receiving dependency notifications from the instance of SQL Server specified by the <paramref name="connectionString" /> parameter. This method may be called more than once with different connection strings for multiple servers.
        </para>
        <para>
          If no queue name is specified, <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> creates a temporary queue and service in the server that is used for the entire process, even if the process involves more than one <see cref="T:System.AppDomain" />. The queue and service are automatically removed upon application shutdown.
        </para>
        <para>
          Multiple calls to the <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start" /> method can be made, subject to the following restrictions:
        </para>
        <list type="bullet">
          <item>Multiple calls with identical parameters (the same connection string and Windows credentials in the calling thread) are valid.</item>
          <item>
            Multiple calls with different connection strings are valid as long as:
            <list type="bullet">
              <item>Each connection string specifies a different database, or</item>
              <item>Each connection string specifies a different user, or</item>
              <item>The calls come from different application domains.</item>
            </list>
          </item>
        </list>
        <para>
          You can make the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> work correctly for applications that use multiple threads to represent different user credentials without giving the dbo role to the group, because different users can subscribe and listen (using <see cref="T:System.Web.Caching.SqlCacheDependency" /> or <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />) to a notification queue created by an administrator. When the relevant application domain starts, call Start with the (Windows) credentials of a user that has permission to initialize a service/queue (the CREATE QUEUE and CREATE SERVICE permissions for the database). Ensure that Start is only called once per AppDomain, otherwise an ambiguity exception is raised.  The user thread must have permission to subscribe to the notification (the <c>SUBSCRIBE QUERY NOTIFICATIONS</c> permission for the database). <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> will associate the subscription request of a non-administrator user to the service/queue created by the administrator.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="connectionString" /> parameter is NULL.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The <paramref name="connectionString" /> parameter is the same as a previous call to this method, but the parameters are different.</item>
          <item>The method was called from within the CLR.</item>
        </list>
      </exception><exception cref="T:System.Security.SecurityException">
        The caller does not have the required <see cref="T:Microsoft.Data.SqlClient.SqlClientPermission" /> code access security (CAS) permission.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        A subsequent call to the method has been made with an equivalent <paramref name="connectionString" /> parameter but a different user, or a user that does not default to the same schema. Also, any underlying <b>SqlClient</b> exceptions.
      </exception><seealso cref="P:Microsoft.Data.SqlClient.SqlConnection.ConnectionString" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.Stop(System.String)">
            <param name="connectionString">
        Connection string for the instance of SQL Server that was used in a previous <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String)" /> call.
      </param><summary>
        Stops a listener for a connection specified in a previous <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String)" /> call.
      </summary><returns><see langword="true" /> if the listener was completely stopped; <see langword="false" /> if the <see cref="T:System.AppDomain" /> was unbound from the listener, but there are is at least one other <see cref="T:System.AppDomain" /> using the same listener.</returns><remarks>
        The <b>Stop</b> method must be called for each <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String)" /> call. A given listener only shuts down fully when it receives the same number of <b>Stop</b> requests as <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String)" /> requests.
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="connectionString" /> parameter is NULL.
      </exception><exception cref="T:System.InvalidOperationException">
        The method was called from within SQLCLR.
      </exception><exception cref="T:System.Security.SecurityException">
        The caller does not have the required <see cref="T:Microsoft.Data.SqlClient.SqlClientPermission" /> code access security (CAS) permission.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        An underlying <b>SqlClient</b> exception occurred.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlDependency.Stop(System.String,System.String)">
            <param name="connectionString">
        Connection string for the instance of SQL Server that was used in a previous <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String,System.String)" /> call.
      </param><param name="queue">
        The SQL Server Service Broker queue that was used in a previous <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String,System.String)" /> call.
      </param><summary>
        Stops a listener for a connection specified in a previous <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String,System.String)" /> call.
      </summary><returns><see langword="true" /> if the listener was completely stopped; <see langword="false" /> if the <see cref="T:System.AppDomain" /> was unbound from the listener, but there is at least one other <see cref="T:System.AppDomain" /> using the same listener.</returns><remarks>
        The <b>Stop</b> method must be called for each <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String)" /> call. A given listener only shuts down fully when it receives the same number of <b>Stop</b> requests as <see cref="M:Microsoft.Data.SqlClient.SqlDependency.Start(System.String)" /> requests.
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="connectionString" /> parameter is NULL.
      </exception><exception cref="T:System.InvalidOperationException">
        The method was called from within SQLCLR.
      </exception><exception cref="T:System.Security.SecurityException">
        The caller does not have the required <see cref="T:Microsoft.Data.SqlClient.SqlClientPermission" /> code access security (CAS) permission.
      </exception><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        And underlying <b>SqlClient</b> exception occurred.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlError">
            <summary>
        Collects information relevant to a warning or error returned by SQL Server.
      </summary><remarks>
        <para>
          This class is created by the .NET Framework Data Provider for SQL Server when an error occurs. An instance of <see cref="T:Microsoft.Data.SqlClient.SqlError" /> is created and managed by the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />, which in turn is created by the <see cref="T:Microsoft.Data.SqlClient.SqlException" /> class.
        </para>
        <para>
          Messages with a severity level of 10 or less are informational and indicate problems caused by mistakes in information that a user has entered. Severity levels from 11 through 16 are generated by the user, and can be corrected by the user. Severity levels from 17 through 25 indicate software or hardware errors. When a level 17, 18, or 19 error occurs, you can continue working, although you might not be able to execute a particular statement.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server usually closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. In both cases, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing the command.
        </para>
        <para>
          For more information on errors generated by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine events and errors</see>. For more information about severity levels, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-error-severities">Database Engine Error Severities</see>.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_ToString -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          DisplaySqlErrors(ex);
                      }
                  }
              }

              private static void DisplaySqlErrors(SqlException exception)
              {
                  for (int i = 0; i &lt; exception.Errors.Count; i++)
                  {
                      Console.WriteLine("Index #" + i + "\n" +
                          "Error: " + exception.Errors[i].ToString() + "\n");
                  }
                  Console.ReadLine();
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /><seealso cref="T:Microsoft.Data.SqlClient.SqlException" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.Class">
            <summary>
        Gets the severity level of the error returned from SQL Server.
      </summary><value>
        A value from 1 to 25 that indicates the severity level of the error. The default is 0.
      </value><remarks>
        <para>
          Messages with a severity level of 10 or less are informational and indicate problems caused by mistakes in information that a user has entered. Severity levels from 11 through 16 are generated by the user, and can be corrected by the user. Severity levels from 17 through 25 indicate software or hardware errors. When a level 17, 18, or 19 error occurs, you can continue working, although you might not be able to execute a particular statement.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server usually closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. In both cases, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing the command.
        </para>
        <para>
          For more information on errors generated by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.LineNumber">
            <summary>
        Gets the line number within the Transact-SQL command batch or stored procedure that contains the error.
      </summary><value>
        The line number within the Transact-SQL command batch or stored procedure that contains the error.
      </value><remarks>
        <para>
          Line numbering starts at 1. If the value is 0, the line number is not applicable.
        </para>
        <para>
          For more information on errors generated by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.Message">
            <summary>
        Gets the text describing the error.
      </summary><value>
        The text describing the error. For more information on errors generated by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">
          Database Engine Events and Errors
        </see>.
      </value><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.Number">
            <summary>
        Gets a number that identifies the type of error.
      </summary><value>
        The number that identifies the type of error.
      </value><remarks>
        <para>
          The following table describes the possible values for this property:
        </para>
        <list type="table">
          <listheader>
            <term>Source of Error</term>
            <description>SqlError.Number</description>
            <description>SqlError.State</description>
            <description>SqlException has inner Win32Exception (beginning with.NET Framework 4.5)</description>
          </listheader>
          <item>
            <term>Error from server</term>
            <description>
              <para>
                Server error code
              </para>
              <para>
                This number corresponds to an entry in the <c>master.dbo.sysmessages</c> table.
              </para>
            </description>
            <description>Typically greater than 0</description>
            <description>No</description>
          </item>
          <item>
            <term>Connection timeout</term>
            <description>-2</description>
            <description>0</description>
            <description>Yes (Number = 258)</description>
          </item>
          <item>
            <term>Communication error (non-LocalDB)</term>
            <description>Win32 error code</description>
            <description>0</description>
            <description>Yes (Number = Win32 error code)</description>
          </item>
          <item>
            <term>Communication error (LocalDB)</term>
            <description>Win32 error code</description>
            <description>0</description>
            <description>No</description>
          </item>
          <item>
            <term>Encryption capability mismatch</term>
            <description>20</description>
            <description>0</description>
            <description>No</description>
          </item>
          <item>
            <term>Failed to start LocalDB</term>
            <description>Win32 error code</description>
            <description>0</description>
            <description>No</description>
          </item>
          <item>
            <term>Read-only routing failure</term>
            <description>0</description>
            <description>0</description>
            <description>No</description>
          </item>
          <item>
            <term>Server had severe error processing query</term>
            <description>0</description>
            <description>0</description>
            <description>No</description>
          </item>
          <item>
            <term>Processed cancellation while parsing results</term>
            <description>0</description>
            <description>0</description>
            <description>No</description>
          </item>
          <item>
            <term>Failed to create user instance</term>
            <description>0</description>
            <description>0</description>
            <description>No</description>
          </item>
        </list>
        <para>
          For more information on errors generated by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.Procedure">
            <summary>
        Gets the name of the stored procedure or remote procedure call (RPC) that generated the error.
      </summary><value>
        The name of the stored procedure or RPC. For more information on errors generated by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
      </value><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.Server">
            <summary>
        Gets the name of the instance of SQL Server that generated the error.
      </summary><value>
        The name of the instance of SQL Server.
      </value><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.Source">
            <summary>
        Gets the name of the provider that generated the error.
      </summary><value>
        The name of the provider that generated the error.
      </value><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlError.State">
            <summary>
        Some error messages can be raised at multiple points in the code for the Database Engine. For example, an 1105 error can be raised for several different conditions. Each specific condition that raises an error assigns a unique state code.
      </summary><value>
        The state code.
      </value><remarks>
        <para>
          State is only set for errors that are received from the server.
        </para>
        <para>
          For more information on errors generated by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/understanding-database-engine-errors">Understanding Database Engine Errors</see>.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_State -->
        <code language="c#">
          using System;
          using System.Collections.Generic;
          using System.Text;
          using Microsoft.Data.SqlClient;

          namespace Classic_WebData_SqlError.StateCS
          {
              class Program
              {
                  static void Main()
                  {
                      //DisplaySqlErrors();
                  }

                  public void DisplaySqlErrors(SqlException exception)
                  {
                      for (int i = 0; i &lt; exception.Errors.Count; i++)
                      {
                          Console.WriteLine("Index #" + i + "\n" +
                              "Source: " + exception.Errors[i].Source + "\n" +
                              "Number: " + exception.Errors[i].Number.ToString() + "\n" +
                              "State: " + exception.Errors[i].State.ToString() + "\n" +
                              "Class: " + exception.Errors[i].Class.ToString() + "\n" +
                              "Server: " + exception.Errors[i].Server + "\n" +
                              "Message: " + exception.Errors[i].Message + "\n" +
                              "Procedure: " + exception.Errors[i].Procedure + "\n" +
                              "LineNumber: " + exception.Errors[i].LineNumber.ToString());
                      }
                      Console.ReadLine();
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlError.ToString">
            <summary>
        Gets the complete text of the error message.
      </summary><returns>
        The complete text of the error.
      </returns><remarks>
        <para>
          The string is in the form "SqlError:", followed by the <see cref="P:Microsoft.Data.SqlClient.SqlError.Message" />, and the stack trace. For example:
        </para>
        <code>
          SqlError:UserId or Password not valid. \&lt;stack trace&gt;
        </code>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_ToString -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          DisplaySqlErrors(ex);
                      }
                  }
              }

              private static void DisplaySqlErrors(SqlException exception)
              {
                  for (int i = 0; i &lt; exception.Errors.Count; i++)
                  {
                      Console.WriteLine("Index #" + i + "\n" +
                          "Error: " + exception.Errors[i].ToString() + "\n");
                  }
                  Console.ReadLine();
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlErrorCollection">
            <summary>
        Collects all errors generated by the .NET Framework Data Provider for SQL Server. This class cannot be inherited.
      </summary><remarks>
        This class is created by <see cref="T:Microsoft.Data.SqlClient.SqlException" /> to collect instances of the <see cref="T:Microsoft.Data.SqlClient.SqlError" /> class. <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> always contains at least one instance of the <see cref="T:Microsoft.Data.SqlClient.SqlError" /> class.
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_ToString -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          DisplaySqlErrors(ex);
                      }
                  }
              }

              private static void DisplaySqlErrors(SqlException exception)
              {
                  for (int i = 0; i &lt; exception.Errors.Count; i++)
                  {
                      Console.WriteLine("Index #" + i + "\n" +
                          "Error: " + exception.Errors[i].ToString() + "\n");
                  }
                  Console.ReadLine();
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                      + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="T:Microsoft.Data.SqlClient.SqlError" /><seealso cref="T:Microsoft.Data.SqlClient.SqlException" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlErrorCollection.Count">
            <summary>
        Gets the number of errors in the collection.
      </summary><value>
        The total number of errors in the collection.
      </value><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_ToString -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          DisplaySqlErrors(ex);
                      }
                  }
              }

              private static void DisplaySqlErrors(SqlException exception)
              {
                  for (int i = 0; i &lt; exception.Errors.Count; i++)
                  {
                      Console.WriteLine("Index #" + i + "\n" +
                          "Error: " + exception.Errors[i].ToString() + "\n");
                  }
                  Console.ReadLine();
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                      + "Integrated Security=SSPI";
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlErrorCollection.Item(System.Int32)">
            <param name="index">
        The zero-based index of the error to retrieve.
      </param><summary>
        Gets the error at the specified index.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SqlError" /> that contains the error at the specified index.
      </value><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_ToString -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          DisplaySqlErrors(ex);
                      }
                  }
              }

              private static void DisplaySqlErrors(SqlException exception)
              {
                  for (int i = 0; i &lt; exception.Errors.Count; i++)
                  {
                      Console.WriteLine("Index #" + i + "\n" +
                          "Error: " + exception.Errors[i].ToString() + "\n");
                  }
                  Console.ReadLine();
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                      + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><exception cref="T:System.IndexOutOfRangeException">
        Index parameter is outside array bounds.
      </exception><seealso cref="P:Microsoft.Data.SqlClient.SqlErrorCollection.Count" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlErrorCollection.System#Collections#ICollection#IsSynchronized">
            <summary>
        For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.
      </summary><value>
        <see langword="true" /> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, <see langword="false" />.
      </value><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> instance is cast to an <see cref="T:System.Collections.ICollection" /> interface.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlErrorCollection.System#Collections#ICollection#SyncRoot">
            <summary>
        For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.
      </summary><value>
        An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
      </value><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> instance is cast to an <see cref="T:System.Collections.ICollection" /> interface.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlErrorCollection.CopyTo(System.Array,System.Int32)">
            <param name="array">
        The <see cref="T:System.Array" /> to copy elements into.
      </param><param name="index">
        The index from which to start copying into the <paramref name="array" /> parameter.
      </param><summary>
        Copies the elements of the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection into an <see cref="T:System.Array" />, starting at the specified index.
      </summary><exception cref="T:System.ArgumentException">
        The sum of <paramref name="index" /> and the number of elements in the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection is greater than the <see cref="P:System.Array.Length" /> of the <see cref="T:System.Array" />.
      </exception><exception cref="T:System.ArgumentNullException">
        The <paramref name="array" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="index" /> is not valid for <paramref name="array" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlErrorCollection.CopyTo(Microsoft.Data.SqlClient.SqlError[],System.Int32)">
            <param name="array">
        The <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> to copy the elements into.
      </param><param name="index">
        The index from which to start copying into the <paramref name="array" /> parameter.
      </param><summary>
        Copies the elements of the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection into a <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />, starting at the specified index.
      </summary><exception cref="T:System.ArgumentException">
        The sum of <paramref name="index" /> and the number of elements in the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection is greater than the length of the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />.
      </exception><exception cref="T:System.ArgumentNullException">
        The <paramref name="array" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="index" /> is not valid for <paramref name="array" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlErrorCollection.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />.
      </summary><returns>
        An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />.
      </returns><remarks>
        Enumerators can be used to read the data in a collection, but they cannot be used to modify the underlying collection.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlException">
            <summary>
        The exception that is thrown when SQL Server returns a warning or error. This class cannot be inherited.
      </summary><remarks>
        <para>
          This class is created whenever the .NET Framework Data Provider for SQL Server encounters an error generated from the server. (Client side errors are thrown as standard common language runtime exceptions.) <see cref="T:Microsoft.Data.SqlClient.SqlException" /> always contains at least one instance of <see cref="T:Microsoft.Data.SqlClient.SqlError" />.
        </para>
        <para>
          Messages that have a severity level of 10 or less are informational and indicate problems caused by mistakes in information that a user has entered. Severity levels from 11 through 16 are generated by the user, and can be corrected by the user. Severity levels from 17 through 25 indicate software or hardware errors. When a level 17, 18, or 19 error occurs, you can continue working, although you might not be able to execute a particular statement.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. In both cases, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing the command.
        </para>
        <para>
          For information about the warning and informational messages sent by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>. The <see cref="T:Microsoft.Data.SqlClient.SqlException" /> class maps to SQL Server severity.
        </para>
        <para>
          The following is general information on handling exceptions. Your code should catch exceptions to prevent the application from crashing and to allow displaying a relevant error message to the user.  You can use database transactions to ensure that the data is consistent regardless of what happens in the client application (including a crash). Features like <see cref="T:System.Transactions.TransactionScope" /> or the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> ensure consistent data regardless of exceptions raised by a provider. Transactions can fail, so catch failures and retry the transaction.
        </para>
        <para>
          Note that beginning with .NET Framework 4.5, <see cref="T:Microsoft.Data.SqlClient.SqlException" /> can return an inner <see cref="T:System.ComponentModel.Win32Exception" />.
        </para>
        <para>
          The exception class of a .NET Framework data provider reports provider-specific errors. For example System.Data.Odbc has <see cref="T:System.Data.Odbc.OdbcException" />, System.Data.OleDb has <see cref="T:System.Data.OleDb.OleDbException" />, and Microsoft.Data.SqlClient has <b>SqlException</b>. For the best level of error detail, catch these exceptions and use the members of these exception classes to get details of the error.
        </para>
        <para>
          Bad input can cause a .NET Framework data provider type to raise an exception such as System.ArgumentException or System.IndexOutOfRangeException. Calling a method at the wrong time can raise System.InvalidOperationException.
        </para>
        <para>
          So, in general, write an exception handler that catches any provider specific exceptions as well as exceptions from the common language runtime. These can be layered as follows:
        </para>
        <code language="c#">
          try
'         {
              // code here
          }
          catch (SqlException sqlEx)
          {
              // Handle more specific SqlException exception here.
          }
          catch (Exception ex)
          {
              // Handle generic ones here.
          }
        </code>
        <para>Or:</para>
        <code language="c#">
          try
          {
              // code here
          }
          catch (Exception ex)
          {
              if (ex is SqlException)
              {
                  // Handle more specific SqlException exception here.
              }
              else
              {
                  // Handle generic ones here.
              }
          }
        </code>
        <para>
          It is also possible for a .NET Framework data provider method call to fail on a thread pool thread with no user code on the stack. In this case, and when using asynchronous method calls, you must register the <see cref="T:System.AppDomain.UnhandledException" /> event to handle those exceptions and avoid application crash.
        </para>
      </remarks><example>
        <para>
          The following example generates a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> and then displays the exception.
        </para>
        <!-- SqlException_Errors1 -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="T:Microsoft.Data.SqlClient.SqlError" /><seealso cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />
            <summary>
        The exception that is thrown when SQL Server returns a warning or error. This class cannot be inherited.
      </summary><remarks>
        <para>
          This class is created whenever the .NET Framework Data Provider for SQL Server encounters an error generated from the server. (Client side errors are thrown as standard common language runtime exceptions.) <see cref="T:Microsoft.Data.SqlClient.SqlException" /> always contains at least one instance of <see cref="T:Microsoft.Data.SqlClient.SqlError" />.
        </para>
        <para>
          Messages that have a severity level of 10 or less are informational and indicate problems caused by mistakes in information that a user has entered. Severity levels from 11 through 16 are generated by the user, and can be corrected by the user. Severity levels from 17 through 25 indicate software or hardware errors. When a level 17, 18, or 19 error occurs, you can continue working, although you might not be able to execute a particular statement.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. In both cases, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing the command.
        </para>
        <para>
          For information about the warning and informational messages sent by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>. The <see cref="T:Microsoft.Data.SqlClient.SqlException" /> class maps to SQL Server severity.
        </para>
        <para>
          The following is general information on handling exceptions. Your code should catch exceptions to prevent the application from crashing and to allow displaying a relevant error message to the user.  You can use database transactions to ensure that the data is consistent regardless of what happens in the client application (including a crash). Features like <see cref="T:System.Transactions.TransactionScope" /> or the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> ensure consistent data regardless of exceptions raised by a provider. Transactions can fail, so catch failures and retry the transaction.
        </para>
        <para>
          Note that beginning with .NET Framework 4.5, <see cref="T:Microsoft.Data.SqlClient.SqlException" /> can return an inner <see cref="T:System.ComponentModel.Win32Exception" />.
        </para>
        <para>
          The exception class of a .NET Framework data provider reports provider-specific errors. For example System.Data.Odbc has <see cref="T:System.Data.Odbc.OdbcException" />, System.Data.OleDb has <see cref="T:System.Data.OleDb.OleDbException" />, and Microsoft.Data.SqlClient has <b>SqlException</b>. For the best level of error detail, catch these exceptions and use the members of these exception classes to get details of the error.
        </para>
        <para>
          Bad input can cause a .NET Framework data provider type to raise an exception such as System.ArgumentException or System.IndexOutOfRangeException. Calling a method at the wrong time can raise System.InvalidOperationException.
        </para>
        <para>
          So, in general, write an exception handler that catches any provider specific exceptions as well as exceptions from the common language runtime. These can be layered as follows:
        </para>
        <code language="c#">
          try
'         {
              // code here
          }
          catch (SqlException sqlEx)
          {
              // Handle more specific SqlException exception here.
          }
          catch (Exception ex)
          {
              // Handle generic ones here.
          }
        </code>
        <para>Or:</para>
        <code language="c#">
          try
          {
              // code here
          }
          catch (Exception ex)
          {
              if (ex is SqlException)
              {
                  // Handle more specific SqlException exception here.
              }
              else
              {
                  // Handle generic ones here.
              }
          }
        </code>
        <para>
          It is also possible for a .NET Framework data provider method call to fail on a thread pool thread with no user code on the stack. In this case, and when using asynchronous method calls, you must register the <see cref="T:System.AppDomain.UnhandledException" /> event to handle those exceptions and avoid application crash.
        </para>
      </remarks><example>
        <para>
          The following example generates a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> and then displays the exception.
        </para>
        <!-- SqlException_Errors1 -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="T:Microsoft.Data.SqlClient.SqlError" /><seealso cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />
            <summary>
        The exception that is thrown when SQL Server returns a warning or error. This class cannot be inherited.
      </summary><remarks>
        <para>
          This class is created whenever the .NET Framework Data Provider for SQL Server encounters an error generated from the server. (Client side errors are thrown as standard common language runtime exceptions.) <see cref="T:Microsoft.Data.SqlClient.SqlException" /> always contains at least one instance of <see cref="T:Microsoft.Data.SqlClient.SqlError" />.
        </para>
        <para>
          Messages that have a severity level of 10 or less are informational and indicate problems caused by mistakes in information that a user has entered. Severity levels from 11 through 16 are generated by the user, and can be corrected by the user. Severity levels from 17 through 25 indicate software or hardware errors. When a level 17, 18, or 19 error occurs, you can continue working, although you might not be able to execute a particular statement.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. In both cases, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing the command.
        </para>
        <para>
          For information about the warning and informational messages sent by SQL Server, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>. The <see cref="T:Microsoft.Data.SqlClient.SqlException" /> class maps to SQL Server severity.
        </para>
        <para>
          The following is general information on handling exceptions. Your code should catch exceptions to prevent the application from crashing and to allow displaying a relevant error message to the user.  You can use database transactions to ensure that the data is consistent regardless of what happens in the client application (including a crash). Features like <see cref="T:System.Transactions.TransactionScope" /> or the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> ensure consistent data regardless of exceptions raised by a provider. Transactions can fail, so catch failures and retry the transaction.
        </para>
        <para>
          Note that beginning with .NET Framework 4.5, <see cref="T:Microsoft.Data.SqlClient.SqlException" /> can return an inner <see cref="T:System.ComponentModel.Win32Exception" />.
        </para>
        <para>
          The exception class of a .NET Framework data provider reports provider-specific errors. For example System.Data.Odbc has <see cref="T:System.Data.Odbc.OdbcException" />, System.Data.OleDb has <see cref="T:System.Data.OleDb.OleDbException" />, and Microsoft.Data.SqlClient has <b>SqlException</b>. For the best level of error detail, catch these exceptions and use the members of these exception classes to get details of the error.
        </para>
        <para>
          Bad input can cause a .NET Framework data provider type to raise an exception such as System.ArgumentException or System.IndexOutOfRangeException. Calling a method at the wrong time can raise System.InvalidOperationException.
        </para>
        <para>
          So, in general, write an exception handler that catches any provider specific exceptions as well as exceptions from the common language runtime. These can be layered as follows:
        </para>
        <code language="c#">
          try
'         {
              // code here
          }
          catch (SqlException sqlEx)
          {
              // Handle more specific SqlException exception here.
          }
          catch (Exception ex)
          {
              // Handle generic ones here.
          }
        </code>
        <para>Or:</para>
        <code language="c#">
          try
          {
              // code here
          }
          catch (Exception ex)
          {
              if (ex is SqlException)
              {
                  // Handle more specific SqlException exception here.
              }
              else
              {
                  // Handle generic ones here.
              }
          }
        </code>
        <para>
          It is also possible for a .NET Framework data provider method call to fail on a thread pool thread with no user code on the stack. In this case, and when using asynchronous method calls, you must register the <see cref="T:System.AppDomain.UnhandledException" /> event to handle those exceptions and avoid application crash.
        </para>
      </remarks><example>
        <para>
          The following example generates a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> and then displays the exception.
        </para>
        <!-- SqlException_Errors1 -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="T:Microsoft.Data.SqlClient.SqlError" /><seealso cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.Class">
            <summary>
        Gets the severity level of the error returned from the .NET Framework Data Provider for SQL Server.
      </summary><value>
        A value from 1 to 25 that indicates the severity level of the error.
      </value><remarks>
        <para>
          Messages that have a severity level of 10 or less are informational and indicate problems caused by mistakes in information that a user has entered. Severity levels from 11 through 16 are generated by the user, and can be corrected by the user. Severity levels from 17 through 25 indicate software or hardware errors. When a level 17, 18, or 19 error occurs, you can continue working, although you might not be able to execute a particular statement.
        </para>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" />. However, the user can reopen the connection and continue. In both cases, a <see cref="T:Microsoft.Data.SqlClient.SqlException" /> is generated by the method executing the command.
        </para>
        <para>
          For information about the warning and informational messages sent by SQL Server, see the Troubleshooting section of the SQL Server documentation.
        </para>
        <para>
          This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.Class" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> property.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> is <see langword="null" />, the <see href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/default-values"><c>default</c></see> value for <c>byte</c> is returned.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlException_Errors2 -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Text;
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistantStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "Error Number: " + ex.Errors[i].Number + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Number" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Source" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.State" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Server" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Procedure" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.LineNumber" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.ClientConnectionId">
            <summary>
        Represents the client connection ID. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/data-tracing">Data Tracing in ADO.NET</see>.
      </summary><value>
        The client connection ID.
      </value><remarks>
        For a code sample, see <see cref="M:Microsoft.Data.SqlClient.SqlException.ToString" />.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.Errors">
            <summary>
        Gets a collection of one or more <see cref="T:Microsoft.Data.SqlClient.SqlError" /> objects that give detailed information about exceptions generated by the .NET Framework Data Provider for SQL Server.
      </summary><value>
        The collected instances of the <see cref="T:Microsoft.Data.SqlClient.SqlError" /> class.
      </value><remarks>
        <para>
          The <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> class always contains at least one instance of the <see cref="T:Microsoft.Data.SqlClient.SqlError" /> class.
        </para>
        <para>
          This is a wrapper for <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" />. For more information on SQL Server engine errors, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlError_ToString -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Text;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          DisplaySqlErrors(ex);
                      }
                  }
              }

              private static void DisplaySqlErrors(SqlException exception)
              {
                  for (int i = 0; i &lt; exception.Errors.Count; i++)
                  {
                      Console.WriteLine("Index #" + i + "\n" +
                          "Error: " + exception.Errors[i].ToString() + "\n");
                  }
                  Console.ReadLine();
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /><seealso cref="T:Microsoft.Data.SqlClient.SqlError" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.LineNumber">
            <summary>
        Gets the line number within the Transact-SQL command batch or stored procedure that generated the error.
      </summary><value>
        The line number within the Transact-SQL command batch or stored procedure that generated the error.
      </value><remarks>
        <para>
          The line numbering starts at 1; if 0 is returned, the line number is not applicable.
        </para>
        <para>
          This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.LineNumber" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> property.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> is <see langword="null" />, the <see href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/default-values"><c>default</c></see> value for <c>int</c> is returned.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlException_Errors2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Text;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "Error Number: " + ex.Errors[i].Number + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Number" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Source" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.State" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Class" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Server" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Procedure" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.Number">
            <summary>
        Gets a number that identifies the type of error.
      </summary><value>
        The number that identifies the type of error.
      </value><remarks>
        <para>
          This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.Number" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> property.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> is <see langword="null" />, the <see href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/default-values"><c>default</c></see> value for <c>int</c> is returned.
        </para>
        <para>
          For more information on SQL Server engine errors, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlException_Errors2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Text;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "Error Number: " + ex.Errors[i].Number + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlException.State" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Class" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Source" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Server" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Procedure" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.LineNumber" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.Procedure">
            <summary>
        Gets the name of the stored procedure or remote procedure call (RPC) that generated the error.
      </summary><value>
        The name of the stored procedure or RPC.
      </value><remarks>
        <para>
          This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.Procedure" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> property.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> is <see langword="null" />, the <see href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/default-values"><c>default</c></see> value for <c>string</c> is returned.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlException_Errors2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Text;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "Error Number: " + ex.Errors[i].Number + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Number" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.State" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Class" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Server" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Source" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.LineNumber" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.Server">
            <summary>
        Gets the name of the computer that is running an instance of SQL Server that generated the error.
      </summary><value>
        The name of the computer running an instance of SQL Server.
      </value><remarks>
        <para>
          This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.Server" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> property.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> is <see langword="null" />, the <see href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/default-values"><c>default</c></see> value for <c>string</c> is returned.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlException_Errors2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Text;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "Error Number: " + ex.Errors[i].Number + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Number" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.State" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Source" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Class" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Procedure" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.LineNumber" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.Source">
            <summary>
        Gets the name of the provider that generated the error.
      </summary><value>
        The name of the provider that generated the error.
      </value><remarks>
        This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.Source" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> property.
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlException_Errors2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Text;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "Error Number: " + ex.Errors[i].Number + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Number" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.State" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Class" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Server" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Procedure" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.LineNumber" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.State">
            <summary>
        Gets a numeric error code from SQL Server that represents an error, warning or "no data found" message. For more information about how to decode these values, see <see href="https://learn.microsoft.com/sql/relational-databases/errors-events/database-engine-events-and-errors">Database Engine Events and Errors</see>.
      </summary><value>
        The number representing the error code.
      </value><remarks>
        <para>
          This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.State" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> property.
        </para>
        <para>
          If <see cref="P:Microsoft.Data.SqlClient.SqlException.Errors" /> is <see langword="null" />, the <see href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/default-values"><c>default</c></see> value for <c>byte</c> is returned.
        </para>
      </remarks><example>
        <para>
          The following example displays each <see cref="T:Microsoft.Data.SqlClient.SqlError" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection.
        </para>
        <!-- SqlException_Errors2 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          using System.Text;

          class Program
          {
              static void Main()
              {
                  string s = GetConnectionString();
                  ShowSqlException(s);
                  Console.ReadLine();
              }

              public static void ShowSqlException(string connectionString)
              {
                  string queryString = "EXECUTE NonExistentStoredProcedure";
                  StringBuilder errorMessages = new StringBuilder();

                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(queryString, connection);
                      try
                      {
                          command.Connection.Open();
                          command.ExecuteNonQuery();
                      }
                      catch (SqlException ex)
                      {
                          for (int i = 0; i &lt; ex.Errors.Count; i++)
                          {
                              errorMessages.Append("Index #" + i + "\n" +
                                  "Message: " + ex.Errors[i].Message + "\n" +
                                  "Error Number: " + ex.Errors[i].Number + "\n" +
                                  "LineNumber: " + ex.Errors[i].LineNumber + "\n" +
                                  "Source: " + ex.Errors[i].Source + "\n" +
                                  "Procedure: " + ex.Errors[i].Procedure + "\n");
                          }
                          Console.WriteLine(errorMessages.ToString());
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code,
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Class" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Number" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Source" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Server" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Procedure" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.LineNumber" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>To be added</summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlException.ToString">
            <summary>
        Returns a string that represents the current <see cref="T:Microsoft.Data.SqlClient.SqlException" /> object, and includes the client connection ID (for more information, see <see cref="P:Microsoft.Data.SqlClient.SqlException.ClientConnectionId" />).
      </summary><returns>
        A string that represents the current <see cref="T:Microsoft.Data.SqlClient.SqlException" /> object. <see cref="T:System.String" />.
      </returns><example>
        <para>
          The following example shows how a connection attempt to a valid server but non-existent database causes a <see cref="T:Microsoft.Data.SqlClient.SqlException" />, which includes the client connection ID:
        </para>
        <code language="c#">
          using System;
          using Microsoft.Data.SqlClient;

          public class A
          {
              public static void Main()
              {
                  SqlConnection connection = new SqlConnection();
                  connection.ConnectionString = "Data Source=a_valid_server;Initial Catalog=Northwinda;Integrated Security=true";

                  try
                  {
                      connection.Open();
                  }
                  catch (SqlException p)
                  {
                      Console.WriteLine("{0}", p.ClientConnectionId);
                      Console.WriteLine("{0}", p.ToString());
                  }

                  connection.Close();
              }
          }
        </code>
        <code language="vb">
          Imports System
          Imports Microsoft.Data.SqlClient

          Module Module1
              Sub Main()
                  Dim connection As New SqlConnection()
                  connection.ConnectionString = "Data Source=a_valid_server;Initial Catalog=Northwinda;Integrated Security=true"

                  Try
                      connection.Open()
                  Catch p As SqlException
                      Console.WriteLine("{0}", p.ClientConnectionId)
                      Console.WriteLine("{0}", p.ToString())
                  End Try
              
                  connection.Close()
              End Sub
          End Module
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.BatchCommand">
            <summary>
        Gets the <see cref="T:System.Data.Common.DbBatchCommand" /> instance that generated the error or <see langword="null" /> if the exception was not raised from a batch.
      </summary><value>
        A <see cref="T:System.Data.Common.DbBatchCommand" /> object or <see langword="null" />
      </value><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Number" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.State" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Class" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Server" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.Procedure" /><seealso cref="P:Microsoft.Data.SqlClient.SqlException.LineNumber" />
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlException.DbBatchCommand">
            <summary>
        If this <see cref="T:Microsoft.Data.SqlClient.SqlException" /> was thrown when executing a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />, references the specific <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> which triggered the exception.
      </summary><value>
        The specific <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> which triggered the exception.
      </value><remarks>
        If this <see cref="T:Microsoft.Data.SqlClient.SqlException" /> wasn't thrown when executing a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />, the value is <see langword="null" />.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs">
            <summary>
        Provides data for the <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event.
      </summary><remarks>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event contains a <see cref="T:Microsoft.Data.SqlClient.SqlErrorCollection" /> collection which contains the warnings sent from the server.
        </para>
        <para>
          An <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event is generated when a SQL Server message with a severity level of 10 or less occurs.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs.#ctor">
            <summary>
        Constructs and initializes a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs" />
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs.Errors">
            <summary>
        Gets the collection of warnings sent from the server.
      </summary><value>
        The collection of warnings sent from the server.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs.Message">
            <summary>
        Gets the full text of the error sent from the database.
      </summary><value>
        The full text of the error.
      </value><remarks>
        This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.Message" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs.Errors" /> collection.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs.Source">
            <summary>
        Gets the name of the object that generated the error.
      </summary><value>
        The name of the object that generated the error.
      </value><remarks>
        This is a wrapper for the <see cref="P:Microsoft.Data.SqlClient.SqlError.Source" /> property of the first <see cref="T:Microsoft.Data.SqlClient.SqlError" /> in the <see cref="P:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs.Errors" /> collection.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs.ToString">
            <summary>
        Retrieves a string representation of the <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event.
      </summary><returns>
        A string representing the <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlInfoMessageEventHandler">
            <param name="sender">
        The source of the event.
      </param><param name="e">
        A <see cref="T:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs" /> object that contains the event data.
      </param><summary>
        Represents the method that will handle the <see cref="E:Microsoft.Data.SqlClient.SqlConnection.InfoMessage" /> event of a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> .
      </summary><remarks>
        When you create a <see cref="T:Microsoft.Data.SqlClient.SqlInfoMessageEventArgs" /> delegate, you identify the method that will handle the event. To associate the event with your event handler, add an instance of the delegate to the event. The event handler is called whenever the event occurs, unless you remove the delegate. For more information about event handler delegates, see <see href="https://learn.microsoft.com/dotnet/standard/events/">Handling and Raising Events</see>.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs">
            <summary>
        Represents the set of arguments passed to the notification event handler.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlNotificationEventArgs.#ctor(Microsoft.Data.SqlClient.SqlNotificationType,Microsoft.Data.SqlClient.SqlNotificationInfo,Microsoft.Data.SqlClient.SqlNotificationSource)">
            <param name="type">
        <see cref="T:Microsoft.Data.SqlClient.SqlNotificationType" /> value that indicates whether this notification is generated because of an actual change, or by the subscription.
      </param><param name="info">
        <see cref="T:Microsoft.Data.SqlClient.SqlNotificationInfo" /> value that indicates the reason for the notification event. This may occur because the data in the store actually changed, or the notification became invalid (for example, it timed out).
      </param><param name="source">
        <see cref="T:Microsoft.Data.SqlClient.SqlNotificationSource" /> value that indicates the source that generated the notification.
      </param><summary>
        Creates a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs" /> object.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlNotificationEventArgs.Info">
            <summary>
        Gets a value that indicates the reason for the notification event, such as a row in the database being modified or a table being truncated.
      </summary><value>
        The notification event reason.
      </value><remarks>
        This event may occur because the data in the store actually changed, or the notification is no longer valid (for example, it timed out).
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlNotificationEventArgs.Source">
            <summary>
        Gets a value that indicates the source that generated the notification, such as a change to the query data or the database's state.
      </summary><value>
        The source of the notification.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlNotificationEventArgs.Type">
            <summary>
        Gets a value that indicates whether this notification is generated because of an actual change, or by the subscription.
      </summary><value>
        A value indicating whether the notification was generated by a change or a subscription.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlNotificationInfo">
            <summary>
        This enumeration provides additional information about the different notifications that can be received by the dependency event handler.
      </summary><remarks>
        The <see cref="T:Microsoft.Data.SqlClient.SqlNotificationInfo" /> enumeration is referenced by an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs" /> class.
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.AlreadyChanged">
            <summary>
        The <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object already fired, and new commands cannot be added to it.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Alter">
            <summary>
        An underlying server object related to the query was modified.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Delete">
            <summary>
        Data was changed by a DELETE statement.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Drop">
            <summary>
        An underlying object related to the query was dropped.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Error">
            <summary>
        An internal server error occurred.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Expired">
            <summary>
        The <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> object has expired.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Insert">
            <summary>
        Data was changed by an INSERT statement.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Invalid">
            <summary>
        A statement was provided that cannot be notified (for example, an UPDATE statement).
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Isolation">
            <summary>
        The statement was executed under an isolation mode that was not valid (for example, Snapshot).
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Merge">
            <summary>
        Used to distinguish the server-side cause for a query notification firing.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Options">
            <summary>
        The SET options were not set appropriately at subscription time.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.PreviousFire">
            <summary>
        A previous statement has caused query notifications to fire under the current transaction.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Query">
            <summary>
        A SELECT statement that cannot be notified or was provided.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Resource">
            <summary>
        Fires as a result of server resource pressure.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Restart">
            <summary>
        The server was restarted (notifications are sent during restart.).
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.TemplateLimit">
            <summary>
        The subscribing query causes the number of templates on one of the target tables to exceed the maximum allowable limit.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Truncate">
            <summary>
        One or more tables were truncated.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Unknown">
            <summary>
        Used when the info option sent by the server was not recognized by the client.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationInfo.Update">
            <summary>
        Data was changed by an UPDATE statement.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlNotificationSource">
            <summary>
        Indicates the source of the notification received by the dependency event handler.
      </summary><remarks>
        <para>
          The <b>SqlNotificationSource</b> enumeration is referenced by an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs" /> class.
        </para>
        <para>
          Query notifications are supported only for SELECT statements that meet a list of specific requirements. For more information, see <see href="https://learn.microsoft.com/sql/database-engine/configure-windows/sql-server-service-broker">SQL Server Service Broker</see> and <see href="https://learn.microsoft.com/sql/connect/oledb/features/working-with-query-notifications">Working with Query Notifications</see>.
        </para>
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Client">
            <summary>
        A client-initiated notification occurred, such as a client-side time-out or as a result of attempting to add a command to a dependency that has already fired.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Data">
            <summary>
        Data has changed; for example, an INSERT, UPDATE, DELETE, or TRUNCATE operation occurred.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Database">
            <summary>
        The database state changed; for example, the database related to the query was dropped or detached.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Environment">
            <summary>
        The run-time environment was not compatible with notifications; for example, the isolation level was set to snapshot, or one or more SET options are not compatible.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Execution">
            <summary>
        A run-time error occurred during execution.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Object">
            <summary>
        A database object changed; for example, an underlying object related to the query was dropped or modified.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Owner">
            <summary>
        Internal only; not intended to be used in your code.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Statement">
            <summary>
        The Transact-SQL statement is not valid for notifications; for example, a SELECT statement that could not be notified or a non-SELECT statement was executed.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.System">
            <summary>
        A system-related event occurred. For example, there was an internal error, the server was restarted, or resource pressure caused the invalidation.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Timeout">
            <summary>
        The subscription time-out expired.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationSource.Unknown">
            <summary>
        Used when the source option sent by the server was not recognized by the client.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlNotificationType">
            <summary>
        Describes the different notification types that can be received by an <see cref="T:Microsoft.Data.SqlClient.OnChangeEventHandler" /> event handler through the <see cref="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs" /> parameter.
      </summary><remarks>
        The <see cref="T:Microsoft.Data.SqlClient.SqlNotificationType" /> enumeration is referenced by an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs" /> class. This information is provided when a notification event is fired with the <see cref="T:Microsoft.Data.SqlClient.SqlDependency" /> class.
      </remarks>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationType.Change">
            <summary>
        Data on the server being monitored changed. Use the <see cref="T:Microsoft.Data.SqlClient.SqlNotificationInfo" /> item to determine the details of the change.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationType.Subscribe">
            <summary>
        There was a failure to create a notification subscription. Use the <see cref="T:Microsoft.Data.SqlClient.SqlNotificationEventArgs" /> object's <see cref="T:Microsoft.Data.SqlClient.SqlNotificationInfo" /> item to determine the cause of the failure.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.SqlNotificationType.Unknown">
            <summary>
        Used when the type option sent by the server was not recognized by the client.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlParameter">
            <summary>
        Represents a parameter to a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and optionally its mapping to <see cref="T:System.Data.DataSet" /> columns. This class cannot be inherited. For more information on parameters, see <see href="https://learn.microsoft.com/sql/connect/ado-net/configure-parameters">Configuring parameters</see>
      </summary><remarks>
        <para>
          Parameter names are not case-sensitive.
        </para>
        <note type="note">
          Nameless, also called ordinal, parameters are not supported by the .NET Framework Data Provider for SQL Server.
        </note>
        <para>
          For more information, along with additional sample code demonstrating how to use parameters, see <see href="https://learn.microsoft.com/sql/connect/ado-net/commands-parameters">Commands and Parameters</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates multiple instances of <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> through the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> collection within the <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />. These parameters are used to select data from the data source and put the data in the <see cref="T:System.Data.DataSet" />.
        </para>
        <para>
          This example assumes that a <see cref="T:System.Data.DataSet" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> have already been created by using the appropriate schema, commands, and connection. For more information and additional examples on using parameters, see <see href="https://learn.microsoft.com/sql/connect/ado-net/retrieving-modifying-data">Retrieving and Modifying Data in ADO.NET</see> and <see href="https://learn.microsoft.com/sql/connect/ado-net/configure-parameters">Configuring parameters</see>.
        </para>
        <!-- SqlParameterCollection_Add6 -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              protected DataSet categoriesDataSet;
              protected DataGrid dataGrid1;
              protected SqlDataAdapter categoriesAdapter;
          
              public void AddSqlParameters()
              {
                  // ...
                  // create categoriesDataSet and categoriesAdapter
                  // ...
          
                  categoriesAdapter.SelectCommand.Parameters.Add(
                    "@CategoryName",
                    SqlDbType.VarChar,
                    80
                  ).Value = "toasters";
                  categoriesAdapter.SelectCommand.Parameters.Add(
                    "@SerialNum",
                    SqlDbType.Int
                  ).Value = 239;
                  categoriesAdapter.Fill(categoriesDataSet);
              }
          }
        </code>
      </example><seealso cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /><seealso cref="T:Microsoft.Data.SqlClient.SqlCommand" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> class.
      </summary><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_SqlParameter -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static void AddSqlParameter(SqlCommand command)
              {
                  SqlParameter parameter = new SqlParameter();
                  parameter.ParameterName = "@Description";
                  parameter.IsNullable = true;
                  parameter.SqlDbType = SqlDbType.VarChar;
                  parameter.Direction = ParameterDirection.Output;
                  parameter.Size = 88;
          
                  command.Parameters.Add(parameter);
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType)">
            <param name="parameterName">
        The name of the parameter to map.
      </param><param name="dbType">
        One of the <see cref="T:System.Data.SqlDbType" /> values.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> class that uses the parameter name and the data type.
      </summary><remarks>
        The data type and, if appropriate, <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Precision" /> are inferred from the value of the <paramref name="dbType" /> parameter.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_SqlParameter2 -->
        <code language="c#">
            using System;
            using System.Data;
            using Microsoft.Data.SqlClient;
            
            class Program
            {
                private static void AddSqlParameter(SqlCommand command, string paramValue)
                {
                    SqlParameter parameter = new SqlParameter("@Description", SqlDbType.VarChar);
                    parameter.IsNullable = true;
                    parameter.Direction = ParameterDirection.Output;
                    parameter.Size = 88;
                    parameter.Value = paramValue;
            
                    command.Parameters.Add(parameter);
                }
            }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value supplied in the <paramref name="dbType" /> parameter is an invalid back-end data type.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32)">
            <param name="parameterName">
        The name of the parameter to map.
      </param><param name="dbType">
        One of the <see cref="T:System.Data.SqlDbType" /> values.
      </param><param name="size">
        The length of the parameter.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> class that uses the parameter name, the <see cref="T:System.Data.SqlDbType" />, and the size.
      </summary><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" /> is inferred from the value of the <paramref name="dbType" /> parameter if it is not explicitly set in the <paramref name="size" /> parameter.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_SqlParameter4 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static void AddSqlParameter(SqlCommand command, string paramValue)
              {
                  SqlParameter parameter = new SqlParameter(
                      "@Description",
                      SqlDbType.VarChar,
                      88);
                  parameter.IsNullable = true;
                  parameter.Direction = ParameterDirection.Output;
                  parameter.Value = paramValue;
          
                  command.Parameters.Add(parameter);
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value supplied in the <paramref name="dbType" /> parameter is an invalid back-end data type.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32,System.Data.ParameterDirection,System.Boolean,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Object)">
            <param name="parameterName">
        The name of the parameter to map.
      </param><param name="dbType">
        One of the <see cref="T:System.Data.SqlDbType" /> values.
      </param><param name="size">
        The length of the parameter.
      </param><param name="direction">
        One of the <see cref="T:System.Data.ParameterDirection" /> values.
      </param><param name="isNullable">
        <see langword="true" /> if the value of the field can be null; otherwise, <see langword="false" />.
      </param><param name="precision">
        The total number of digits to the left and right of the decimal point to which <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> is resolved.
      </param><param name="scale">
        The total number of decimal places to which <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> is resolved.
      </param><param name="sourceColumn">
        The name of the source column (<see cref="P:Microsoft.Data.SqlClient.SqlParameter.SourceColumn" />) if this <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> is used in a call to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </param><param name="sourceVersion">
        One of the <see cref="T:System.Data.DataRowVersion" /> values.
      </param><param name="value">
        An <see cref="T:System.Object" /> that is the value of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> class that uses the parameter name, the type of the parameter, the size of the parameter, a <see cref="T:System.Data.ParameterDirection" />, the precision of the parameter, the scale of the parameter, the source column, a <see cref="T:System.Data.DataRowVersion" /> to use, and the value of the parameter.
      </summary><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Precision" /> are inferred from the value of the <paramref name="dbType" /> parameter if they are not explicitly set in the <paramref name="size" /> and <paramref name="precision" /> parameters.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_SqlParameter1 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static void AddSqlParameter(SqlCommand command)
              {
                  SqlParameter parameter = new SqlParameter(
                      "@Description",
                      SqlDbType.VarChar,
                      11,
                      ParameterDirection.Input,
                      true,
                      0,
                      0,
                      "Description",
                      DataRowVersion.Current,
                      "garden hose");
                  parameter.IsNullable = true;
          
                  command.Parameters.Add(parameter);
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value supplied in the <paramref name="dbType" /> parameter is an invalid back-end data type.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32,System.Data.ParameterDirection,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Boolean,System.Object,System.String,System.String,System.String)">
            <param name="parameterName">
        The name of the parameter to map.
      </param><param name="dbType">
        One of the <see cref="T:System.Data.SqlDbType" /> values.
      </param><param name="size">
        The length of the parameter.
      </param><param name="direction">
        One of the <see cref="T:System.Data.ParameterDirection" /> values.
      </param><param name="precision">
        The total number of digits to the left and right of the decimal point to which <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> is resolved.
      </param><param name="scale">
        The total number of decimal places to which <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> is resolved.
      </param><param name="sourceColumn">
        The name of the source column ( <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SourceColumn" />) if this <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> is used in a call to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> &gt;.
      </param><param name="sourceVersion">
        One of the <see cref="T:System.Data.DataRowVersion" /> values.
      </param><param name="sourceColumnNullMapping">
        <see langword="true" /> if the source column is nullable; <see langword="false" /> if it is not.
      </param><param name="value">
        An <see cref="T:System.Object" /> that is the value of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </param><param name="xmlSchemaCollectionDatabase">
        The name of the database where the schema collection for this XML instance is located.
      </param><param name="xmlSchemaCollectionOwningSchema">
        The owning relational schema where the schema collection for this XML instance is located.
      </param><param name="xmlSchemaCollectionName">
        The name of the schema collection for this parameter.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> class that uses the parameter name, the type of the parameter, the length of the parameter the direction, the precision, the scale, the name of the source column, one of the <see cref="T:System.Data.DataRowVersion" /> values, a Boolean for source column mapping, the value of the <see langword="SqlParameter" />, the name of the database where the schema collection for this XML instance is located, the owning relational schema where the schema collection for this XML instance is located, and the name of the schema collection for this parameter.
      </summary><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Precision" /> are inferred from the value of the <paramref name="dbType" /> parameter if they are not explicitly set in the <paramref name="size" /> and <paramref name="precision" /> parameters.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType,System.Int32,System.String)">
            <param name="parameterName">
        The name of the parameter to map.
      </param><param name="dbType">
        One of the <see cref="T:System.Data.SqlDbType" /> values.
      </param><param name="size">
        The length of the parameter.
      </param><param name="sourceColumn">
        The name of the source column (<see cref="P:Microsoft.Data.SqlClient.SqlParameter.SourceColumn" />) if this <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> is used in a call to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> &gt;.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> class that uses the parameter name, the <see cref="T:System.Data.SqlDbType" />, the size, and the source column name.
      </summary><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Size" /> is inferred from the value of the <paramref name="dbType" /> parameter if it is not explicitly set in the <paramref name="size" /> parameter.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_SqlParameter5 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static void AddSqlParameter(SqlCommand command)
              {
                  SqlParameter parameter = new SqlParameter(
                      "@Description",
                      SqlDbType.VarChar,
                      88,
                      "Description");
                  parameter.IsNullable = true;
                  parameter.Direction = ParameterDirection.Output;
          
                  command.Parameters.Add(parameter);
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The value supplied in the <paramref name="dbType" /> parameter is an invalid back-end data type.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.#ctor(System.String,System.Object)">
            <param name="parameterName">
        The name of the parameter to map.
      </param><param name="value">
        An <see cref="T:System.Object" /> that is the value of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> class that uses the parameter name and a value of the new <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </summary><remarks>
        <para>
          When you specify an <see cref="T:System.Object" /> in the <paramref name="value" /> parameter, the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> is inferred from the Microsoft .NET Framework type of the <see cref="T:System.Object" />.
        </para>
        <para>
          Use caution when you use this overload of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> constructor to specify integer parameter values. Because this overload takes a <paramref name="value" /> of type <see cref="T:System.Object" />, you must convert the integral value to an <see cref="T:System.Object" /> type when the value is zero, as the following C# example demonstrates.
        </para>
        <code language="c#">
          Parameter = new SqlParameter("@pname", (object)0);
        </code>
        <para>
          If you do not perform this conversion, the compiler assumes that you are trying to call the <see cref="M:Microsoft.Data.SqlClient.SqlParameter.#ctor(System.String,System.Data.SqlDbType)" /> constructor overload.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_SqlParameter6 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static void AddSqlParameter(SqlCommand command)
              {
                  SqlParameter parameter = new SqlParameter(
                      "@Description",
                      SqlDbType.VarChar,
                      88,
                      "Description");
                  parameter.IsNullable = true;
                  parameter.Direction = ParameterDirection.Output;
          
                  command.Parameters.Add(parameter);
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.System#ICloneable#Clone">
            <summary>
        For a description of this member, see <see cref="M:System.ICloneable.Clone" />.
      </summary><returns>
        A new <see cref="T:System.Object" /> that is a copy of this instance.
      </returns><remarks>
        This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> instance is cast to an <see cref="T:System.ICloneable" /> interface.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.CompareInfo">
            <summary>
        Gets or sets the <see cref="T:System.Globalization.CompareInfo" /> object that defines how string comparisons should be performed for this parameter.
      </summary><value>
        A <see cref="T:System.Globalization.CompareInfo" /> object that defines string comparison for this parameter.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.DbType">
            <summary>
        Gets or sets the <see cref="T:System.Data.SqlDbType" /> of the parameter.
      </summary><value>
        One of the <see cref="T:System.Data.SqlDbType" /> values. The default is <c>NVARCHAR</c>.
      </value><remarks>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> are linked. Therefore, setting the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> changes the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> to a supporting <see cref="T:System.Data.SqlDbType" />.
        </para>
        <para>
          For a list of the supported data types, see the appropriate <see cref="T:System.Data.SqlDbType" /> member. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/dataadapter-parameters">DataAdapter Parameters</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_IsNullable -->
        <!-- THIS EXAMPLE DOESN'T EVEN USE THE PROPERTY -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static void AddSqlParameter(SqlCommand command, string paramValue)
              {
                  SqlParameter parameter = new SqlParameter(
                      "@Description",
                      SqlDbType.VarChar);
                  parameter.Value = paramValue;
                  parameter.IsNullable = true;
                  command.Parameters.Add(parameter);
              }
          
              private static void SetParameterToNull(IDataParameter parameter)
              {
                  if (parameter.IsNullable)
                  {
                      parameter.Value = DBNull.Value;
                  }
                  else
                  {
                      throw new ArgumentException("Parameter provided is not nullable", "parameter");
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.Direction">
            <summary>
        Gets or sets a value that indicates whether the parameter is input-only, output-only, bidirectional, or a stored procedure return value parameter.
      </summary><value>
        One of the <see cref="T:System.Data.ParameterDirection" /> values. The default is <see langword="Input" />.
      </value><remarks>
        If the <see cref="T:System.Data.ParameterDirection" /> is output, and execution of the associated <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> does not return a value, the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> contains a null value. <see cref="F:System.Data.ParameterDirection.Output" />, <see cref="F:System.Data.ParameterDirection.InputOut" />, and <see cref="F:System.Data.ParameterDirection.ReturnValue" /> parameters returned by calling <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader" /> cannot be accessed until you close the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <list type="bullet">
          <item><see href="https://learn.microsoft.com/sql/connect/ado-net/commands-parameters">Commands and Parameters</see></item>
          <item><see href="https://learn.microsoft.com/sql/connect/ado-net/dataadapter-parameters">DataAdapter Parameters</see></item>
          <item><see href="https://learn.microsoft.com/sql/connect/ado-net/sql/">SQL Server and ADO.NET</see></item>
        </list>
      </example><exception cref="T:System.ArgumentException">
        The property was not set to one of the valid <see cref="T:System.Data.ParameterDirection" /> values.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.ForceColumnEncryption">
            <summary>
        Enforces encryption of a parameter when using <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>. If SQL Server informs the driver that the parameter does not need to be encrypted, the query using the parameter will fail. This property provides additional protection against security attacks that involve a compromised SQL Server providing incorrect encryption metadata to the client, which may lead to data disclosure.
      </summary><value>
        <see langword="true" /> if the parameter has a force column encryption; otherwise, <see langword="false" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.IsNullable">
            <summary>
        Gets or sets a value that indicates whether the parameter accepts null values. <see cref="P:Microsoft.Data.SqlClient.SqlParameter.IsNullable" /> is not used to validate the parameter's value and will not prevent sending or receiving a null value when executing a command.
      </summary><value>
        <see langword="true" /> if null values are accepted; otherwise, <see langword="false" />. The default is <see langword="false" />.
      </value><remarks>
        Null values are handled using the <see cref="T:System.DBNull" /> class.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter #2 -->
        <code language="c#">
          static void CreateSqlParameterNullable()
          {
              SqlParameter parameter = new SqlParameter("Description", SqlDbType.VarChar, 88);
              parameter.IsNullable = true;
              parameter.Direction = ParameterDirection.Output;
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.LocaleId">
            <summary>
        Gets or sets the locale identifier that determines conventions and language for a particular region.
      </summary><value>
        The locale identifier associated with the parameter.
      </value><remarks>
        <para>
          The locale identifies conventions and language for a particular geographical region. The codepage used to encode a specific string (the character set) is based on the locale used by that string or the environment that produced it. This property sets (for input parameters) or gets (for output parameters) the locale to be attached to a string when exchanging data with the server. This property is typically used together with the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.CompareInfo" /> property.
        </para>
        <code language="c#">
          static void CreateSqlParameterLocaleId()
          {
              SqlParameter parameter = new SqlParameter("pName", SqlDbType.VarChar);
              parameter.LocaleId = 1033;
              // English - United States
          }
        </code>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.Offset">
            <summary>
        Gets or sets the offset to the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> property.
      </summary><value>
        The offset to the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" />. The default is 0.
      </value><remarks>
        The <b>Offset</b> property is used for client-side chunking of binary and string data. For example, in order to insert 10MB of text into a column on a server, a user might execute 10 parameterized inserts of 1MB chunks, shifting the value of <b>Offset</b> on each iteration by 1MB. <b>Offset</b> specifies the number of bytes for binary types, and the number of characters for strings. The count for strings does not include the terminating character.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter #3 -->
        <code language="c#">
          static void CreateSqlParameterOffset()
          {
              SqlParameter parameter = new SqlParameter("pDName", SqlDbType.VarChar);
              parameter.IsNullable = true;
              parameter.Offset = 3;
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.ParameterName">
            <summary>
        Gets or sets the name of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </summary><value>
        The name of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />. The default is an empty string.
      </value><remarks>
        The <see cref="P:Microsoft.Data.SqlClient.SqlParameter.ParameterName" /> is specified in the form <c>@paramname</c>. You must set <see cref="P:Microsoft.Data.SqlClient.SqlParameter.ParameterName" /> before executing a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> that relies on parameters.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_ParameterName -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              private static void AddSqlParameter(SqlCommand command)
              {
                  SqlParameter parameter = new SqlParameter();
                  parameter.ParameterName = "@Description";
                  parameter.IsNullable = true;
                  parameter.DbType = DbType.String;
                  parameter.Direction = ParameterDirection.Output;
          
                  command.Parameters.Add(parameter);
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.Precision">
            <summary>
        Gets or sets the maximum number of digits used to represent the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> property.
      </summary><value>
        The maximum number of digits used to represent the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> property. The default value is 0. This indicates that the data provider sets the precision for <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" />.
      </value><remarks>
        <para>
          The <b>Precision</b> property is used by parameters that have a <see cref="T:System.Data.SqlDbType" /> of <c>Decimal</c>.
        </para>
        <para>
          You do not need to specify values for the <b>Precision</b> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Scale" /> properties for input parameters, as they can be inferred from the parameter value. <b>Precision</b> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Scale" /> are required for output parameters and for scenarios where you need to specify complete metadata for a parameter without indicating a value, such as specifying a null value with a specific precision and scale.
        </para>
        <note type="note">
          Use of this property to coerce data passed to the database is not supported. To round, truncate, or otherwise coerce data before passing it to the database, use the <see cref="T:System.Math" /> class that is part of the <c>System</c> namespace prior to assigning a value to the parameter's <see paramref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> property.
        </note>
        <note type="note">
          Microsoft .NET Framework data providers that are included with the .NET Framework version 1.0 do not verify the <b>Precision</b> or <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Scale" /> of <see cref="T:System.Decimal" /> parameter values. This can cause truncated data being inserted at the data source. If you are using .NET Framework version 1.0, validate the <b>Precision</b> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Scale" /> of <see cref="T:System.Decimal" /> values before setting the parameter value. When you use .NET Framework version 1.1 or a later version, an exception is thrown if a <see cref="T:System.Decimal" /> parameter value is set with an invalid <b>Precision</b>. <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Scale" /> values that exceed the <see cref="T:System.Decimal" /> parameter scale are still truncated.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter_Precision -->
        <code language="c#">
        using System;
        using System.Data;
        using Microsoft.Data.SqlClient;
        
        class Program
        {
            private static void AddSqlParameter(SqlCommand command)
            {
                SqlParameter parameter = new SqlParameter("@Price", SqlDbType.Decimal);
                parameter.Value = 3.1416;
                parameter.Precision = 8;
                parameter.Scale = 4;
        
                command.Parameters.Add(parameter);
            }
        }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.Scale">
            <summary>
        Gets or sets the number of decimal places to which <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> is resolved.
      </summary><value>
        The number of decimal places to which <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> is resolved. The default is 0.
      </value><remarks>
        <para>
          The <b>Scale</b> property is used by parameters that have a <see cref="T:System.Data.SqlDbType" /> of <c>Decimal</c>.
        </para>
        <note type="warning">
          Data may be truncated if the <b>Scale</b> property is not explicitly specified and the data on the server does not fit in scale 0 (the default).
        </note>
        <para>
          You do not need to specify values for the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Precision" /> and <b>Scale</b> properties for input parameters, as they can be inferred from the parameter value. <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Precision" /> and <c>Scale</c> are required for output parameters and for scenarios where you need to specify complete metadata for a parameter without indicating a value, such as specifying a null value with a specific precision and scale.
        </para>
        <note type="note">
          Use of this property to coerce data passed to the database is not supported. To round, truncate, or otherwise coerce data before passing it to the database, use the <see cref="T:System.Math" /> class that is part of the <c>System</c> namespace prior to assigning a value to the parameter's <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> property.
        </note>
        <note type="note">
          .NET Framework data providers that are included with the .NET Framework version 1.0 do not verify the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Precision" /> or <b>Scale</b> of <see cref="T:System.Decimal" /> parameter values. This can cause truncated data to be inserted at the data source. If you are using .NET Framework version 1.0, validate the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Precision" /> and <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> of <see cref="T:System.Decimal" /> values before setting the parameter value. <b>Scale</b> values that exceed the <see cref="T:System.Decimal" /> parameter scale are still truncated.
        </note>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter #4 -->
        <code language="c#">
          static void CreateSqlParameterPrecisionScale()
          {
              SqlParameter parameter = new SqlParameter("Price", SqlDbType.Decimal);
              parameter.Value = 3.1416;
              parameter.Precision = 8;
              parameter.Scale = 4;
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.Size">
            <summary>
        Gets or sets the maximum size, in bytes, of the data within the column.
      </summary><value>
        The maximum size, in bytes, of the data within the column. The default value is inferred from the parameter value.
      </value><remarks>
        <para>
          Return values are not affected by this property; return parameters from stored procedures are always fixed-size integers.
        </para>
        <para>
          For output parameters with a variable length type (nvarchar, for example), the size of the parameter defines the size of the buffer holding the output parameter. The output parameter can be truncated to a size specified with <b>Size</b>. For character types, the size specified with <b>Size</b> is in characters.
        </para>
        <para>
          The <b>Size</b> property is used for binary and string types. For string type parameters, <b>Size</b> means length in Unicode characters. For parameters of type <see cref="F:System.Data.SqlDbType.Xml" />, <c>Size</c> is ignored.
        </para>
        <para>
          For non-string data types and ANSI string data, the <b>Size</b> property refers to the number of bytes. For Unicode string data, <b>Size</b> refers to the number of characters. The count for strings does not include the terminating character.
        </para>
        <para>
          For variable-length data types, <b>Size</b> describes the maximum amount of data to transmit to the server. For example, for a Unicode string value, <b>Size</b> could be used to limit the amount of data sent to the server to the first one hundred characters.
        </para>
        <para>
          If not explicitly set, the size is inferred from the actual size of the specified parameter value.
        </para>
        <para>
          If the fractional part of the parameter value is greater than the size, then the value will be truncated to match the size.
        </para>
        <para>
          For fixed length data types, the value of <b>Size</b> is ignored. It can be retrieved for informational purposes, and returns the maximum amount of bytes the provider uses when transmitting the value of the parameter to the server.
        </para>
        <para>
          For information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter #5 -->
        <code language="c#">
          static void CreateSqlParameterSize()
          {
              string description = "12 foot scarf - multiple colors, one previous owner";
              SqlParameter parameter = new SqlParameter("Description", SqlDbType.VarChar);
              parameter.Direction = ParameterDirection.InputOutput;
              parameter.Size = description.Length;
              parameter.Value = description;
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.SourceColumn">
            <summary>
        Gets or sets the name of the source column mapped to the <see cref="T:System.Data.DataSet" /> and used for loading or returning the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" />
      </summary><value>
        The name of the source column mapped to the <see cref="T:System.Data.DataSet" />. The default is an empty string.
      </value><remarks>
        <para>
          When <b>SourceColumn</b> is set to anything other than an empty string, the value of the parameter is retrieved from the column with the <b>SourceColumn</b> name. If <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Direction" /> is set to <see cref="F:System.Data.ParameterDirection.Input" />, the value is taken from the <see cref="T:System.Data.DataSet" />. If <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Direction" /> is set to <see cref="F:System.Data.ParameterDirection.Output" />, the value is taken from the data source. A <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Direction" /> of <see cref="F:System.Data.ParameterDirection.InputOutput" /> is a combination of both.
        </para>
        <para>
          For more information about how to use the <b>SourceColumn</b> property, see <see href="https://learn.microsoft.com/sql/connect/ado-net/dataadapter-parameters">DataAdapter Parameters</see> and <see href="https://learn.microsoft.com/sql/connect/ado-net/update-data-sources-with-dataadapters">Updating Data Sources with DataAdapters</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter #6 -->
        <code language="c#">
          static void CreateSqlParameterSourceColumn()
          {
              SqlParameter parameter = new SqlParameter("Description", SqlDbType.VarChar, 88);
              parameter.SourceColumn = "Description";
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.SourceColumnNullMapping">
            <summary>
        Sets or gets a value which indicates whether the source column is nullable. This allows <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> to correctly generate Update statements for nullable columns.
      </summary><value>
        <see langword="true" /> if the source column is nullable; <see langword="false" /> if it is not.
      </value><remarks>
        <para>
          <b>SourceColumnNullMapping</b> is used by the <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> to correctly generate update commands when dealing with nullable columns. Generally, use of <b>SourceColumnNullMapping</b> is limited to developers inheriting from <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" />. <see cref="T:System.Data.Common.DbCommandBuilder" /> uses this property to determine whether the source column is nullable, and sets this property to <see langword="true" /> if it is nullable, and <see langword="false" /> if it is not. When <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> is generating its UPDATE statement, it examines the <b>SourceColumnNullMapping</b> for each parameter. If the property is <see langword="true" />, <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> generates a WHERE clauses like the following (in this query expression, <c>FieldName</c> represents the name of the field):
        </para>
        <code language="sql">
          ((@IsNull_FieldName = 1 AND FieldName IS NULL) OR
          (FieldName = @Original_FieldName))
        </code>
        <para>
          If <b>SourceColumnNullMapping</b> for the field is <see langword="false" />, <see cref="T:Microsoft.Data.SqlClient.SqlCommandBuilder" /> generates the following WHERE clause:
        </para>
        <code language="sql">
          FieldName = @OriginalFieldName
        </code>
        <para>
          In addition, <c>@IsNull_FieldName</c> contains 1 if the source field contains null, and 0 if it does not. This mechanism allows for a performance optimization in SQL Server, and provides for common code that works across multiple providers.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.SourceVersion">
            <summary>
        Gets or sets the <see cref="T:System.Data.DataRowVersion" /> to use when you load <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" />
      </summary><value>
        One of the <see cref="T:System.Data.DataRowVersion" /> values. The default is <see cref="F:System.Data.DataRowVersion.Current" />.
      </value><remarks>
        This property is used by the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" /> during an update to determine whether the original or current value is used for a parameter value. This lets primary keys be updated. This property is set to the version of the <see cref="T:System.Data.DataRow" /> used by the <see cref="P:System.Data.DataRow.Item(System.String)" /> property, or one of the <see cref="M:System.Data.DataRow.GetChildRows(System.String)" /> methods of the <see cref="T:System.Data.DataRow" /> object.
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <code language="c#">
          static void CreateSqlParameterSourceVersion()
          {
              SqlParameter parameter = new SqlParameter("Description", SqlDbType.VarChar, 88);
              parameter.SourceColumn = "Description";
              parameter.SourceVersion = DataRowVersion.Current;
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType">
            <summary>
        Gets or sets the <see cref="T:System.Data.SqlDbType" /> of the parameter.
      </summary><value>
        One of the <see cref="T:System.Data.SqlDbType" /> values. The default is <see cref="F:System.Data.SqlDbType.NvarChar" />.
      </value><remarks>
        <para>
          The <b>SqlDbType</b> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> are linked. Therefore, setting the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> changes the <b>SqlDbType</b> to a supporting <see cref="T:System.Data.SqlDbType" />.
        </para>
        <para>
          For a list of the supported data types, see the appropriate <see cref="T:System.Data.SqlDbType" /> member. For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/dataadapter-parameters">DataAdapter Parameters</see>.
        </para>
        <para>
          For information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.SqlValue">
            <summary>
        Gets or sets the value of the parameter as an SQL type.
      </summary><value>
        An <see cref="T:System.Object" /> that is the value of the parameter, using SQL types. The default value is <see langword="null" />.
      </value><remarks>
        <para>
          For input parameters, the value is bound to the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> that is sent to the server. For output and return value parameters, the value is set on completion of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and after the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed.
        </para>
        <para>
          This property can be set to null or <see cref="F:System.DBNull.Value" />. Use <see cref="F:System.DBNull.Value" /> to send a NULL value as the value of the parameter. Use null or do not set <b>SqlValue</b> to use the default value for the parameter.
        </para>
        <para>
          If the application specifies the database type, the bound value is converted to that type when the provider sends the data to the server. The provider tries to convert any type of value if it supports the <see cref="T:System.IConvertible" /> interface. Conversion errors may result if the specified type is not compatible with the value.
        </para>
        <para>
          Both the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> properties can be inferred by setting the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" />.
        </para>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> property is overwritten by <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />.
        </para>
        <para>
          Use the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.Value" /> property to return parameter values as common language runtime (CLR) types.
        </para>
        <para>
          For information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.TypeName">
            <summary>
        Gets or sets the type name for a table-valued parameter.
      </summary><value>
        The type name of the specified table-valued parameter.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.UdtTypeName">
            <summary>
        Gets or sets a <see cref="T:System.String" /> that represents a user-defined type as a parameter.
      </summary><value>
        A <see cref="T:System.String" /> that represents the fully qualified name of a user-defined type in the database.
      </value><remarks>
        For a sample demonstrating <b>UdtTypeName</b>, see <see href="https://learn.microsoft.com/sql/relational-databases/clr-integration-database-objects-user-defined-types/accessing-user-defined-types-retrieving-udt-data">Retrieving UDT Data</see>.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.Value">
            <summary>
        Gets or sets the value of the parameter.
      </summary><value>
        An <see cref="T:System.Object" /> that is the value of the parameter. The default value is null.
      </value><remarks>
        <para>
          For input parameters, the value is bound to the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> that is sent to the server. For output and return value parameters, the value is set on completion of the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and after the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> is closed.
        </para>
        <para>
          This property can be set to <see langword="null" /> or <see cref="F:System.DBNull.Value" />. Use <see cref="F:System.DBNull.Value" /> to send a NULL value as the value of the parameter. Use <see langword="null" /> or do not set <b>Value</b> to use the default value for the parameter.
        </para>
        <para>
          An exception is thrown if non-Unicode XML data is passed as a string.
        </para>
        <para>
          If the application specifies the database type, the bound value is converted to that type when the provider sends the data to the server. The provider tries to convert any type of value if it supports the <see cref="T:System.IConvertible" /> interface. Conversion errors may result if the specified type is not compatible with the value.
        </para>
        <para>
          Both the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> properties can be inferred by setting <b>Value</b>.
        </para>
        <para>
          The <b>Value</b> property is overwritten by <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.UpdateCommand" />.
        </para>
        <para>
          For information about streaming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sqlclient-streaming-support">SqlClient Streaming Support</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> and sets some of its properties.
        </para>
        <!-- SqlParameter #8 -->
        <code language="c#">
          static void CreateSqlParameterVersion()
          {
              SqlParameter parameter = new SqlParameter("Description", SqlDbType.VarChar, 88);
              parameter.Value = "garden hose";
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionDatabase">
            <summary>
        Gets the name of the database where the schema collection for this XML instance is located.
      </summary><value>
        The name of the database where the schema collection for this XML instance is located.
      </value><remarks>
        This value is null (<c>Nothing</c> in Microsoft Visual Basic) if the collection is defined within the current database. It is also null if there is no schema collection, in which case <see cref="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionName" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionOwningSchema" /> are also null.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionName">
            <summary>
        Gets the name of the schema collection for this XML instance.
      </summary><value>
        The name of the schema collection for this XML instance.
      </value><remarks>
        <para>
          This value is null (<c>Nothing</c> in Microsoft Visual Basic) if there is no associated schema collection. If the value is null, then <see cref="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionDatabase" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionOwningSchema" /> are also null.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionOwningSchema">
            <summary>
        The owning relational schema where the schema collection for this XML instance is located.
      </summary><value>
        The owning relational schema for this XML instance.
      </value><remarks>
        This value is null (<c>Nothing</c> in Microsoft Visual Basic) if the collection is defined within the current database. It is also null if there is no schema collection, in which case <see cref="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionDatabase" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.XmlSchemaCollectionName" /> are also null.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.ResetDbType">
            <summary>
        Resets the type associated with this <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </summary><remarks>
        When executing a command that includes parameter values, code can either set the type of parameter explicitly, or the parameter can infer its type from its value. Calling this method resets the parameter so that it can again infer its type from the value passed in the parameter. Calling this method affects both the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> properties of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.ResetSqlDbType">
            <summary>
        Resets the type associated with this <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </summary><remarks>
        When executing a command that includes parameter values, code can either set the type of parameter explicitly, or the parameter can infer its type from its value. Calling this method resets the parameter so that it can again infer its type from the value passed in the parameter. Calling this method affects both the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.DbType" /> and <see cref="P:Microsoft.Data.SqlClient.SqlParameter.SqlDbType" /> properties of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameter.ToString">
            <summary>
        Gets a string that contains the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.ParameterName" />.
      </summary><returns>
        A string that contains the <see cref="P:Microsoft.Data.SqlClient.SqlParameter.ParameterName" />.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlParameterCollection">
            <summary>
        Represents a collection of parameters associated with a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> and their respective mappings to columns in a <see cref="T:System.Data.DataSet" />. This class cannot be inherited.
      </summary><remarks>
        <para>
          If the command contains an ad hoc SQL statement, as opposed to a stored-procedure name, the number of the parameters in the collection must be equal to the number of parameter placeholders within the command text, or SQL Server raises an error. With a stored procedure, all the parameters declared in the stored procedure without a default value must be provided. Parameters declared with a default value are optional. This lets you specify a value other than the default.
        </para>
        <para>
          For more information with additional sample code demonstrating how to use parameters, see <see href="https://learn.microsoft.com/sql/connect/ado-net/commands-parameters">Commands and Parameters</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates multiple instances of <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> through the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> collection. The parameters are used to select data within the data source and populate the <see cref="T:System.Data.DataSet" />. This code assumes that a <see cref="T:System.Data.DataSet" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" /> have already been created with the appropriate schema, commands, and connection.
        </para>
        <!-- SqlParameterCollection_Add6 -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              protected DataSet categoriesDataSet;
              protected DataGrid dataGrid1;
              protected SqlDataAdapter categoriesAdapter;
          
          
              public void AddSqlParameters()
              {
                  // ...
                  // create categoriesDataSet and categoriesAdapter
                  // ...
          
                  categoriesAdapter.SelectCommand.Parameters.Add(
                      "@CategoryName",
                      SqlDbType.VarChar,
                      80
                  ).Value = "toasters";
                  categoriesAdapter.SelectCommand.Parameters.Add(
                    "@SerialNum",
                    SqlDbType.Int
                  ).Value = 239;
                  categoriesAdapter.Fill(categoriesDataSet);
          
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.#ctor">
            <summary>Constructs and initializes a new instance of <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.</summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameterCollection.Count">
            <summary>
        Returns an Integer that contains the number of elements in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />. Read-only.
      </summary><value>
        The number of elements in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> as an Integer.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameterCollection.IsFixedSize">
            <summary>
        Gets a value that indicates whether the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> has a fixed size.
      </summary><value>
        <see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> has a fixed size; otherwise, <see langword="false" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameterCollection.IsReadOnly">
            <summary>
        Gets a value that indicates whether the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> is read-only.
      </summary><value>
        <see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> is read-only; otherwise, <see langword="false" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameterCollection.Item(System.Int32)">
            <param name="index">
        The zero-based index of the parameter to retrieve.
      </param><summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> at the specified index.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> at the specified index.
      </value><example>
        <para>
          The following example demonstrates creating <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> objects to supply an input parameter to a stored procedure that returns results in an output parameter. The code iterates through the items in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> and displays some parameter properties in the console window. This example assumes a valid connection string to the <b>AdventureWorks</b> sample database on an instance of SQL Server.
        </para>
        <!-- SqlParameterCollection_Count -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  // Supply any valid Document ID value.
                  // The value 7 is supplied for demonstration purposes.
                  string summaryString = CreateSqlParameters(7);
                  Console.ReadLine();
              }
              
              static private string CreateSqlParameters(int documentID)
              {
                  // Assumes GetConnectionString returns a valid connection string to the
                  // AdventureWorks sample database on an instance of SQL Server 2005.
                  using (SqlConnection connection = new SqlConnection(GetConnectionString()))
                  {
                      connection.Open();
                      SqlCommand command = connection.CreateCommand();
                      try
                      {
                          // Setup the command to execute the stored procedure.
                          command.CommandText = "GetDocumentSummary";
                          command.CommandType = CommandType.StoredProcedure;
          
                          // Create the input parameter for the DocumentID.
                          SqlParameter paramID = new SqlParameter("@DocumentID", SqlDbType.Int);
                          paramID.Value = documentID;
                          command.Parameters.Add(paramID);
          
                          // Create the output parameter to retrieve the summary.
                          SqlParameter paramSummary = new SqlParameter("@DocumentSummary", SqlDbType.NVarChar, -1);
                          paramSummary.Direction = ParameterDirection.Output;
                          command.Parameters.Add(paramSummary);
          
                          // List the parameters and some of properties.
                          SqlParameterCollection paramCollection = command.Parameters;
                          string parameterList = "";
                          for (int i = 0; i &lt; paramCollection.Count; i++)
                          {
                              parameterList += String.Format("  {0}, {1}, {2}\n",
                                  paramCollection[i], paramCollection[i].DbType,
                                  paramCollection[i].Direction);
                          }
                          Console.WriteLine("Parameter Collection:\n" + parameterList);
          
                          // Execute the stored procedure; retrieve
                          // and display the output parameter value.
                          command.ExecuteNonQuery();
                          Console.WriteLine((String)(paramSummary.Value));
                          return (String)(paramSummary.Value);
                      }
                      catch (Exception ex)
                      {
                          Console.WriteLine(ex.Message);
                          return null;
                      }
                  }
              }
              
              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file, using the 
                  // System.Configuration.ConfigurationSettings.AppSettings property
                  return "Data Source=(local);Initial Catalog=AdventureWorks;" +
                         "Integrated Security=SSPI";
              }
          }
        </code>
      </example><exception cref="T:System.IndexOutOfRangeException">
        The specified index does not exist.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameterCollection.Item(System.String)">
            <param name="parameterName">
        The name of the parameter to retrieve.
      </param><summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> with the specified name.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> with the specified name.
      </value><remarks>
        The <paramref name="parameterName" /> is used to look up the index value in the underlying <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />. If the <paramref name="parameterName" /> is not valid, an <see cref="T:System.IndexOutOfRangeException" /> will be thrown.
      </remarks><exception cref="T:System.IndexOutOfRangeException">
        The specified <paramref name="parameterName" /> is not valid.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlParameterCollection.SyncRoot">
            <summary>
        Gets an object that can be used to synchronize access to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><value>
        An object that can be used to synchronize access to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </value>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Add(Microsoft.Data.SqlClient.SqlParameter)">
            <param name="value">
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to add to the collection.
      </param><summary>
        Adds the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><returns>
        A new <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </returns><example>
        <!-- SqlParameterCollection_Add -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          public class Sample
          {
              public void AddSqlParameter(SqlCommand command)
              {
                  command.Parameters.Add(new SqlParameter("Description", "Beverages"));
              }
          }
        </code>
      </example><exception cref="T:System.ArgumentException">
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> specified in the <paramref name="value" /> parameter is already added to this or another <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </exception><exception cref="T:System.InvalidCastException">
        The parameter passed was not a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </exception><exception cref="T:System.ArgumentNullException">
        The <paramref name="value" /> parameter is null.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Add(System.Object)">
            <param name="value">
        An <see cref="T:System.Object" />.
      </param><summary>
        Adds the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><returns>
        The index of the new <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Add(System.String,System.Data.SqlDbType)">
            <param name="parameterName">
        The name of the parameter.
      </param><param name="sqlDbType">
        One of the <see cref="T:System.Data.SqlDbType" /> values.
      </param><summary>
        Adds a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> given the parameter name and the data type.
      </summary><returns>
        A new <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </returns><example>
        <!-- SqlParameterCollection_Add3 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          public class Sample
          {
              public void AddSqlParameter(SqlCommand command)
              {
                  SqlParameter param = command.Parameters.Add(
                      "@Description",
                      SqlDbType.NVarChar);
                  param.Size = 16;
                  param.Value = "Beverages";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Add(System.String,System.Data.SqlDbType,System.Int32)">
            <param name="parameterName">
        The name of the parameter.
      </param><param name="sqlDbType">
        The <see cref="T:System.Data.SqlDbType" /> of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to add to the collection.
      </param><param name="size">
        The size as an <see cref="T:System.Int32" />.
      </param><summary>
        Adds a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />, given the specified parameter name, <see cref="T:System.Data.SqlDbType" /> and size.
      </summary><returns>
        A new <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </returns><remarks>
        This overload is useful when you are adding a parameter of a variable-length data type such as <c>varchar</c> or <c>binary</c>.
      </remarks><example>
        <!-- SqlParameterCollection_Add1 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          public class Sample
          {
              public void AddSqlParameter(SqlCommand command)
              {
                  SqlParameter param = new SqlParameter(
                      "@Description",
                      SqlDbType.NVarChar,
                      16);
                  param.Value = "Beverages";
                  command.Parameters.Add(param);
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Add(System.String,System.Data.SqlDbType,System.Int32,System.String)">
            <param name="parameterName">
        The name of the parameter.
      </param><param name="sqlDbType">
        One of the <see cref="T:System.Data.SqlDbType" /> values.
      </param><param name="size">
        The column length.
      </param><param name="sourceColumn">
        The name of the source column (<see cref="P:Microsoft.Data.SqlClient.SqlParameter.SourceColumn" />) if this <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> is used in a call to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </param><summary>
        Adds a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> with the parameter name, the data type, and the column length.
      </summary><returns>
        A new <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </returns><example>
        <!-- SqlParameterCollection_Add5 -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          public class Sample
          {
              public void AddSqlParameter(SqlCommand cmd)
              {
                  SqlParameter p1 = cmd.Parameters.Add("@Description", SqlDbType.NVarChar, 16, "Description");
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.AddRange(Microsoft.Data.SqlClient.SqlParameter[])">
            <param name="values">
        The <see cref="T:System.Array" /> values to add.
      </param><summary>
        Adds an array of values to the end of the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.AddRange(System.Array)">
            <param name="values">
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> values to add.
      </param><summary>
        Adds an array of <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> values to the end of the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.AddWithValue(System.String,System.Object)">
            <param name="parameterName">
        The name of the parameter.
      </param><param name="value">
        The value to be added. Use <see cref="F:System.DBNull.Value" /> instead of null, to indicate a null value.
      </param><summary>
        Adds a value to the end of the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object.
      </returns><remarks>
        <para>
          <b>AddWithValue</b> replaces the <b>SqlParameterCollection.Add</b> method that takes a <see cref="T:System.String" /> and an <see cref="T:System.Object" />. The overload of <b>Add</b> that takes a string and an object was deprecated because of possible ambiguity with the <b>SqlParameterCollection.Add</b> overload that takes a <see cref="T:System.String" /> and a <see cref="T:System.Data.SqlDbType" /> enumeration value where passing an integer with the string could be interpreted as being either the parameter value or the corresponding <see cref="T:System.Data.SqlDbType" /> value. Use <b>AddWithValue</b> whenever you want to add a parameter by specifying its name and value.
        </para>
        <para>
          For <see cref="F:System.Data.SqlDbType.Xml" /> enumeration values, you can use a string, an XML value, an <see cref="T:System.Xml.XmlReader" /> derived type instance, or a <see cref="T:System.Data.SqlTypes.SqlXml" /> object.
        </para>
      </remarks><example>
        <para>
          The following example demonstrates how to use the <b>AddWithValue</b> method.
        </para>
        <!-- SqlParameterCollection_AddWithValue -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string connectionString = GetConnectionString();
                  string demo = @"&lt;StoreSurvey xmlns=""http://schemas.microsoft.com/sqlserver/2004/07/adventure-works/StoreSurvey""&gt;&lt;AnnualSales&gt;1500000&lt;/AnnualSales&gt;&lt;AnnualRevenue&gt;150000&lt;/AnnualRevenue&gt;&lt;BankName&gt;Primary International&lt;/BankName&gt;&lt;BusinessType&gt;OS&lt;/BusinessType&gt;&lt;YearOpened&gt;1974&lt;/YearOpened&gt;&lt;Specialty&gt;Road&lt;/Specialty&gt;&lt;SquareFeet&gt;38000&lt;/SquareFeet&gt;&lt;Brands&gt;3&lt;/Brands&gt;&lt;Internet&gt;DSL&lt;/Internet&gt;&lt;NumberEmployees&gt;40&lt;/NumberEmployees&gt;&lt;/StoreSurvey&gt;";
                  Int32 id = 3;
                  UpdateDemographics(id, demo, connectionString);
                  Console.ReadLine();
              }
              
              private static void UpdateDemographics(
                  Int32 customerID,
                  string demoXml,
                  string connectionString)
              {
                  // Update the demographics for a store, which is stored 
                  // in an xml column. 
                  string commandText = "UPDATE Sales.Store SET Demographics = @demographics "
                      + "WHERE CustomerID = @ID;";
          
                  using (SqlConnection connection = new SqlConnection(connectionString))
                  {
                      SqlCommand command = new SqlCommand(commandText, connection);
                      command.Parameters.Add("@ID", SqlDbType.Int);
                      command.Parameters["@ID"].Value = customerID;
          
                      // Use AddWithValue to assign Demographics.
                      // SQL Server will implicitly convert strings into XML.
                      command.Parameters.AddWithValue("@demographics", demoXml);
          
                      try
                      {
                          connection.Open();
                          Int32 rowsAffected = command.ExecuteNonQuery();
                          Console.WriteLine("RowsAffected: {0}", rowsAffected);
                      }
                      catch (Exception ex)
                      {
                          Console.WriteLine(ex.Message);
                      }
                  }
              }

              static private string GetConnectionString()
              {
                  // To avoid storing the connection string in your code, 
                  // you can retrieve it from a configuration file.
                  return "Data Source=(local);Initial Catalog=AdventureWorks;"
                       + "Integrated Security=SSPI";
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Clear">
            <summary>
        Removes all the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> objects from the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Contains(Microsoft.Data.SqlClient.SqlParameter)">
            <param name="value">
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> value.
      </param><summary>
        Determines whether the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> is in this <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><returns>
        <see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> contains the value; otherwise, <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Contains(System.Object)">
            <param name="value">
        The <see cref="T:System.Object" /> value.
      </param><summary>
        Determines whether the specified <see cref="T:System.Object" /> is in this <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><returns>
        <see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> contains the value; otherwise, <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Contains(System.String)">
            <param name="value">
        The <see cref="T:System.String" /> value.
      </param><summary>
        Determines whether the specified parameter name is in this <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><returns>
        <see langword="true" /> if the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> contains the value; otherwise, <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.CopyTo(System.Array,System.Int32)">
            <param name="array">
        The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from the current <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </param><param name="index">
        A 32-bit integer that represents the index in the <see cref="T:System.Array" /> at which copying starts.
      </param><summary>
        Copies all the elements of the current <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> to the specified one-dimensional <see cref="T:System.Array" /> starting at the specified destination <see cref="T:System.Array" /> index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.CopyTo(Microsoft.Data.SqlClient.SqlParameter[],System.Int32)">
            <param name="array">
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> that is the destination of the elements copied from the current <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </param><param name="index">
        A 32-bit integer that represents the index in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> at which copying starts.
      </param><summary>
        Copies all the elements of the current <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> to the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> starting at the specified destination index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><returns>
        An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.GetParameter(System.Int32)">
            <param name="index">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.GetParameter(System.String)">
            <param name="parameterName">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.IndexOf(Microsoft.Data.SqlClient.SqlParameter)">
            <param name="value">
        The <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to find.
      </param><summary>
        Gets the location of the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> within the collection.
      </summary><returns>
        The zero-based location of the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> that is a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> within the collection. Returns -1 when the object does not exist in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.IndexOf(System.Object)">
            <param name="value">
        The <see cref="T:System.Object" /> to find.
      </param><summary>
        Gets the location of the specified <see cref="T:System.Object" /> within the collection.
      </summary><returns>
        The zero-based location of the specified <see cref="T:System.Object" /> that is a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> within the collection. Returns -1 when the object does not exist in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.IndexOf(System.String)">
            <param name="parameterName">
        The case-sensitive name of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to find.
      </param><summary>
        Gets the location of the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> with the specified name.
      </summary><returns>
        The zero-based location of the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> with the specified case-sensitive name. Returns -1 when the object does not exist in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Insert(System.Int32,Microsoft.Data.SqlClient.SqlParameter)">
            <param name="index">
        The zero-based index at which value should be inserted.
      </param><param name="value">
        A <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object to be inserted in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </param><summary>
        Inserts a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object into the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> at the specified index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Insert(System.Int32,System.Object)">
            <param name="index">
        The zero-based index at which value should be inserted.
      </param><param name="value">
        An <see cref="T:System.Object" /> to be inserted in the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </param><summary>
        Inserts an <see cref="T:System.Object" /> into the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> at the specified index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Remove(Microsoft.Data.SqlClient.SqlParameter)">
            <param name="value">
        A <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object to remove from the collection.
      </param><summary>
        Removes the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> from the collection.
      </summary><example>
        <para>
          The following example searches for a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object in a <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> collection. If the parameter exists, the example removes it. This example assumes that a <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> collection has already been created by a <see cref="T:Microsoft.Data.SqlClient.SqlCommand" />.
        </para>
        <!-- SqlParameterCollection_Remove -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              protected DataSet DataSet1;
              protected DataGrid dataGrid1;
              protected SqlCommand command;
              protected SqlParameter param;
          
              public void SearchSqlParams()
              {
                  // ...
                  // create SqlCommand command and SqlParameter param
                  // ...
                  if (command.Parameters.Contains(param))
                  {
                      command.Parameters.Remove(param);
                  }
              }
          }
        </code>
      </example><exception cref="T:System.InvalidCastException">
        The parameter is not a <see cref="T:Microsoft.Data.SqlClient.SqlParameter" />.
      </exception><exception cref="T:System.SystemException">
        The parameter does not exist in the collection.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.Remove(System.Object)">
            <param name="value">
        The object to remove from the collection.
      </param><summary>
        Removes the specified <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> from the collection.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.RemoveAt(System.Int32)">
            <param name="index">
        The zero-based index of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> object to remove.
      </param><summary>
        Removes the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> from the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> at the specified index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.RemoveAt(System.String)">
            <param name="parameterName">
        The name of the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> to remove.
      </param><summary>
        Removes the <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> from the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" /> at the specified parameter name.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.SetParameter(System.Int32,System.Data.Common.DbParameter)">
            <param name="index">
        To be added.
      </param><param name="value">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlParameterCollection.SetParameter(System.String,System.Data.Common.DbParameter)">
            <param name="parameterName">
        To be added.
      </param><param name="value">
        To be added.
      </param><summary>
        To be added.
      </summary><remarks>
        To be added.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs">
            <summary>
        Represents the set of arguments passed to the <see cref="T:Microsoft.Data.SqlClient.SqlRowsCopiedEventHandler" /> .
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs.#ctor(System.Int64)">
            <param name="rowsCopied">
        An <see cref="T:System.Int64" /> that indicates the number of rows copied during the current bulk copy operation.
      </param><summary>
        Creates a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs" /> object.
      </summary><remarks>
        The value in the <paramref name="rowsCopied" /> parameter is reset on each call to any one of the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" /> methods.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs.Abort">
            <summary>
        Gets or sets a value that indicates whether the bulk copy operation should be aborted.
      </summary><value> <see langword="true" /> if the bulk copy operation should be aborted; otherwise <see langword="false" />.</value><remarks>
        <para>
          Use the <b>Abort</b> property to cancel a bulk copy operation. Set <b>Abort</b> to <see langword="true" /> to abort the bulk copy operation.
        </para>
        <para>
          If you call the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.Close" /> method from <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" />, an exception is generated, and the <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> object state does not change.
        </para>
        <para>
          If an application specifically creates a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> object in the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> constructor, the transaction is not rolled back. The application is responsible for determining whether it is required to roll back the operation, and if so, it must call the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> method. If the application does not create a transaction, the internal transaction corresponding to the current batch is automatically rolled back. However, changes related to previous batches within the bulk copy operation are retained, because the transactions for them already have been committed.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs.RowsCopied">
            <summary>
        Gets a value that returns the number of rows copied during the current bulk copy operation.
      </summary><value>
        <see langword="int" /> that returns the number of rows copied.
      </value><remarks>
        The value in the <see cref="P:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs.RowsCopied" /> property is reset on each call to any of the <see cref="M:Microsoft.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" /> methods.
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRowsCopiedEventHandler">
            <param name="sender">
        The source of the event.
      </param><param name="e">
        A <see cref="T:Microsoft.Data.SqlClient.SqlRowsCopiedEventArgs" /> object that contains the event data.
      </param><summary>
        Represents the method that handles the <see cref="E:Microsoft.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" /> event of a <see cref="T:Microsoft.Data.SqlClient.SqlBulkCopy" /> .
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRowUpdatedEventArgs">
            <summary>
        Provides data for the <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> event.
      </summary><remarks>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> event is raised when an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> to a row is completed.
        </para>
        <para>
          When using <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, there are two events that occur for each data row updated. The order of execution is as follows:
        </para>
        <list type="number">
          <item>The values in the <see cref="T:System.Data.DataRow" /> are moved to the parameter values.</item>
          <item>The <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> event is raised.</item>
          <item>The command executes.</item>
          <item>If the command is set to <c>FirstReturnedRecord</c>, and the first returned result is placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>If there are output parameters, they are placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>The <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> event is raised.</item>
          <item><see cref="M:System.Data.DataRow.AcceptChanges" /> is called.</item>
        </list>
      </remarks><example>
        <para>
          The following example shows how to use both the <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> and <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> events.
        </para>
        <!-- SqlDataAdapter_RowUpdated -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              private DataSet DataSet1;
              private DataGrid dataGrid1;
          
              // handler for RowUpdating event
              private static void OnRowUpdating(object sender, SqlRowUpdatingEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              // handler for RowUpdated event
              private static void OnRowUpdated(object sender, SqlRowUpdatedEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              public static int Main()
              {
                  const string connectionString =
                            "Integrated Security=SSPI;database=Northwind;server=MSSQL1";
                  const string queryString = "SELECT * FROMProducts";
          
                  // create DataAdapter
                  SqlDataAdapter adapter = new SqlDataAdapter(queryString, connectionString);
                  SqlCommandBuilder builder = new SqlCommandBuilder(adapter);
          
                  // Create and fill DataSet (select only first 5 rows)
                  DataSet dataSet = new DataSet();
                  adapter.Fill(dataSet, 0, 5, "Table");
          
                  // Modify DataSet
                  DataTable table = dataSet.Tables["Table"];
                  table.Rows[0][1] = "new product";
          
                  // add handlers
                  adapter.RowUpdating += new SqlRowUpdatingEventHandler(OnRowUpdating);
                  adapter.RowUpdated += new SqlRowUpdatedEventHandler(OnRowUpdated);
          
                  // update, this operation fires two events 
                  // (RowUpdating/RowUpdated) per changed row 
                  adapter.Update(dataSet, "Table");
          
                  // remove handlers
                  adapter.RowUpdating -= new SqlRowUpdatingEventHandler(OnRowUpdating);
                  adapter.RowUpdated -= new SqlRowUpdatedEventHandler(OnRowUpdated);
                  return 0;
              }
          
              private static void PrintEventArgs(SqlRowUpdatingEventArgs args)
              {
                  Console.WriteLine("OnRowUpdating");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " status=" + args.Status + ")");
              }
          
              private static void PrintEventArgs(SqlRowUpdatedEventArgs args)
              {
                  Console.WriteLine("OnRowUpdated");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " recordsAffected=" + args.RecordsAffected +
                      " status=" + args.Status + ")");
              }
          }
        </code>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> event returns this output:
        </para>
        <code>
          Event Arguments: (command=Microsoft.Data.SqlClient.SqlCommand commandType=2 status=0)
        </code>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> event returns this output:
        </para>
        <code>
          Event Arguments: (command=Microsoft.Data.SqlClient.SqlCommand commandType=2 recordsAffected=1 row=System.Data.DataRow[37] status=0)
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRowUpdatedEventArgs.#ctor(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <param name="row">
        The <see cref="T:System.Data.DataRow" /> sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </param><param name="command">
        The <see cref="T:System.Data.IDbCommand" /> executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> is called.
      </param><param name="statementType">
        One of the <see cref="T:System.Data.StatementType" /> values that specifies the type of query executed.
      </param><param name="tableMapping">
        The <see cref="T:System.Data.Common.DataTableMapping" /> sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlRowUpdatedEventArgs" /> class.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRowUpdatedEventArgs.Command">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> is called.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> is called.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRowUpdatedEventHandler">
            <param name="sender">
        The source of the event.
      </param><param name="e">
        The <see cref="T:Microsoft.Data.SqlClient.SqlRowUpdatedEventArgs" /> that contains the event data.
      </param><summary>
        Represents the method that will handle the <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> event of a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
      </summary><remarks>
        <para>
          The handler is not required to perform any action, and your code should avoid generating exceptions or allowing exceptions to propagate to the calling method. Any exceptions that do reach the caller are ignored.
        </para>
        <para>
          When you create a <see cref="T:Microsoft.Data.SqlClient.SqlRowUpdatedEventArgs" /> delegate, you identify the method that will handle the event. To associate the event with your event handler, add an instance of the delegate to the event. The event handler is called whenever the event occurs, unless you remove the delegate. For more information about event handler delegates, see <see href="https://learn.microsoft.com/dotnet/standard/events/">Handling and Raising Events</see>.
        </para>
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs">
            <summary>
        Provides data for the <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> event.
      </summary><remarks>
        <para>
          The <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> event is raised before an <see cref="E:System.Data.Common.DbDataAdapter.Update" /> to a row.
        </para>
        <para>
          When you are using <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />, there are two events that occur for each data row updated. The order of execution is as follows:
        </para>
        <list type="number">
          <item>The values in the <see cref="T:System.Data.DataRow" /> are moved to the parameter values.</item>
          <item>The <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> event is raised.</item>
          <item>The command executes.</item>
          <item>If the command is set to <c>FirstReturnedRecord</c>, and the first returned result is placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>If there are output parameters, they are placed in the <see cref="T:System.Data.DataRow" />.</item>
          <item>The <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> event is raised.</item>
          <item><see cref="M:System.Data.DataRow.AcceptChanges" /> is called.</item>
        </list>
      </remarks><example>
        <para>
          The following example shows how to use both the <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> and <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> events.
        </para>
        <!-- SqlRowUpdatingEventArgs -->
        <code language="c#">
          using System;
          using System.Data;
          using System.Data.Common;
          using System.Windows.Forms;
          using System.Xml;
          using Microsoft.Data.SqlClient;
          
          public class Form1 : Form
          {
              private DataSet DataSet1;
              private DataGrid dataGrid1;
          
          
              // handler for RowUpdating event
              private static void OnRowUpdating(object sender, SqlRowUpdatingEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              //Handler for RowUpdated event.
              private static void OnRowUpdated(object sender, SqlRowUpdatedEventArgs e)
              {
                  PrintEventArgs(e);
              }
          
              public static int Main()
              {
                  const string CONNECTION_STRING = "Persist Security Info=False;Integrated Security=SSPI;database=northwind;server=mySQLServer";
                  const string SELECT_ALL = "select * from Products";
          
                  //Create DataAdapter.
                  SqlDataAdapter rAdapter = new SqlDataAdapter(SELECT_ALL, CONNECTION_STRING);
          
                  //Create and fill DataSet (Select only first 5 rows.).
                  DataSet rDataSet = new DataSet();
                  rAdapter.Fill(rDataSet, 0, 5, "Table");
          
                  //Modify DataSet.
                  DataTable rTable = rDataSet.Tables["Table"];
                  rTable.Rows[0][1] = "new product";
          
                  //Add handlers.
                  rAdapter.RowUpdating += new SqlRowUpdatingEventHandler(OnRowUpdating);
                  rAdapter.RowUpdated += new SqlRowUpdatedEventHandler(OnRowUpdated);
          
                  //Update--this operation fires two events (RowUpdating and RowUpdated) for each changed row. 
                  rAdapter.Update(rDataSet, "Table");
          
                  //Remove handlers.
                  rAdapter.RowUpdating -= new SqlRowUpdatingEventHandler(OnRowUpdating);
                  rAdapter.RowUpdated -= new SqlRowUpdatedEventHandler(OnRowUpdated);
                  return 0;
              }
          
              private static void PrintEventArgs(SqlRowUpdatingEventArgs args)
              {
                  Console.WriteLine("OnRowUpdating");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " status=" + args.Status + ")");
              }
          
              private static void PrintEventArgs(SqlRowUpdatedEventArgs args)
              {
                  Console.WriteLine("OnRowUpdated");
                  Console.WriteLine("  event args: (" +
                      " command=" + args.Command +
                      " commandType=" + args.StatementType +
                      " recordsAffected=" + args.RecordsAffected +
                      " status=" + args.Status + ")");
              }
          }
        </code>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> event returns this output:
        </para>
        <code>
          event args: (command=Microsoft.Data.SqlClient.SQLCommand commandType=2 status=0)
        </code>
        <para>
          The <see cref="P:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdated" /> event returns this output:
        </para>
        <code>
          event args: (command=Microsoft.Data.SqlClient.SQLCommand commandType=2 recordsAffected=1 row=System.Data.DataRow[37] status=0)
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs.#ctor(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <param name="row">
        The <see cref="T:System.Data.DataRow" /> to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </param><param name="command">
        The <see cref="T:System.Data.IDbCommand" /> to execute during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </param><param name="statementType">
        One of the <see cref="T:System.Data.StatementType" /> values that specifies the type of query executed.
      </param><param name="tableMapping">
        The <see cref="T:System.Data.Common.DataTableMapping" /> sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs" /> class.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs.BaseCommand">
            <summary>
        To be added.
      </summary><value>
        To be added.
      </value><remarks>
        To be added.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs.Command">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> to execute when performing the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> to execute when performing the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRowUpdatingEventHandler">
            <param name="sender">
        The source of the event.
      </param><param name="e">
        The <see cref="T:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs" /> that contains the event data.
      </param><summary>
        Represents the method that will handle the <see cref="E:Microsoft.Data.SqlClient.SqlDataAdapter.RowUpdating" /> event of a <see cref="T:Microsoft.Data.SqlClient.SqlDataAdapter" />.
      </summary><remarks>
        <para>
          The handler is not required to perform any action, and your code should avoid generating exceptions or allowing exceptions to propagate to the calling method. Any exceptions that do reach the caller are ignored.
        </para>
        <para>
          The handler may use the <see cref="T:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs" /> to influence the processing of the updates. For example, the handler may opt to skip the update of the current row or skip the update of all remaining rows. Note that the rows are updated in the order that they were received from the data source.
        </para>
        <para>
          When you create a <see cref="T:Microsoft.Data.SqlClient.SqlRowUpdatingEventArgs" /> delegate, you identify the method that will handle the event. To associate the event with your event handler, add an instance of the delegate to the event. The event handler is called whenever the event occurs, unless you remove the delegate. For more information about event handler delegates, see <see href="https://learn.microsoft.com/dotnet/standard/events/">Handling and Raising Events</see>.
        </para>
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlTransaction">
            <summary>
        Represents a Transact-SQL transaction to be made in a SQL Server database. This class cannot be inherited.
      </summary><remarks>
        <para>
          The application creates a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> object by calling <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> on the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object. All subsequent operations associated with the transaction (for example, committing or aborting the transaction), are performed on the <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> object.
        </para>
        <note type="note">
          <c>Try</c> / <c>Catch</c> exception handling should always be used when committing or rolling back a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. Both <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> generate an <see cref="T:System.InvalidOperationException" /> if the connection is terminated or if the transaction has already been rolled back on the server.
        </note>
        <para>
          For more information on SQL Server transactions, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transactions-transact-sql">Explicit Transactions</see>
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. It also demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />, and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> methods. The transaction is rolled back on any error, or if it is disposed without first being committed. <c>Try</c> / <c>Catch</c> error handling is used to handle any errors when attempting to commit or roll back the transaction.
        </para>
        <!-- SqlConnection_BeginTransaction -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace Transaction1CS
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString =
                          "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      ExecuteSqlTransaction(connectionString);
                      Console.ReadLine();
                  }
                  
                  private static void ExecuteSqlTransaction(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
          
                          SqlCommand command = connection.CreateCommand();
                          SqlTransaction transaction;
          
                          // Start a local transaction.
                          transaction = connection.BeginTransaction();
          
                          // Must assign both transaction object and connection
                          // to Command object for a pending local transaction
                          command.Connection = connection;
                          command.Transaction = transaction;
          
                          try
                          {
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')";
                              command.ExecuteNonQuery();
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (101, 'Description')";
                              command.ExecuteNonQuery();
          
                              // Attempt to commit the transaction.
                              transaction.Commit();
                              Console.WriteLine("Both records are written to database.");
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine("Commit Exception Type: {0}", ex.GetType());
                              Console.WriteLine("  Message: {0}", ex.Message);
          
                              // Attempt to roll back the transaction.
                              try
                              {
                                  transaction.Rollback();
                              }
                              catch (Exception ex2)
                              {
                                  // This catch block will handle any errors that may have occurred
                                  // on the server that would cause the rollback to fail, such as
                                  // a closed connection.
                                  Console.WriteLine("Rollback Exception Type: {0}", ex2.GetType());
                                  Console.WriteLine("  Message: {0}", ex2.Message);
                              }
                          }
                      }
                  }
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlTransaction.Connection">
            <summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object associated with the transaction, or <see langword="null" /> if the transaction is no longer valid.
      </summary><value>
        The <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> object associated with the transaction.
      </value><remarks>
        A single application may have multiple database connections, each with zero or more transactions. This property lets you determine the connection object associated with a particular transaction created by <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlTransaction.DbConnection">
            <summary>
        To be added.
      </summary><value>
        To be added.
      </value><remarks>
        To be added.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlTransaction.IsolationLevel">
            <summary>
        Specifies the <see cref="T:System.Data.IsolationLevel" /> for this transaction.
      </summary><value>
        The <see cref="T:System.Data.IsolationLevel" /> for this transaction. The default is <see cref="F:System.Data.IsolationLevel.ReadCommitted" />.
      </value><remarks>
        <para>
          Parallel transactions are not supported. Therefore, the <see cref="T:System.Data.IsolationLevel" /> applies to the whole transaction.
        </para>
        <para>
          For more information on SQL Server isolation levels, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transaction-isolation-levels">Transaction Isolation Levels</see>.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlTransaction.Commit">
            <summary>
        Commits the database transaction.
      </summary><remarks>
        <para>
          The <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> method is equivalent to the Transact-SQL COMMIT TRANSACTION statement. You cannot roll back a transaction once it has been committed, because all modifications have become a permanent part of the database. For more information, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/commit-transaction-transact-sql">COMMIT TRANSACTION (Transact-SQL)</see>.
        </para>
        <note type="note">
          <c>Try</c> / <c>Catch</c> exception handling should always be used when committing or rolling back a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. Both <b>Commit</b> and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> generates an <see cref="T:System.InvalidOperationException" /> if the connection is terminated or if the transaction has already been rolled back on the server.
        </note>
        <para>
          For more information on SQL Server transactions, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transactions-transact-sql">Transactions (Transact-SQL)</see>. 
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. It also demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />, <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> methods. The transaction is rolled back on any error. <c>Try</c> / <c>Catch</c> error handling is used to handle any errors when attempting to commit or roll back the transaction.
        </para>
        <!-- SqlConnection_BeginTransaction -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace Transaction1CS
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString =
                          "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      ExecuteSqlTransaction(connectionString);
                      Console.ReadLine();
                  }
                  
                  private static void ExecuteSqlTransaction(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
          
                          SqlCommand command = connection.CreateCommand();
                          SqlTransaction transaction;
          
                          // Start a local transaction.
                          transaction = connection.BeginTransaction();
          
                          // Must assign both transaction object and connection
                          // to Command object for a pending local transaction
                          command.Connection = connection;
                          command.Transaction = transaction;
          
                          try
                          {
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')";
                              command.ExecuteNonQuery();
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (101, 'Description')";
                              command.ExecuteNonQuery();
          
                              // Attempt to commit the transaction.
                              transaction.Commit();
                              Console.WriteLine("Both records are written to database.");
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine("Commit Exception Type: {0}", ex.GetType());
                              Console.WriteLine("  Message: {0}", ex.Message);
          
                              // Attempt to roll back the transaction.
                              try
                              {
                                  transaction.Rollback();
                              }
                              catch (Exception ex2)
                              {
                                  // This catch block will handle any errors that may have occurred
                                  // on the server that would cause the rollback to fail, such as
                                  // a closed connection.
                                  Console.WriteLine("Rollback Exception Type: {0}", ex2.GetType());
                                  Console.WriteLine("  Message: {0}", ex2.Message);
                              }
                          }
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.Exception">
        An error occurred while trying to commit the transaction.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The transaction has already been committed or rolled back.</item>
          <item>The connection is broken.</item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlTransaction.Dispose(System.Boolean)">
            <param name="disposing">
        <see langword="true" /> to release managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.
      </param><summary>
        Releases the unmanaged resources used and optionally releases the managed resources.
      </summary><remarks>
        This method calls <see cref="M:System.Data.Common.DbTransaction.Dispose" />.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback">
            <summary>
        Rolls back a transaction from a pending state.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback(System.String)">
            <summary>
        Rolls back a transaction from a pending state.
      </summary><remarks>
        <para>
          The <b>Rollback</b> method is equivalent to the Transact-SQL ROLLBACK TRANSACTION statement. For more information, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/rollback-transaction-transact-sql">ROLLBACK TRANSACTION (Transact-SQL)</see>.
        </para>
        <para>
          The transaction can only be rolled back from a pending state (after <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> has been called, but before <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> is called). The transaction is rolled back in the event it is disposed before <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" /> or <b>Rollback</b> is called.
        </para>
        <note type="note">
          <c>Try</c> / <c>Catch</c> exception handling should always be used when rolling back a transaction. A <b>Rollback</b> generates an <see cref="T:System.InvalidOperationException" /> if the connection is terminated or if the transaction has already been rolled back on the server.
        </note>
        <para>
          For more information on SQL Server transactions, see <see href="https://learn.microsoft.com/sql/t-sql/language-elements/transactions-transact-sql">Transactions (Transact-SQL)</see>.
        </para>
      </remarks><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" />. It also demonstrates how to use the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" />, <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Commit" />, and <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> methods. The transaction is rolled back on any error. <c>Try</c> / <c>Catch</c> error handling is used to handle any errors when attempting to commit or roll back the transaction.
        </para>
        <!-- SqlConnection_BeginTransaction -->
        <code language="c#">
          using System;
          using System.Data;
          using Microsoft.Data.SqlClient;
          
          namespace Transaction1CS
          {
              class Program
              {
                  static void Main()
                  {
                      string connectionString =
                          "Persist Security Info=False;Integrated Security=SSPI;database=Northwind;server=(local)";
                      ExecuteSqlTransaction(connectionString);
                      Console.ReadLine();
                  }
                  
                  private static void ExecuteSqlTransaction(string connectionString)
                  {
                      using (SqlConnection connection = new SqlConnection(connectionString))
                      {
                          connection.Open();
          
                          SqlCommand command = connection.CreateCommand();
                          SqlTransaction transaction;
          
                          // Start a local transaction.
                          transaction = connection.BeginTransaction();
          
                          // Must assign both transaction object and connection
                          // to Command object for a pending local transaction
                          command.Connection = connection;
                          command.Transaction = transaction;
          
                          try
                          {
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')";
                              command.ExecuteNonQuery();
                              command.CommandText =
                                  "Insert into Region (RegionID, RegionDescription) VALUES (101, 'Description')";
                              command.ExecuteNonQuery();
          
                              // Attempt to commit the transaction.
                              transaction.Commit();
                              Console.WriteLine("Both records are written to database.");
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine("Commit Exception Type: {0}", ex.GetType());
                              Console.WriteLine("  Message: {0}", ex.Message);
          
                              // Attempt to roll back the transaction.
                              try
                              {
                                  transaction.Rollback();
                              }
                              catch (Exception ex2)
                              {
                                  // This catch block will handle any errors that may have occurred
                                  // on the server that would cause the rollback to fail, such as
                                  // a closed connection.
                                  Console.WriteLine("Rollback Exception Type: {0}", ex2.GetType());
                                  Console.WriteLine("  Message: {0}", ex2.Message);
                              }
                          }
                      }
                  }
              }
          }
        </code>
      </example><exception cref="T:System.Exception">
        An error occurred while trying to commit the transaction.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The transaction has already been committed or rolled back.</item>
          <item>The connection is broken.</item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlTransaction.Save(System.String)">
            <param name="savePointName">
        The name of the savepoint.
      </param><summary>
        Creates a savepoint in the transaction that can be used to roll back a part of the transaction, and specifies the savepoint name.
      </summary><remarks>
        <para>
          The <b>Save</b> method is equivalent to the Transact-SQL SAVE TRANSACTION statement.
        </para>
        <para>
          The value used in the <paramref name="savePointName" /> parameter can be the same value used in the <c>transactionName</c> parameter of some implementations of the <see cref="M:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction" /> method.
        </para>
        <para>
          Savepoints offer a mechanism to roll back parts of transactions. You create a savepoint using the <b>Save</b> method, and then later call the <see cref="M:Microsoft.Data.SqlClient.SqlTransaction.Rollback" /> method to roll back to the savepoint instead of rolling back to the start of the transaction.
        </para>
      </remarks><exception cref="T:System.Exception">
        An error occurred while trying to commit the transaction.
      </exception><exception cref="T:System.InvalidOperationException">
        <list type="bullet">
          <item>The transaction has already been committed or rolled back.</item>
          <item>The connection is broken.</item>
        </list>
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRetryingEventArgs">
            <summary>
        Represents the set of arguments passed to the <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Retrying" /> event.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryingEventArgs.#ctor(System.Int32,System.TimeSpan,System.Collections.Generic.IList{System.Exception})">
            <param name="retryCount">
        The current retry attempt count.
      </param><param name="delay">
        The delay that indicates how long the current thread will be suspended before the next iteration is invoked.
      </param><param name="exceptions">
        The list of exceptions since the first retry that caused the retry logic to re-execute the function.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlRetryingEventArgs" /> class.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryingEventArgs.RetryCount">
            <summary>
        Retry-attempt-number, after the first exception occurrence.
      </summary><value>
        <see cref="T:System.Int32" /> that returns the number of retry execution attempts; starting from 1.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryingEventArgs.Delay">
            <summary>
        Gets the current waiting time as a <see cref="T:System.TimeSpan" /> object.
      </summary><value> <see cref="T:System.TimeSpan" /> The upcoming gap time before the next execution attempt.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryingEventArgs.Cancel">
            <summary>
        Gets or sets a value that indicates whether the retry logic should be canceled.
      </summary><value>
        If set to <see langword="true" />, the execution attempt will be interrupted immediately.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryingEventArgs.Exceptions">
            <summary>
        Gets the list of exceptions since the first attempt failure.
      </summary><value>
        List of occurred exceptions.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator">
            <summary>
        Generates a sequence of time intervals.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.GapTimeInterval">
            <summary>
        The default gap time of each interval.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.MaxTimeInterval">
            <summary>
        The maximum allowed time interval value.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.MinTimeInterval">
            <summary>
        The minimum allowed time interval value.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.Current">
            <summary>
        Gets the element in the collection at the current position of the enumerator.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.#ctor">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator" /> class with a default value of zero for the gap time, minimum, and maximum interval time.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.#ctor(System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <param name="timeInterval">
        The gap time used to calculate the time delay before each attempt.
      </param><param name="maxTime">
        The maximum time allowed as a gap time.
      </param><param name="minTime">
        The minimum time allowed as a gap time.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator" /> class.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The supplied arguments failed <see cref="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.Validate(System.TimeSpan,System.TimeSpan,System.TimeSpan)" /> validation.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.Reset">
            <summary>
        Sets the enumerator to its initial position, which is before the first element in the collection.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.Validate(System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <param name="timeInterval">
        The gap time of each interval. Must be between 0 and 120 seconds.
      </param><param name="maxTimeInterval">
        Maximum time interval value. Must be between 0 and 120 seconds.
      </param><param name="minTimeInterval">
        Minimum time interval value. Must be less than maximum time interval and between 0 and 120 seconds.
      </param><summary>
        Validate the enumeration parameters.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The supplied arguments failed validation.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.GetNextInterval">
            <summary>
        Calculates the next interval time.
      </summary><returns>
        Returns the next gap time interval.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.MoveNext">
            <summary>
        Advances the enumerator to the next element of the collection.
      </summary><returns>
        Returns <see langword="true" />, if the enumerator was successfully advanced to the next element; <see langword="false" /> if the enumerator has passed the end of the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.Dispose">
            <summary>
        Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator.Clone">
            <summary>
        Creates a new object that is a copy of the current instance.
      </summary><returns>
        A new object that is a copy of this instance.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRetryLogicBase">
            <summary>
        Retrieves the next time interval with respect to the number of retries if a transient condition occurs.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicBase.NumberOfTries">
            <summary>
        Maximum number of retries.
      </summary><value>
        <see langword="int" /> that returns the maximum number of retry execution attempts that will be attempted after the first failure.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicBase.Current">
            <summary>
        Current retry number starting from zero.
      </summary><value>
        <see langword="int" /> that returns the number of retry execution attempts after the first failure.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicBase.RetryIntervalEnumerator">
            <summary>
        The timer interval enumerator.
      </summary><value>
        <see cref="T:Microsoft.Data.SqlClient.SqlRetryIntervalBaseEnumerator" /> value that indicates an enumerator to generate a sequence of time intervals.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicBase.TransientPredicate">
            <summary>
        Delegate to a transient condition predicate. The function that this delegate points to must return a true value when an expected transient exception happens.
      </summary><value>
        <see cref="T:System.Predicate`1" /> value that delegates to a function that receives a <see cref="T:System.Exception" /> input parameter.
      </value>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryLogicBase.RetryCondition(System.Object)">
            <param name="sender">
        The sender object.
      </param><summary>
        Pre-retry validation for the sender state.
      </summary><returns>
        Returns <see langword="true" /> if the sender is authorized to retry the operation.
      </returns><remarks>
        <note type="important">
          Operations that are part of a <b>Transaction</b> are not safe to retry without specific knowledge of business logic. Due to this complexity, retry logic should be managed at the application level.
        </note>
        <note type="note">
          The <b>RetryCondition</b> is an extra condition that checks before executing the <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicBase.TransientPredicate" /> and the default condition always returns <see langword="true" />.
        </note>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryLogicBase.TryNextInterval(System.TimeSpan@)">
            <param name="intervalTime">
        The interval time that is generated by the <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicBase.RetryIntervalEnumerator" />.
      </param><summary>
        Try to get the next interval time by using the enumerator if the counter does not exceed the number of retries.
      </summary><returns>
        Returns <see langword="true" /> if the number of retry attempts has not been exceeded; otherwise <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryLogicBase.Reset">
            <summary>
        Set the counters and enumerator to default values for next use.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryLogicBase.Clone">
            <summary>
        Creates a new object that is a copy of the current instance.
      </summary><returns>
        When implemented in a derived class, the method is expected to return a new object of the current instance. The default implementation throws <see cref="T:System.NotImplementedException" />.
      </returns><exception cref="T:System.NotImplementedException">
        In all cases.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider">
            <summary>
        Applies retry logic on an operation through the <see cref="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Execute{TResult}(System.Object,System.Func{TResult})" /> or <see cref="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Execute{TResult}(System.Object,System.Func{System.Threading.Task{TResult}},System.Threading.CancellationToken)" /> function.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Retrying">
            <summary>
        Occurs before applying the calculated delay time and executing the function on a next attempt.
      </summary><value>
        <see cref="T:System.EventHandler" /> with event argument of <see cref="T:Microsoft.Data.SqlClient.SqlRetryingEventArgs" /> object can be subscribed.
      </value><remarks>
        <note type="important">
          Don't block execution with a time-consuming action when an event occurs. For instance, if you log data to a file, run it in a new thread to avoid blocking the main execution thread.
        </note>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.RetryLogic">
            <summary>
        Defines the retry logic used to decide when to retry based on the encountered exception.
      </summary><remarks>
        <note type="note">
          The <b>RetryLogic</b> property is assigned at construction of the <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> creation and its value is used as a template internally. Don't use it to monitor the status of the retry logic during and after execution. Instead, use the <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Retrying" /> event to collect data about retry executions.
        </note>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.Execute``1(System.Object,System.Func{``0})">
            <typeparam name="TResult">
        The object that the `function` returns when executed.
      </typeparam><param name="sender">
        The source of the event.
      </param><param name="function">
        The operation to re-execute if a transient condition occurs.
      </param><summary>
        <para>
          Executes a function and applies retry logic, if enabled.
        </para>
        <note type="note">
          Exceptions will be reported via an aggregate exception if the execution isn't successful via retry attempts.
        </note>
      </summary><returns>
        The return value of the <paramref name="function" /> if it runs without exception.
      </returns><remarks>
        <para>
          <note type="note">
            The type of exception depends on the <paramref name="function" />'s internal implementation. But if the exception is due to all retry attempts failing, it will be an <see cref="T:System.AggregateException" /> that consists of all exceptions that happened during the failed attempts.
          </note>
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="function" /> parameter can't be <see langword="null" />.
      </exception><exception cref="T:System.AggregateException">
        The collection of exceptions after all retry attempts have failed.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.ExecuteAsync``1(System.Object,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <typeparam name="TResult">
        The object that the <paramref name="function" /> returns in a Task when executed.
      </typeparam><param name="sender">
        The source of the event.
      </param><param name="function">
        The operation to re-execute if a transient condition occurs.
      </param><param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        <para>
          Executes a function and applies retry logic, if enabled. The cancellation token can be used to request that the operation be abandoned before the execution attempts are exceeded.
        </para>
        <note type="note">
          Exceptions will be reported via the returned Task object, which will contain an aggregate exception if execution fails for all retry attempts.
        </note>
      </summary><returns>
        A task representing the asynchronous operation. The results of the task will be the return value of the <paramref name="function" />, if it runs without exception.
      </returns><remarks>
        <note type="note">
          If the exception comes from all retry attempts failing, it will be an <see cref="T:System.AggregateException" /> that consists of all exceptions from the failed attempts.
        </note>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="function" /> parameter can't be <see langword="null" />.
      </exception><exception cref="T:System.AggregateException">
        The collection of exceptions after failed retry attempts.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider.ExecuteAsync(System.Object,System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <param name="sender">
        The source of the event.
      </param><param name="function">
        The operation to re-execute if a transient condition occurs.
      </param><param name="cancellationToken">
        The cancellation instruction.
      </param><summary>
        <para>
          Executes a function and applies retry logic, if enabled. The cancellation token can be used to request that the operation be abandoned before the execution attempts are exceeded.
        </para>
        <note type="note">
          Exceptions will be reported via the returned Task object, which will contain an aggregate exception if execution fails for all retry attempts.
        </note>
      </summary><returns>
        A Task or an exception.
      </returns><remarks>
        <note type="note">
          If the exception comes from all retry attempts failing, it will be an <see cref="T:System.AggregateException" /> that consists of all exceptions from the failed attempts.
        </note>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="function" /> parameter can't be <see langword="null" />.
      </exception><exception cref="T:System.AggregateException">
        The collection of exceptions after failed retry attempts.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlRetryLogicOption">
            <summary>
        Provides the retry logic parameters to create an instance of the <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> class by using <see cref="T:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory" /> methods.
      </summary><example>
        <para>
          The following sample declares a <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicOption" /> object that is configured to apply retry logic for the error number <c>102</c> for a maximum of <c>5</c> times and <c>3</c> to <c>60</c> seconds gap time between each run. It will only work for the SELECT SQL statements assigned to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.RetryLogicProvider" />.
        </para>
        <!-- SqlConfigurableRetryLogic_SqlRetryLogicOptions -->
        <code language="c#">
          using System;
          using System.Text.RegularExpressions;
          using Microsoft.Data.SqlClient;
          
          class RetryLogicSample
          {
              static void Main(string[] args)
              {
                  var RetryLogicOption = new SqlRetryLogicOption()
                  {
                      NumberOfTries = 5,
                      // Declare the error number 102 as a transient error to apply the retry logic when it occurs.
                      TransientErrors = new int[] { 102 },
                      // When a SqlCommand executes out of a transaction, 
                      // the retry logic will apply if it contains a 'select' keyword.
                      AuthorizedSqlCondition = x =&gt; string.IsNullOrEmpty(x)
                              || Regex.IsMatch(x, @"\b(SELECT)\b", RegexOptions.IgnoreCase),
                      DeltaTime = TimeSpan.FromSeconds(1),
                      MaxTimeInterval = TimeSpan.FromSeconds(60),
                      MinTimeInterval = TimeSpan.FromSeconds(3)
                  };
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.NumberOfTries">
            <summary>
        Sets the number of times to try and execute the function.
      </summary><value>
        <see langword="int" /> between 1 and 60; 1 means to execute one time and if an error is encountered, don't retry.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.DeltaTime">
            <summary>
        Sets the gap time interval as a <see cref="T:System.TimeSpan" /> object.
      </summary><value>
        <see cref="T:System.TimeSpan" /> The upcoming gap time before the next execution attempt; must be between 0 and 120 seconds.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MinTimeInterval">
            <summary>
        Sets the minimum allowed gap time interval as a <see cref="T:System.TimeSpan" /> object.
      </summary><value>
        <see cref="T:System.TimeSpan" /> The minimum upcoming gap time before the next execution attempt; the default value is <b>zero</b> and must be between 0 and 120 seconds.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MaxTimeInterval">
            <summary>
        Sets the allowed maximum gap time interval as a <see cref="T:System.TimeSpan" /> object.
      </summary><value>
        <see cref="T:System.TimeSpan" /> The maximum upcoming gap time interval before the next execution attempt; must be between 0 and 120 seconds.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.TransientErrors">
            <summary>
        Sets the list of transient error numbers on which to retry when they occur.
      </summary><value>
        List of <see cref="P:Microsoft.Data.SqlClient.SqlException.Number" />; Set to <see langword="null" /> to use the internal list of exceptions from the <see cref="T:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory" /> object.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.AuthorizedSqlCondition">
            <summary>
        Sets a pre-retry validation function on the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> to only include specific SQL statements.
      </summary><value>
        <see cref="T:System.Predicate`1" /> The pre-retry validation delegate function; <see langword="true" /> if the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.CommandText" /> is authorized to retry the operation.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory">
            <summary>
        Provides different retry logic providers with a common list of transient errors.
      </summary><remarks>
        <para>
          The following table shows the inner transient error list.
        </para>
        <list type="table">
          <listheader>
            <term>Error Number</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>1204</term>
            <description>
              The instance of the SQL Server Database Engine cannot obtain a LOCK resource at this time. Rerun your statement when there are fewer active users. Ask the database administrator to check the lock and memory configuration for this instance, or to check for long-running transactions.
            </description>
          </item>
          <item>
            <term>1205</term>
            <description>
              Transaction (Process ID) was deadlocked on resources with another process and has been chosen as the deadlock victim. Rerun the transaction.
            </description>
          </item>
          <item>
            <term>1222</term>
            <description>Lock request time out period exceeded.</description>
          </item>
          <item>
            <term>49918</term>
            <description>Cannot process request. Not enough resources to process request.</description>
          </item>
          <item>
            <term>49919</term>
            <description>
              Cannot process create or update request. Too many create or update operations in progress for subscription "%ld".
            </description>
          </item>
          <item>
            <term>49920</term>
            <description>Cannot process request. Too many operations in progress for subscription "%ld".</description>
          </item>
          <item>
            <term>4060</term>
            <description>Cannot open database "%.*ls" requested by the login. The login failed.</description>
          </item>
          <item>
            <term>4221</term>
            <description>
              Login to read-secondary failed due to long wait on 'HADR_DATABASE_WAIT_FOR_TRANSITION_TO_VERSIONING'. The replica is not available for login because row versions are missing for transactions that were in-flight when the replica was recycled. The issue can be resolved by rolling back or committing the active transactions on the primary replica. Occurrences of this condition can be minimized by avoiding long write transactions on the primary.
            </description>
          </item>
          <item>
            <term>40143</term>
            <description>The service has encountered an error processing your request. Please try again.</description>
          </item>
          <item>
            <term>40613</term>
            <description>
              Database '%.*ls' on server '%.*ls' is not currently available. Please retry the connection later. If the problem persists, contact customer support, and provide them the session tracing ID of '%.*ls'.
            </description>
          </item>
          <item>
            <term>40501</term>
            <description>The service is currently busy. Retry the request after 10 seconds. Incident ID: %ls. Code: %d.</description>
          </item>
          <item>
            <term>40540</term>
            <description>The service has encountered an error processing your request. Please try again.</description>
          </item>
          <item>
            <term>40197</term>
            <description>The service has encountered an error processing your request. Please try again. Error code %d.</description>
          </item>
          <item>
            <term>10929</term>
            <description>
              Resource ID: %d. The %s minimum guarantee is %d, maximum limit is %d and the current usage for the database is %d. However, the server is currently too busy to support requests greater than %d for this database. For more information, see https://learn.microsoft.com/azure/azure-sql/database/resource-limits-logical-server. Otherwise, please try again later.
            </description>
          </item>
          <item>
            <term>10928</term>
            <description>
              Resource ID: %d. The %s limit for the database is %d and has been reached. For more information, see https://learn.microsoft.com/azure/azure-sql/database/resource-limits-logical-server.
            </description>
          </item>
          <item>
            <term>10060</term>
            <description>
              An error has occurred while establishing a connection to the server. When connecting to SQL Server, this failure may be caused by the fact that under the default settings SQL Server does not allow remote connections. (provider: TCP Provider, error: 0 - A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.) (Microsoft SQL Server, Error: 10060)
            </description>
          </item>
          <item>
            <term>10054</term>
            <description>The data value for one or more columns overflowed the type used by the provider.</description>
          </item>
          <item>
            <term>10053</term>
            <description>Could not convert the data value due to reasons other than sign mismatch or overflow.</description>
          </item>
          <item>
            <term>997</term>
            <description>
              A connection was successfully established with the server, but then an error occurred during the login process. (provider: Named Pipes Provider, error: 0 - Overlapped I/O operation is in progress)
            </description>
          </item>
          <item>
            <term>233</term>
            <description>
              A connection was successfully established with the server, but then an error occurred during the login process. (provider: Shared Memory Provider, error: 0 - No process is on the other end of the pipe.) (Microsoft SQL Server, Error: 233)
            </description>
          </item>
        </list>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateExponentialRetryProvider(Microsoft.Data.SqlClient.SqlRetryLogicOption)">
            <param name="retryLogicOption">
        An object of <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicOption" /> containing the configuration for the object.
      </param><summary>
        Provides an exponential time interval retry logic provider.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object.
      </returns><remarks>
        <note type="note">
          The inner enumerator includes randomization to prevent multiple instances of the client from performing subsequent retry attempts at the same time.
        </note>
      </remarks><exception cref="T:System.ArgumentNullException">
        If the <paramref name="retryLogicOption" /> parameter was null.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        If at least one of the following conditions occurs:
        <list type="bullet">
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.NumberOfTries" /> is less than 1 or bigger than 60.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.DeltaTime" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MinTimeInterval" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MaxTimeInterval" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MinTimeInterval" /> is not less than <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MaxTimeInterval" />.
          </item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateIncrementalRetryProvider(Microsoft.Data.SqlClient.SqlRetryLogicOption)">
            <param name="retryLogicOption">
        An object of <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicOption" /> containing the configuration for the object.
      </param><summary>
        Provides an incremental time interval retry logic provider.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object.
      </returns><remarks>
        <note type="note">
          The inner enumerator includes randomization to prevent multiple instances of the client from performing subsequent retry attempts at the same time.
        </note>
      </remarks><exception cref="T:System.ArgumentNullException">
        If the <paramref name="retryLogicOption" /> parameter was null.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        If at least one of the following conditions occurs:
        <list type="bullet">
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.NumberOfTries" /> is less than 1 or bigger than 60.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.DeltaTime" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MinTimeInterval" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MaxTimeInterval" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MinTimeInterval" /> is not less than <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MaxTimeInterval" />.
          </item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateFixedRetryProvider(Microsoft.Data.SqlClient.SqlRetryLogicOption)">
            <param name="retryLogicOption">
        An object of <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicOption" /> containing the configuration for the object.
      </param><summary>
        Provides a fixed interval time retry logic provider.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object.
      </returns><remarks>
        <note type="note">
          The inner enumerator includes randomization to prevent multiple instances of the client from performing subsequent retry attempts at the same time.
        </note>
      </remarks><exception cref="T:System.ArgumentNullException">
        If the `retryLogicOption` parameter was null.
      </exception><exception cref="T:System.ArgumentOutOfRangeException">
        If at least one of the following conditions occurs:
        <list type="bullet">
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.NumberOfTries" /> is less than 1 or bigger than 60.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.DeltaTime" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MinTimeInterval" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MaxTimeInterval" /> is bigger than 120 seconds.
          </item>
          <item>
            <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MinTimeInterval" /> is not less than <see cref="P:Microsoft.Data.SqlClient.SqlRetryLogicOption.MaxTimeInterval" />.
          </item>
        </list>
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlConfigurableRetryFactory.CreateNoneRetryProvider">
            <summary>
        Provides a non-retryable provider with a <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBase.TransientPredicate" /> that returns <see langword="false" />.
      </summary><returns>
        A <see cref="T:Microsoft.Data.SqlClient.SqlRetryLogicBaseProvider" /> object.
      </returns><remarks>
        <note type="note">
          The returned provider of this function performs a single execution without any retry logic.
        </note>
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore">
            <summary>
        Contains diagnostic information emitted before a command is executed.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.Name">
            <summary>
        Contains diagnostic information emitted before a command is executed.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.ConnectionId">
            <summary>
        A nullable guid uniquely identifying the connection that the command is being executed on.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction that the command enrolled in if it is enrolled in one.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.Command">
            <summary>
        The command object that is executing.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.Item(System.Int32)">
            <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandBefore.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter">
            <summary>
        Contains diagnostic information emitted after a command is successfully executed.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.ConnectionId">
            <summary>
        A nullable guid uniquely identifying the connection that the command is being executed on.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction that the command is enrolled in if it is enrolled in one, or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.Command">
            <summary>
        The command object that is executing.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.Statistics">
            <summary>
        An IDictionary of statistic information about the event that has completed.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.Item(System.Int32)">
            <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandAfter.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError">
            <summary>
        Contains diagnostic information emitted after a command execution fails with an exception.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.Name">
            <summary>
        Contains diagnostic information emitted after a command execution fails with an exception.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.ConnectionId">
            <summary>
        A nullable guid uniquely identifying the connection that the command is being executed on.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction that the command is enrolled in if it is enrolled in one, or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.Command">
            <summary>
        The command object that is executing.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.Exception">
            <summary>
        The exception object that caused the command execution to fail.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientCommandError.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore">
            <summary>
        Contains diagnostic information emitted before a connection is opened.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.Connection">
            <summary>
        The connection object that is being opened.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.ClientVersion">
            <summary>
        The version of the SqlClient library.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenBefore.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter">
            <summary>
        Contains diagnostic information emitted after a connection has been successfully opened.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.ConnectionId">
            <summary>
        The unique guid assigned to the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.Connection">
            <summary>
        The connection object that has been opened.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.ClientVersion">
            <summary>
        The version of the SqlClient library.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.Statistics">
            <summary>
        An IDictionary of statistic information about the event that has completed.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenAfter.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError">
            <summary>
        Contains diagnostic information emitted after a connection open fails with an exception.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.ConnectionId">
            <summary>
        The unique guid assigned to the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.Connection">
            <summary>
        The connection object that has been opened.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.ClientVersion">
            <summary>
        The version of the SqlClient library.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.Exception">
            <summary>
        The exception object that caused the command execution to fail.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionOpenError.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore">
            <summary>
        Contains diagnostic information emitted before a connection is closed.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.Name">
            <SqlClientConnectionCloseBefore>
      <summary>
        Contains diagnostic information emitted before a connection is closed.
      </summary>
    </SqlClientConnectionCloseBefore><summary>
        Contains diagnostic information emitted before a connection is closed.
      </summary><Name>
      <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
    </Name><summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary><Connection>
      <summary>
        The connection object that is being closed.
      </summary>
    </Connection><summary>
        The connection object that is being closed.
      </summary><ConnectionId>
      <summary>
        The unique guid assigned to the connection.
      </summary>
    </ConnectionId><summary>
        The unique guid assigned to the connection.
      </summary><Statistics>
      <summary>
        An IDictionary of statistic information about the connection.
      </summary>
    </Statistics><summary>
        An IDictionary of statistic information about the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.ConnectionId">
            <summary>
        The unique guid assigned to the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.Connection">
            <summary>
        The connection object that is being closed.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.Statistics">
            <summary>
        An IDictionary of statistic information about the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseBefore.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter">
            <summary>
        Contains diagnostic information emitted after a connection has been successfully closed.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.ConnectionId">
            <summary>
        The unique guid assigned to the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.Connection">
            <summary>
        The connection object that has been closed.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.Statistics">
            <summary>
        An IDictionary of statistic information about the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseAfter.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError">
            <summary>
        Contains diagnostic information emitted after a connection close fails with an exception.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.ConnectionId">
            <summary>
        The unique guid assigned to the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Connection">
            <summary>
        The connection object that has been closed.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Statistics">
            <summary>
        An IDictionary of statistic information about the connection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Exception">
            <summary>
        The exception object that caused the command execution to fail.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientConnectionCloseError.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore">
            <summary>
        Contains diagnostic information emitted before a transaction is opened.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.IsolationLevel">
            <summary>
        The IsolationLevel of the transaction.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.Connection">
            <summary>
        The connection object that the transaction belongs to.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction that the command is enrolled in if it is enrolled in one, or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitBefore.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter">
            <summary>
        Contains diagnostic information emitted after a transaction is successfully committed.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.IsolationLevel">
            <summary>
        The IsolationLevel of the transaction.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.Connection">
            <summary>
        The connection object that the transaction belongs to.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction that the command is enrolled in if it is enrolled in one, or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitAfter.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError">
            <summary>
        Contains diagnostic information emitted after a transaction commit fails with an exception.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.IsolationLevel">
            <summary>
        The IsolationLevel of the transaction.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.Connection">
            <summary>
        The connection object that the transaction belongs to.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction that the command is enrolled in if it is enrolled in one, or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.Exception">
            <summary>
        The exception object that caused the command execution to fail.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionCommitError.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore">
            <summary>
        Contains diagnostic information emitted before a transaction rollback is rolled back.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.Name">
            <summary>
        Contains diagnostic information emitted before a transaction rollback is rolled back.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.IsolationLevel">
            <summary>
        The IsolationLevel of the transaction.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.Connection">
            <summary>
        The connection object that the transaction belongs to.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction that the command is enrolled in if it is enrolled in one, or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.TransactionName">
            <summary>
        The name of the transaction which is being rolled back.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackBefore.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter">
            <summary>
        Contains diagnostic information emitted after a transaction is rolled back successfully.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.IsolationLevel">
            <summary>
        The IsolationLevel of the transaction.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.Connection">
            <summary>
        The connection object that the transaction belongs to.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction, or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.TransactionName">
            <summary>
        The name of the transaction which is being rolled back.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackAfter.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError">
            <summary>
        Contains diagnostic information emitted after a transaction roll back fails with an exception.
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.Name">
            <summary>
        The name of the event that needs to be enabled for the event to be raised.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.OperationId">
            <summary>
        A guid value used to correlate before, after and error events.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.Operation">
            <summary>
        The name of the operation.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.Timestamp">
            <summary>
        The timestamp of the event.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.IsolationLevel">
            <summary>
        The IsolationLevel of the transaction.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.Connection">
            <summary>
        The connection object that the transaction belongs to.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.TransactionId">
            <summary>
        A nullable long uniquely identifying the transaction , or null.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.TransactionName">
            <summary>
        The name of the transaction which is being rolled back.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.Exception">
            <summary>
        The exception object that caused the command execution to fail.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.Count">
            <summary>
        Gets the number of elements in the collection.
      </summary><returns>
        The number of elements in the collection.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.Item(System.Int32)">
            <inheritdoc />&gt;/// <summary>
        Gets the element at the specified index in the read-only list.
      </summary><param name="index">
        The zero-based index of the element to get.
      </param><returns>
        The element at the specified index in the read-only list.
      </returns><exception cref="T:System.IndexOutOfRangeException" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.System#Collections#IEnumerable#GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Diagnostics.SqlClientTransactionRollbackError.GetEnumerator">
            <summary>
        Returns an enumerator that iterates through the collection.
      </summary><returns>
        An enumerator that can be used to iterate through the collection.
      </returns>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Server.SqlDataRecord">
            <summary>
        Represents a single row of data and its metadata.
      </summary><remarks>
        <para>
          This class is used together with <see cref="T:Microsoft.SqlServer.Server.SqlPipe" /> to send result sets to the client from managed code stored-procedures.
        </para>
        <para>
          When writing common language runtime (CLR) applications, you should re-use existing <b>SqlDataRecord</b> objects instead of creating new ones every time. Creating many new <b>SqlDataRecord</b> objects could severely deplete memory and adversely affect performance.
        </para>
      </remarks><example>
        <para>
          The following example shows how to create several <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> objects, which describe the column metadata of a record, and creating a <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" />. The column values of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> are set and the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> is sent to the calling program by using the <see cref="T:Microsoft.SqlServer.Server.SqlContext" /> class.
        </para>
        <!-- SqlDataRecord #1 -->
        <code language="c#">
          using Microsoft.Data.SqlClient.Server;
          
          [Microsoft.Data.SqlClient.Server.SqlProcedure]
          public static void CreateNewRecord()
          {
          
             // Variables.
             SqlDataRecord record;    
                
             // Create a new record with the column metadata. The constructor is 
             // able to accept a variable number of parameters. 
             record = new SqlDataRecord(new SqlMetaData[] { new SqlMetaData("Column1", SqlDbType.NVarChar, 12), 
                                                            new SqlMetaData("Column2", SqlDbType.Int), 
                                                            new SqlMetaData("Column3", SqlDbType.DateTime) });
          
             // Set the record fields.
             record.SetString(0, "Hello World!");
             record.SetInt32(1, 42);
             record.SetDateTime(2, DateTime.Now);
          
             // Send the record to the calling program.
             SqlContext.Pipe.Send(record);
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.#ctor(Microsoft.Data.SqlClient.Server.SqlMetaData[])">
            <param name="metaData">
        An array of <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> objects that describe each column in the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" />.
      </param><summary>
        Initializes a new <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> instance with the schema based on the array of <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> objects passed as an argument.
      </summary><example>
        <para>
          The following example shows how to create a new <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> object from two <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> objects, which indicate the column name and data type.
        </para>
        <!-- SqlDataRecord #2 -->
        <code language="c#">
          using Microsoft.Data.SqlClient.Server;
          
          // Variables.
          SqlMetaData column1Info;
          SqlMetaData column2Info;
          SqlDataRecord record;
          
          // Create the column metadata.
          column1Info = new SqlMetaData("Column1", SqlDbType.NVarChar, 12);
          column2Info = new SqlMetaData("Column2", SqlDbType.Int);
          
          // Create a new record with the column metadata.      
          record = new SqlDataRecord(new SqlMetaData[] { column1Info, column2Info });

          
          // Set the record fields.
          record.SetString(0, "Hello World!");
          record.SetInt32(1, 42);
          
          // Send the record to the calling program.
          SqlContext.Pipe.Send(record);
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        The <paramref name="metaData" /> is <see langword="null" />.
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount">
            <summary>
        Gets the number of columns in the data row. This property is read-only.
      </summary><value>
        The number of columns in the data row as an integer.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.Item(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the common language runtime (CLR) type value for the column specified by the column <paramref name="ordinal" /> argument.
      </summary><value>
        The CLR type value of the column specified by the <paramref name="ordinal" />.
      </value><remarks>
        For columns with null value, <see cref="P:System.DBNull.Value" /> is returned.
      </remarks><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.Item(System.String)">
            <param name="name">
        The name of the column.
      </param><summary>
        Gets the common language runtime (CLR) type value for the column specified by the column <paramref name="name" /> argument.
      </summary><value>
        The CLR type value of the column specified by the <paramref name="name" />.
      </value><remarks>
        For columns with null value, <see cref="P:System.DBNull.Value" /> is returned.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetBoolean(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Boolean" />.
      </summary><returns>
        The column value as a <see cref="T:System.Boolean" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is null.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetByte(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Byte" />.
      </summary><returns>
        The column value as a <see cref="T:System.Byte" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is null.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="fieldOffset">
        The offset into the field value to start retrieving bytes.
      </param><param name="buffer">
        The target buffer to which to copy bytes.
      </param><param name="bufferOffset">
        The offset into the buffer to which to start copying bytes.
      </param><param name="length">
        The number of bytes to copy to the buffer.
      </param><summary>
        Gets the value for the column specified by the ordinal as an array of <see cref="T:System.Byte" /> objects.
      </summary><returns>
        The number of bytes copied.
      </returns><remarks>
        <para>
          This method enables you to obtain a binary value either in a single call or in chunks. Getting the value in chunks is useful for large values or values of unknown size.
        </para>
        <para>
          To obtain the value in several chunks, allocate a byte array of the chunk-size and call <b>GetBytes</b> repeatedly, adjusting the <paramref name="fieldOffset" /> parameter accordingly in each call.
        </para>
      </remarks><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetChar(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Char" />.
      </summary><returns>
        The column value as a <see cref="T:System.Char" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="fieldOffset">
        The offset into the field value to start retrieving characters.
      </param><param name="buffer">
        The target buffer to copy chars to.
      </param><param name="bufferOffset">
        The offset into the buffer to start copying chars to.
      </param><param name="length">
        The number of chars to copy to the buffer.
      </param><summary>
        Gets the value for the column specified by the ordinal as an array of <see cref="T:System.Char" /> objects.
      </summary><returns>
        The number of characters copied.
      </returns><remarks>
        <para>
          This method enables you to obtain a character value either in a single call or in chunks. Getting the value in chunks is useful for large values or values of unknown size.
        </para>
        <para>
          To obtain the value in several chunks, allocate a char array of the chunk-size and call <b>GetChars</b> repeatedly adjusting the <paramref name="fieldOffset" /> parameter accordingly in each call.
        </para>
      </remarks><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is null.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.System#Data#IDataRecord#GetData(System.Int32)">
            <param name="ordinal">
        To be added.
      </param><summary>
        To be added.
      </summary><returns>
        To be added.
      </returns><remarks>
        To be added.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetDataTypeName(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns the name of the data type for the column specified by the ordinal argument.
      </summary><returns>
        A <see cref="T:System.String" /> that contains the data type of the column.
      </returns><remarks>
        This method returns the type name as known in the SQL Server type-system. For user-defined types (UDTs), it returns the three-part name that was used to register the type with SQL Server.
      </remarks><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetDateTime(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.DateTime" />.
      </summary><returns>
        The column value as a <see cref="T:System.DateTime" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetDateTimeOffset(System.Int32)">
            <param name="ordinal">
        The zero-based column ordinal.
      </param><summary>
        Returns the specified column's data as a <see cref="T:System.DateTimeOffset" />.
      </summary><returns>
        The value of the specified column as a <see cref="T:System.DateTimeOffset" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetDecimal(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Decimal" />.
      </summary><returns>
        The column value as a <see cref="T:System.Decimal" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetDouble(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Double" />.
      </summary><returns>
        The column value as a <see cref="T:System.Double" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetFieldType(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns a <see cref="T:System.Type" /> object representing the common language runtime (CLR) type that maps to the SQL Server type of the column specified by the <paramref name="ordinal" /> argument.
      </summary><returns>
        The column type as a <see cref="T:System.Type" /> object.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.TypeLoadException">
        The column is of a user-defined type that is not available to the calling application domain.
      </exception><exception cref="T:System.IO.FileNotFoundException">
        The column is of a user-defined type that is not available to the calling application domain.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetFloat(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Single" />.
      </summary><returns>
        The column value as a <see cref="T:System.Single" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetGuid(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Guid" />.
      </summary><returns>
        The column value as a <see cref="T:System.Guid" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetInt16(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Int16" />.
      </summary><returns>
        The column value as a <see cref="T:System.Int16" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetInt32(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Int32" />.
      </summary><returns>
        The column value as a <see cref="T:System.Int32" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetInt64(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Int64" />.
      </summary><returns>
        The column value as a <see cref="T:System.Int64" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">
        The column specified by <paramref name="ordinal" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetName(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns the name of the column specified by the ordinal argument.
      </summary><returns>
        A <see cref="T:System.String" /> containing the column name.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetOrdinal(System.String)">
            <param name="name">
        The name of the column to look up.
      </param><summary>
        Returns the column ordinal specified by the column name.
      </summary><returns>
        The zero-based ordinal of the column as an integer.
      </returns><exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> is <see langword="null" />.
      </exception><exception cref="T:System.IndexOutOfRangeException">
        The column name could not be found.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlBinary(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlBinary" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlBinary" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlBoolean(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlByte(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlByte" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlByte" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlBytes(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlBytes" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlBytes" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlChars(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlChars" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlChars" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlDateTime(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlDecimal(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlDouble(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlDouble" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlDouble" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlFieldType(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns a <see cref="T:System.Type" /> object that represents the type (as a SQL Server type, defined in <see cref="N:System.Data.SqlTypes" />) that maps to the SQL Server type of the column.
      </summary><returns>
        The column type as a <see cref="T:System.Type" /> object.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.TypeLoadException">
        The column is of a user-defined type that is not available to the calling application domain.
      </exception><exception cref="T:System.IO.FileNotFoundException">
        The column is of a user-defined type that is not available to the calling application domain.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlGuid(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlGuid" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlGuid" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlInt16(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlInt16" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlInt16" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlInt32(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlInt32" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlInt32" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlInt64(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlInt64" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlInt64" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlMetaData(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns a <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> object, describing the metadata of the column specified by the column ordinal.
      </summary><returns>
        The column metadata as a <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> object.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlMoney(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlMoney" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlMoney" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlSingle(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlSingle" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlSingle" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlString(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlString" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlString" />.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlValue(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns the data value stored in the column, expressed as a SQL Server type, specified by the column ordinal.
      </summary><returns>
        The value of the column, expressed as a SQL Server type, as a <see cref="T:System.Object" />.
      </returns><remarks>
        For null values, a SQL Server type instance is returned where the <see cref="P:System.Data.SqlTypes.INullable.IsNull" /> property is true.
      </remarks><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception><seealso cref="N:System.Data.SqlTypes" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlValues(System.Object[])">
            <param name="values">
        The array into which to copy the values column values.
      </param><summary>
        Returns the values for all the columns in the record, expressed as SQL Server types, in an array.
      </summary><returns>
        An <see cref="T:System.Int32" /> that indicates the number of columns copied.
      </returns><remarks>
        <para>
          The SQL Server type values of the column are copied into the <paramref name="values" /> array that is passed as a parameter. For null values, a Sql type instance is returned where the <see cref="P:System.Data.SqlTypes.INullable.IsNull" /> property is true.
        </para>
        <para>
          The length of the <paramref name="values" /> array does not need to match the number of columns in the record. If the array length is greater than the number of columns, all the column values are copied into the array; if it is less, only the array length number of column values are copied into the array, starting at the column value with ordinal 0.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        <paramref name="values" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception><seealso cref="N:System.Data.SqlTypes" />
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetSqlXml(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlXml" />.
      </summary><returns>
        The column value as a <see cref="T:System.Data.SqlTypes.SqlXml" />.
      </returns><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetString(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Gets the value for the column specified by the ordinal as a <see cref="T:System.String" />.
      </summary><returns>
        The column value as a <see cref="T:System.String" />.
      </returns><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetTimeSpan(System.Int32)">
            <param name="ordinal">
        The zero-based column ordinal.
      </param><summary>
        Returns the specified column's data as a <see cref="T:System.TimeSpan" />.
      </summary><returns>
        The value of the specified column as a <see cref="T:System.TimeSpan" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetValue(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns the common language runtime (CLR) type value for the column specified by the ordinal argument.
      </summary><returns>
        The CLR type value of the column specified by the ordinal.
      </returns><remarks>
        For columns with null value, <see cref="F:System.DBNull.Value" /> is returned.
      </remarks><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.GetValues(System.Object[])">
            <param name="values">
        The array into which to copy the values column values.
      </param><summary>
        Returns the values for all the columns in the record, expressed as common language runtime (CLR) types, in an array.
      </summary><returns>
        An <see cref="T:System.Int32" /> that indicates the number of columns copied.
      </returns><remarks>
        <para>
          The CLR type values of the column are copied into the <paramref name="values" /> array that is passed as a parameter. For columns with null value, <see cref="F:System.DBNull.Value" /> is returned.
        </para>
        <para>
          The length of the <paramref name="values" /> array does not need to match the number of columns in the record. If the array length is greater than the number of columns, all the column values are copied into the array; if it is less, only the array length number of column values is copied into the array, starting at the column value with ordinal 0.
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        <paramref name="values" /> is <see langword="null" />.
      </exception><exception cref="T:System.InvalidCastException">
        There is a type mismatch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.IsDBNull(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Returns <see langword="true" /> if the column specified by the column ordinal parameter is null.
      </summary><returns>
        <see langword="true" /> if the column is null; <see langword="false" /> otherwise.
      </returns><exception cref="T:System.IndexOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetBoolean(System.Int32,System.Boolean)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Boolean" /> value.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetByte(System.Int32,System.Byte)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Byte" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="fieldOffset">
        The offset into the field value to start copying bytes.
      </param><param name="buffer">
        The target buffer from which to copy bytes.
      </param><param name="bufferOffset">
        The offset into the buffer from which to start copying bytes.
      </param><param name="length">
        The number of bytes to copy from the buffer.
      </param><summary>
        Sets the data stored in the column to the specified array of <see cref="T:System.Byte" /> values.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetChar(System.Int32,System.Char)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Char" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="fieldOffset">
        The offset into the field value to start copying characters.
      </param><param name="buffer">
        The target buffer from which to copy chars.
      </param><param name="bufferOffset">
        The offset into the buffer from which to start copying chars.
      </param><param name="length">
        The number of chars to copy from the buffer.
      </param><summary>
        Sets the data stored in the column to the specified array of <see cref="T:System.Char" /> values.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetDateTime(System.Int32,System.DateTime)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.DateTime" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetDateTimeOffset(System.Int32,System.DateTimeOffset)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the value of the column specified to the <see cref="T:System.DateTimeOffset" /> value.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetDBNull(System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><summary>
        Sets the value in the specified column to <see cref="T:System.DBNull" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetDecimal(System.Int32,System.Decimal)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Decimal" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetDouble(System.Int32,System.Double)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Double" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetFloat(System.Int32,System.Single)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Single" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetGuid(System.Int32,System.Guid)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Guid" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetInt16(System.Int32,System.Int16)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Int16" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetInt32(System.Int32,System.Int32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Int32" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetInt64(System.Int32,System.Int64)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Int64" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlBinary(System.Int32,System.Data.SqlTypes.SqlBinary)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlBinary" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlBoolean(System.Int32,System.Data.SqlTypes.SqlBoolean)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlBoolean" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlByte(System.Int32,System.Data.SqlTypes.SqlByte)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlByte" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlBytes(System.Int32,System.Data.SqlTypes.SqlBytes)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlBytes" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlChars(System.Int32,System.Data.SqlTypes.SqlChars)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlChars" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlDateTime(System.Int32,System.Data.SqlTypes.SqlDateTime)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlDateTime" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlDecimal(System.Int32,System.Data.SqlTypes.SqlDecimal)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlDouble(System.Int32,System.Data.SqlTypes.SqlDouble)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlDouble" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlGuid(System.Int32,System.Data.SqlTypes.SqlGuid)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlGuid" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlInt16(System.Int32,System.Data.SqlTypes.SqlInt16)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlInt16" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlInt32(System.Int32,System.Data.SqlTypes.SqlInt32)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlInt32" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlInt64(System.Int32,System.Data.SqlTypes.SqlInt64)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlInt64" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlMoney(System.Int32,System.Data.SqlTypes.SqlMoney)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlMoney" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlSingle(System.Int32,System.Data.SqlTypes.SqlSingle)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlSingle" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlString(System.Int32,System.Data.SqlTypes.SqlString)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlString" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetSqlXml(System.Int32,System.Data.SqlTypes.SqlXml)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlXml" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetString(System.Int32,System.String)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the data stored in the column to the specified <see cref="T:System.String" /> value.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetTimeSpan(System.Int32,System.TimeSpan)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value of the column.
      </param><summary>
        Sets the value of the column specified to the <see cref="T:System.TimeSpan" />.
      </summary><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> passed in is a negative number.
      </exception><exception cref="T:System.ArgumentException">
        The <see cref="T:System.TimeSpan" /> value passed in is greater than 24 hours in length.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetValue(System.Int32,System.Object)">
            <param name="ordinal">
        The zero-based ordinal of the column.
      </param><param name="value">
        The new value for the specified column.
      </param><summary>
        Sets a new value, expressed as a common language runtime (CLR) type, for the column specified by the column ordinal.
      </summary><remarks>
        <paramref name="value" /> is a SQL type boxed as a <see cref="T:System.Object" /> instance.
      </remarks><exception cref="T:System.ArgumentOutOfRangeException">
        The <paramref name="ordinal" /> is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.Data.SqlClient.Server.SqlDataRecord.FieldCount" />).
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlDataRecord.SetValues(System.Object[])">
            <param name="values">
        The array of new values, expressed as CLR types boxed as <see cref="T:System.Object" /> references, for the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> instance.
      </param><summary>
        Sets new values for all the columns in the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" />. These values are expressed as common language runtime (CLR) types.
      </summary><returns>
        The number of column values set as an integer.
      </returns><remarks>
        The length of values must match the number of columns in the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> instance.
      </remarks><exception cref="T:System.ArgumentNullException">
        <paramref name="values" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        The size of values does not match the number of columns in the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> instance.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.Server.SqlMetaData">
            <summary>
        Specifies and retrieves metadata information from parameters and columns of <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> objects. This class cannot be inherited.
      </summary><example>
        <para>
          The following example shows the creation of several <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> objects, which describe the column metadata of a record, and the creation of a <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" />. The column values of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> are set and the <see cref="T:Microsoft.Data.SqlClient.Server.SqlDataRecord" /> is sent to the calling program using the <see cref="T:Microsoft.SqlServer.Server.SqlContext" /> class.
        </para>
        <!-- SqlMetaData #1 -->
        <code language="c#">
          using Microsoft.Data.SqlClient.Server;
      
          [Microsoft.Data.SqlClient.Server.SqlProcedure]
          public static void CreateNewRecord()
          {
              // Variables.
              SqlMetaData column1Info;
              SqlMetaData column2Info;
              SqlMetaData column3Info;
              SqlDataRecord record;
      
              // Create the column metadata.
              column1Info = new SqlMetaData("Column1", SqlDbType.NVarChar, 12);
              column2Info = new SqlMetaData("Column2", SqlDbType.Int);
              column3Info = new SqlMetaData("Column3", SqlDbType.DateTime);
      
              // Create a new record with the column metadata.      
              record = new SqlDataRecord(new SqlMetaData[] { 
                column1Info,
                column2Info,
                column3Info });
      
              // Set the record fields.
              record.SetString(0, "Hello World!");
              record.SetInt32(1, 42);
              record.SetDateTime(2, DateTime.Now);
      
              // Send the record to the calling program.
              SqlContext.Pipe.Send(record);
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name and type.
      </summary><remarks>
        <para>
          Only the following are allowed to be passed to this constructor as <paramref name="dbType" />: <see cref="F:System.Data.SqlDbType.Bit" />, <see cref="F:System.Data.SqlDbType.BigInt" />, <see cref="F:System.Data.SqlDbType.DateTime" />, <see cref="F:System.Data.SqlDbType.Decimal" />, <see cref="F:System.Data.SqlDbType.Float" />, <see cref="F:System.Data.SqlDbType.Int" />, <see cref="F:System.Data.SqlDbType.Money" />, <c>Numeric</c>, <see cref="F:System.Data.SqlDbType.SmallDateTime" />, <see cref="F:System.Data.SqlDbType.SmallInt" />, <see cref="F:System.Data.SqlDbType.SmallMoney" />, <see cref="F:System.Data.SqlDbType.Timestamp" />, <see cref="F:System.Data.SqlDbType.TinyInt" />, <see cref="F:System.Data.SqlDbType.UniqueIdentifier" />, <see cref="F:System.Data.SqlDbType.Xml" />.
        </para>
        <para>
          The following are the default values assigned to <paramref name="dbType" />, depending on the <see cref="T:System.Data.SqlDbType" /> (the <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" />, and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Type" /> properties are set to <see langword="null" />):
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>SqlDbType</term>
              <description>Maximum length</description>
              <description>Precision</description>
              <description>Scale</description>
              <description>Locale</description>
              <description>Compare options</description>
            </listheader>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Bit" /></term>
              <description>1</description>
              <description>1</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.BigInt" /></term>
              <description>8</description>
              <description>19</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.DateTime" /></term>
              <description>8</description>
              <description>23</description>
              <description>3</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Decimal" /></term>
              <description>9</description>
              <description>18</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Float" /></term>
              <description>8</description>
              <description>53</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Int" /></term>
              <description>4</description>
              <description>10</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Money" /></term>
              <description>8</description>
              <description>19</description>
              <description>4</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><c>Numeric</c></term>
              <description>9</description>
              <description>18</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.SmallDateTime" /></term>
              <description>4</description>
              <description>16</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.SmallInt" /></term>
              <description>2</description>
              <description>5</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.SmallMoney" /></term>
              <description>4</description>
              <description>10</description>
              <description>4</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Timestamp" /></term>
              <description>8</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.TinyInt" /></term>
              <description>1</description>
              <description>3</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.UniqueIdentifier" /></term>
              <description>16</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Xml" /></term>
              <description>Max (-1)</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
          </list>
        </para>
      </remarks><example>
        <para>
          The following example creates a new <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> object by specifying the column name and a column data type of <see cref="F:System.Data.SqlDbType.Int" />
        </para>
        <!-- SqlMetadata #3 -->
        <code language="c#">
          using Microsoft.Data.SqlClient.Server;
      
          public static void CreateSqlMetaData2()
          {
              SqlMetaData columnInfo;
              columnInfo = new SqlMetaData("Column2", SqlDbType.Int);
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        The <paramref name="name" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        A <see langword="SqlDbType" /> that is not allowed was passed to the constructor as <paramref name="dbType" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Boolean,System.Boolean,Microsoft.Data.SqlClient.SortOrder,System.Int32)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="useServerDefault">
        Specifies whether this column should use the default server value.
      </param><param name="isUniqueKey">
        Specifies if the column in the table-valued parameter is unique.
      </param><param name="columnSortOrder">
        Specifies the sort order for a column.
      </param><param name="sortOrdinal">
        Specifies the ordinal of the sort column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, and default server. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.
      </summary><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Byte,System.Byte)">
            <param name="name">
        The name of the parameter or column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="precision">
        The precision of the parameter or column.
      </param><param name="scale">
        The scale of the parameter or column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, precision, and scale.
      </summary><remarks>
        <para>
          Only the following <see cref="T:System.Data.SqlDbType" /> is allowed to be passed to the constructor as <paramref name="dbType" />: <see cref="F:System.Data.SqlDbType.Decimal" />.
        </para>
        <para>
          The following are the default values assigned to <paramref name="dbType" />, depending on the <see cref="T:System.Data.SqlDbType" /> (the <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" />, and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Type" /> properties are set to <see langword="null" />):
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>SqlDbType</term>
              <description>Maximum length</description>
              <description>Precision</description>
              <description>Scale</description>
              <description>Locale</description>
              <description>Compare options</description>
            </listheader>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Decimal" /></term>
              <description>9</description>
              <description>18</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
          </list>
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="name" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        A <see cref="T:System.Data.SqlDbType" /> that is not allowed was passed to the constructor as <paramref name="dbType" />, or <paramref name="scale" /> was greater than <paramref name="precision" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Byte,System.Byte,System.Boolean,System.Boolean,Microsoft.Data.SqlClient.SortOrder,System.Int32)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="precision">
        The precision of the parameter or column.
      </param><param name="scale">
        The scale of the parameter or column.
      </param><param name="useServerDefault">
        Specifies whether this column should use the default server value.
      </param><param name="isUniqueKey">
        Specifies if the column in the table-valued parameter is unique.
      </param><param name="columnSortOrder">
        Specifies the sort order for a column.
      </param><param name="sortOrdinal">
        Specifies the ordinal of the sort column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, precision, scale, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.
      </summary><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Int64)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="maxLength">
        The maximum length of the specified type.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, and maximum length.
      </summary><remarks>
        <para>
          Only the following are allowed to be passed to the constructor as <paramref name="dbType" />: <see cref="F:System.Data.SqlDbType.Binary" />, <see cref="F:System.Data.SqlDbType.Char" />, <see cref="F:System.Data.SqlDbType.Image" />, <see cref="F:System.Data.SqlDbType.NChar" />, <see cref="F:System.Data.SqlDbType.NText" />, <see cref="F:System.Data.SqlDbType.NVarChar" />, <see cref="F:System.Data.SqlDbType.Text" />, <see cref="F:System.Data.SqlDbType.VarBinary" />, <see cref="F:System.Data.SqlDbType.VarChar" />.
        </para>
        <para>
          Only a <paramref name="maxLength" /> specification of <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Max" />, or -1 is allowed for a <paramref name="dbType" /> of <see cref="F:System.Data.SqlDbType.Text" />, <see cref="F:System.Data.SqlDbType.NText" />, or <see cref="F:System.Data.SqlDbType.Image" />.
        </para>
        <para>
          For a <paramref name="dbType" /> of <see cref="F:System.Data.SqlDbType.VarChar" />, <see cref="F:System.Data.SqlDbType.NVarChar" />, or <see cref="F:System.Data.SqlDbType.VarBinary" />, a length specification of <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Max" />, or -1, declares the metadata as <c>VARCHAR(MAX)</c>, <c>NVARCHAR(MAX)</c>, or <c>NVARBINARY(MAX)</c>, respectively.
        </para>
        <para>
          The following are the default values assigned to <paramref name="dbType" />, depending on the <see cref="T:System.Data.SqlDbType" /> (the <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" />, and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Type" /> properties are set to <see langword="null" />):
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>SqlDbType</term>
              <description>Precision</description>
              <description>Scale</description>
              <description>Locale</description>
              <description>Compare options</description>
            </listheader>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Binary" /></term>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Char" /></term>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Image" /></term>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.NChar" /></term>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.NText" /></term>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.NVarChar" /></term>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Text" /></term>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.VarBinary" /></term>
              <description>0</description>
              <description>0</description>
              <description />
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.VarChar" /></term>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
          </list>
        </para>
      </remarks><example>
        <para>
          The following example creates a new <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> object by specifying the column name, a column data type of <see cref="F:System.Data.SqlDbType.NVarChar" />, and a maximum length of 12 characters.
        </para>
        <!-- SqlMetaData #2 -->
        <code language="c#">
          using Microsoft.Data.SqlClient.Server;
      
          public static void CreateSqlMetaData1()
          {
              SqlMetaData columnInfo;
              columnInfo = new SqlMetaData("Column1", SqlDbType.NVarChar, 12);
          }
        </code>
      </example><exception cref="T:System.ArgumentNullException">
        The <paramref name="name" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        A SqlDbType that is not allowed was passed to the constructor as <paramref name="dbType" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Int64,System.Boolean,System.Boolean,Microsoft.Data.SqlClient.SortOrder,System.Int32)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="maxLength">
        The maximum length of the specified type.
      </param><param name="useServerDefault">
        Specifies whether this column should use the default server value.
      </param><param name="isUniqueKey">
        Specifies if the column in the table-valued parameter is unique.
      </param><param name="columnSortOrder">
        Specifies the sort order for a column.
      </param><param name="sortOrdinal">
        Specifies the ordinal of the sort column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, maximum length, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.
      </summary><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Int64,System.Byte,System.Byte,System.Int64,System.Data.SqlTypes.SqlCompareOptions,System.Type)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="maxLength">
        The maximum length of the specified type.
      </param><param name="precision">
        The precision of the parameter or column.
      </param><param name="scale">
        The scale of the parameter or column.
      </param><param name="locale">
        The locale ID of the parameter or column.
      </param><param name="compareOptions">
        The comparison rules of the parameter or column.
      </param><param name="userDefinedType">
        A <see cref="T:System.Type" /> instance that points to the UDT.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, maximum length, precision, scale, locale ID, compare options, and user-defined type (UDT).
      </summary><remarks>
        <para>
          Only the following are allowed to be passed to the constructor as <paramref name="dbType" />: <see cref="F:System.Data.SqlDbType.BigInt" />, <see cref="F:System.Data.SqlDbType.Bit" />, <see cref="F:System.Data.SqlDbType.DateTime" />, <see cref="F:System.Data.SqlDbType.Decimal" />, <see cref="F:System.Data.SqlDbType.Float" />, <see cref="F:System.Data.SqlDbType.Image" />, <see cref="F:System.Data.SqlDbType.Int" />, <see cref="F:System.Data.SqlDbType.Money" />, <see cref="F:System.Data.SqlDbType.NText" />, <c>Numeric</c>, <see cref="F:System.Data.SqlDbType.Real" />, <see cref="F:System.Data.SqlDbType.SmallDateTime" />, <see cref="F:System.Data.SqlDbType.SmallInt" />, <see cref="F:System.Data.SqlDbType.SmallMoney" />, <see cref="F:System.Data.SqlDbType.Text" />, <see cref="F:System.Data.SqlDbType.Timestamp" />, <see cref="F:System.Data.SqlDbType.TinyInt" />, <see cref="F:System.Data.SqlDbType.Udt" />, <see cref="F:System.Data.SqlDbType.UniqueIdentifier" />, <see cref="F:System.Data.SqlDbType.Variant" />, <see cref="F:System.Data.SqlDbType.Xml" />.
        </para>
        <para>
          The following are the default values assigned to <paramref name="dbType" />, depending on the <see cref="T:System.Data.SqlDbType" /> (the <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" />, and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Type" /> properties are set to <see langword="null" />):
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>SqlDbType</term>
              <description>Maximum length</description>
              <description>Precision</description>
              <description>Scale</description>
              <description>Locale</description>
              <description>Compare options</description>
            </listheader>
            <item>
              <term><see cref="F:System.Data.SqlDbType.BigInt" /></term>
              <description>8</description>
              <description>19</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Bit" /></term>
              <description>1</description>
              <description>1</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.DateTime" /></term>
              <description>8</description>
              <description>23</description>
              <description>3</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Decimal" /></term>
              <description>9</description>
              <description>18</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Float" /></term>
              <description>8</description>
              <description>53</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Image" /></term>
              <description>Max (-1)</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Int" /></term>
              <description>4</description>
              <description>10</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Money" /></term>
              <description>8</description>
              <description>19</description>
              <description>4</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.NText" /></term>
              <description>Max (-1)</description>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Real" /></term>
              <description>4</description>
              <description>24</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><c>Row</c></term>
              <description>&lt;number of columns&gt;</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.SmallDateTime" /></term>
              <description>4</description>
              <description>16</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.SmallInt" /></term>
              <description>2</description>
              <description>5</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.SmallMoney" /></term>
              <description>4</description>
              <description>10</description>
              <description>4</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Text" /></term>
              <description>Max (-1)</description>
              <description>0</description>
              <description>0</description>
              <description>&lt;thread&gt;</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Timestamp" /></term>
              <description>8</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.TinyInt" /></term>
              <description>1</description>
              <description>3</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.UniqueIdentifier" /></term>
              <description>16</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Udt" /></term>
              <description>&lt;Max length of the type&gt; or -1</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Variant" /></term>
              <description>8016</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Xml" /></term>
              <description>Max (-1)</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
          </list>
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="name" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        A <see langword="SqlDbType" /> that is not allowed was passed to the constructor as <paramref name="dbType" />, or <paramref name="userDefinedType" /> points to a type that does not have <see cref="T:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute" /> declared.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Int64,System.Byte,System.Byte,System.Int64,System.Data.SqlTypes.SqlCompareOptions,System.Type,System.Boolean,System.Boolean,Microsoft.Data.SqlClient.SortOrder,System.Int32)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="maxLength">
        The maximum length of the specified type.
      </param><param name="precision">
        The precision of the parameter or column.
      </param><param name="scale">
        The scale of the parameter or column.
      </param><param name="localeId">
        The locale ID of the parameter or column.
      </param><param name="compareOptions">
        The comparison rules of the parameter or column.
      </param><param name="userDefinedType">
        A <see cref="T:System.Type" /> instance that points to the UDT.
      </param><param name="useServerDefault">
        Specifies whether this column should use the default server value.
      </param><param name="isUniqueKey">
        Specifies if the column in the table-valued parameter is unique.
      </param><param name="columnSortOrder">
        Specifies the sort order for a column.
      </param><param name="sortOrdinal">
        Specifies the ordinal of the sort column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, maximum length, precision, scale, locale ID, compare options, and user-defined type (UDT). This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.
      </summary><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Int64,System.Int64,System.Data.SqlTypes.SqlCompareOptions)">
            <param name="name">
        The name of the parameter or column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="maxLength">
        The maximum length of the specified type.
      </param><param name="locale">
        The locale ID of the parameter or column.
      </param><param name="compareOptions">
        The comparison rules of the parameter or column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, maximum length, locale, and compare options.
      </summary><remarks>
        <para>
          Only the following are allowed to be passed to the constructor as <paramref name="dbType" />: <see cref="F:System.Data.SqlDbType.Char" />, <see cref="F:System.Data.SqlDbType.NChar" />, <see cref="F:System.Data.SqlDbType.NText" />, <see cref="F:System.Data.SqlDbType.NVarChar" />, <see cref="F:System.Data.SqlDbType.Text" />, <see cref="F:System.Data.SqlDbType.VarChar" />.
        </para>
        <para>
          Only a <see langword="maxLength" /> specification of <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Max" />, or -1, is allowed for a <paramref name="dbType" /> of <see cref="F:System.Data.SqlDbType.Text" /> or <see cref="F:System.Data.SqlDbType.NText" />.
        </para>
        <para>
          For a <paramref name="dbType" /> of <see cref="F:System.Data.SqlDbType.VarChar" /> or <see cref="F:System.Data.SqlDbType.NVarChar" />, a length specification of <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Max" />, or -1, declares the metadata as VARCHAR(MAX) and NVARCHAR(MAX), respectively.
        </para>
        <para>
          The following are the default values assigned to <paramref name="dbType" />, depending on the <see cref="T:System.Data.SqlDbType" /> (the <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" />, and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Type" /> properties are set to <see langword="null" />):
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>SqlDbType</term>
              <description>Precision</description>
              <description>Scale</description>
            </listheader>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Char" /></term>
              <description>0</description>
              <description>0</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.NChar" /></term>
              <description>0</description>
              <description>0</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.NText" /></term>
              <description>0</description>
              <description>0</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.NVarChar" /></term>
              <description>0</description>
              <description>0</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Text" /></term>
              <description>0</description>
              <description>0</description>
            </item>
            <item>
              <term><see cref="F:System.Data.SqlDbType.VarChar" /></term>
              <description>0</description>
              <description>0</description>
            </item>
          </list>
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="name" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        A <see cref="T:System.Data.SqlDbType" /> that is not allowed was passed to the constructor as <paramref name="dbType" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Int64,System.Int64,System.Data.SqlTypes.SqlCompareOptions,System.Boolean,System.Boolean,Microsoft.Data.SqlClient.SortOrder,System.Int32)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="maxLength">
        The maximum length of the specified type.
      </param><param name="locale">
        The locale ID of the parameter or column.
      </param><param name="compareOptions">
        The comparison rules of the parameter or column.
      </param><param name="useServerDefault">
        Specifies whether this column should use the default server value.
      </param><param name="isUniqueKey">
        Specifies if the column in the table-valued parameter is unique.
      </param><param name="columnSortOrder">
        Specifies the sort order for a column.
      </param><param name="sortOrdinal">
        Specifies the ordinal of the sort column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, maximum length, locale, compare options, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.
      </summary><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.String,System.String,System.String)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="database">
        The database name of the XML schema collection of a typed XML instance.
      </param><param name="owningSchema">
        The relational schema name of the XML schema collection of a typed XML instance.
      </param><param name="objectName">
        The name of the XML schema collection of a typed XML instance.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, database name, owning schema, and object name.
      </summary><remarks>
        <para>
          Only the following <see cref="T:System.Data.SqlDbType" /> is allowed to be passed to the constructor as <paramref name="dbType" />: <see cref="F:System.Data.SqlDbType.Xml" />.
        </para>
        <para>
          The following are the default values assigned to <paramref name="dbType" />, depending on the <see cref="T:System.Data.SqlDbType" />:
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>SqlDbType</term>
              <description>Maximum length</description>
              <description>Precision</description>
              <description>Scale</description>
              <description>Locale</description>
              <description>Compare options</description>
            </listheader>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Xml" /></term>
              <description>Max (-1)</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>IgnoreCase, IgnoreKanaType, IgnoreWidth</description>
            </item>
          </list>
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="name" /> is <see langword="null" />, or <paramref name="objectName" /> is <see langword="null" /> when <paramref name="database" /> and <paramref name="owningSchema" /> are non- <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        A SqlDbType that is not allowed was passed to the constructor as <paramref name="dbType" />.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.String,System.String,System.String,System.Boolean,System.Boolean,Microsoft.Data.SqlClient.SortOrder,System.Int32)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="database">
        The database name of the XML schema collection of a typed XML instance.
      </param><param name="owningSchema">
        The relational schema name of the XML schema collection of a typed XML instance.
      </param><param name="objectName">
        The name of the XML schema collection of a typed XML instance.
      </param><param name="useServerDefault">
        Specifies whether this column should use the default server value.
      </param><param name="isUniqueKey">
        Specifies if the column in the table-valued parameter is unique.
      </param><param name="columnSortOrder">
        Specifies the sort order for a column.
      </param><param name="sortOrdinal">
        Specifies the ordinal of the sort column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, database name, owning schema, object name, and default server. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.
      </summary><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Type)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="userDefinedType">
        A <see cref="T:System.Type" /> instance that points to the UDT.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, and user-defined type (UDT).
      </summary><remarks>
        <para>
          Only the following <see cref="T:System.Data.SqlDbType" /> is allowed to be passed to the constructor as <paramref name="dbType" />: <see cref="F:System.Data.SqlDbType.Udt" />.
        </para>
        <para>
          The following are the default values assigned to <paramref name="dbType" />, depending on the <see cref="T:System.Data.SqlDbType" /> (the <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" />, <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" />, and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Type" /> properties are set to <see langword="null" />):
        </para>
        <para>
          <list type="table">
            <listheader>
              <term>SqlDbType</term>
              <description>Maximum length</description>
              <description>Precision</description>
              <description>Scale</description>
              <description>Locale</description>
              <description>Compare options</description>
            </listheader>
            <item>
              <term><see cref="F:System.Data.SqlDbType.Udt" /></term>
              <description>&lt;Max length of the type&gt; or -1</description>
              <description>0</description>
              <description>0</description>
              <description>0</description>
              <description>None</description>
            </item>
          </list>
        </para>
      </remarks><exception cref="T:System.ArgumentNullException">
        The <paramref name="name" /> is <see langword="null" />.
      </exception><exception cref="T:System.ArgumentException">
        A <see cref="T:System.Data.SqlDbType" /> that is not allowed was passed to the constructor as <paramref name="dbType" />, or <paramref name="userDefinedType" /> points to a type that does not have <see cref="T:Microsoft.Data.SqlClient.Server.SqlUserDefinedTypeAttribute" /> declared.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Type,System.String)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="userDefinedType">
        A <see cref="T:System.Type" /> instance that points to the UDT.
      </param><param name="serverTypeName">
        The SQL Server type name for <paramref name="userDefinedType" />.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, user-defined type (UDT), and SQLServer type.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.#ctor(System.String,System.Data.SqlDbType,System.Type,System.String,System.Boolean,System.Boolean,Microsoft.Data.SqlClient.SortOrder,System.Int32)">
            <param name="name">
        The name of the column.
      </param><param name="dbType">
        The SQL Server type of the parameter or column.
      </param><param name="userDefinedType">
        A <see cref="T:System.Type" /> instance that points to the UDT.
      </param><param name="serverTypeName">
        The SQL Server type name for <paramref name="userDefinedType" />.
      </param><param name="useServerDefault">
        Specifies whether this column should use the default server value.
      </param><param name="isUniqueKey">
        Specifies if the column in the table-valued parameter is unique.
      </param><param name="columnSortOrder">
        Specifies the sort order for a column.
      </param><param name="sortOrdinal">
        Specifies the ordinal of the sort column.
      </param><summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> class with the specified column name, type, user-defined type, SQL Server type, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.
      </summary><remarks>
        For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.CompareOptions">
            <summary>
        Gets the comparison rules used for the column or parameter.
      </summary><value>
        The comparison rules used for the column or parameter as a <see cref="T:System.Data.SqlTypes.SqlCompareOptions" />.
      </value><remarks>
        To be added.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.DbType">
            <summary>
        Gets the data type of the column or parameter.
      </summary><value>
        The data type of the column or parameter as a <see cref="T:System.Data.DbType" />.
      </value><remarks>
        The default type is <see cref="F:System.Data.DbType.String" />.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.IsUniqueKey">
            <summary>
        Indicates if the column in the table-valued parameter is unique.
      </summary><value>
        A <see cref="T:System.Boolean" /> value.
      </value><remarks>
        <para>
          The default is <see langword="false" />.
        </para>
        <para>
          This property can only be set in one of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> constructors.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.LocaleId">
            <summary>
        Gets the locale ID of the column or parameter.
      </summary><value>
        The locale ID of the column or parameter as a <see cref="T:System.Int64" />.
      </value><remarks>
        <para>
          The default value is the current locale of the current thread for string-valued <see cref="T:System.Data.SqlDbType" />s, and 0 for <see cref="T:System.Data.SqlDbType" />s that do not support collation.
        </para>
        <para>
          Returns 0 if the collation of the underlying column type is not defined.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Max">
            <summary>
        Gets the length of TEXT, NTEXT, and IMAGE data types.
      </summary><value>
        The length of TEXT, NTEXT, and IMAGE data types.
      </value><remarks>
        The default value is -1.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.MaxLength">
            <summary>
        Gets the maximum length of the column or parameter.
      </summary><value>
        The maximum length of the column or parameter as a <see cref="T:System.Int64" />.
      </value><remarks>
        <para>
          The potential maximum length for values of the specified column. Returns 0 for types other than fixed and varying length character and binary types. For variable size columns or parameters declared with the <c>Max</c> constructor parameter, it returns -1.
        </para>
        <para>
          For <c>Row</c> this returns the number of columns in the row metadata instance.
        </para>
        <para>
          The default value is 0.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Name">
            <summary>
        Gets the name of the column or parameter.
      </summary><value>
        The name of the column or parameter as a <see cref="T:System.String" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Precision">
            <summary>
        Gets the precision of the column or parameter.
      </summary><value>
        The precision of the column or parameter as a <see cref="T:System.Byte" />.
      </value><remarks>
        Returns 0 if the precision of the underlying column type is not defined.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Scale">
            <summary>
        Gets the scale of the column or parameter.
      </summary><value>
        The scale of the column or parameter.
      </value><remarks>
        Returns 0 if the scale of the underlying column type is not defined.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.SortOrder">
            <summary>
        Returns the sort order for a column.
      </summary><value>
        A <see cref="T:Microsoft.Data.SqlClient.SortOrder" /> object.
      </value><remarks>
        <para>
          This property can only be set in one of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> constructors.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.SortOrdinal">
            <summary>
        Returns the ordinal of the sort column.
      </summary><value>
        The ordinal of the sort column.
      </value><remarks>
        <para>
          The default is 1.
        </para>
        <para>
          This property can only be set in one of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> constructors.
        </para>
        <para>
          For more information, see <see href="https://learn.microsoft.com/sql/connect/ado-net/sql/table-valued-parameters">Table-Valued Parameters</see>.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.SqlDbType">
            <summary>
        Gets the data type of the column or parameter.
      </summary><value>
        The data type of the column or parameter as a <see cref="T:System.Data.DbType" />.
      </value><remarks>
        The default value is <see cref="F:System.Data.SqlDbType.NVarChar" />.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.Type">
            <summary>
        Gets the common language runtime (CLR) type of user-defined type (UDT).
      </summary><value>
        The CLR type name of a user-defined type as a <see cref="T:System.Type" />.
      </value><remarks>
        <para>
          The default value is <see langword="null" />.   
        </para>
        <para>
          Returns <see langword="null" /> if <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.SqlDbType" /> is not a UDT type. <see langword="null" /> may also returned for valid UDT result sets where the assembly is not available to the application.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.TypeName">
            <summary>
        Gets the three-part name of the user-defined type (UDT) or the SQL Server type represented by the instance.
      </summary><value>
        The name of the UDT or SQL Server type as a <see cref="T:System.String" />.
      </value><remarks>
        The default value is <see langword="null" />.
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.UseServerDefault">
            <summary>
        Reports whether this column should use the default server value.
      </summary><value>
        A <see cref="T:System.Boolean" /> value.
      </value><remarks>
        <para>
          The default is <see langword="false" />.
        </para>
        <para>
          This property can only be set in one of the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> constructors.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase">
            <summary>
        Gets the name of the database where the schema collection for this XML instance is located.
      </summary><value>
        The name of the database where the schema collection for this XML instance is located as a <see cref="T:System.String" />.
      </value><remarks>
        <para>
          The default value is <see langword="null" />.
        </para>
        <para>
          This property may be <see langword="null" /> if the collection is defined within the current database. It is also <see langword="null" /> if there is no schema collection, in which case <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" /> and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" /> are also <see langword="null" />.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName">
            <summary>
        Gets the name of the schema collection for this XML instance.
      </summary><value>
        The name of the schema collection for this XML instance as a <see cref="T:System.String" />.
      </value><remarks>
        <para>
          The default value is <see langword="null" />.
        </para>
        <para>
          This value is <see langword="null" /> if there is no associated schema collection. If the value is <see langword="null" />, then <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" /> and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema" /> are also <see langword="null" />.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionOwningSchema">
            <summary>
        Gets the owning relational schema where the schema collection for this XML instance is located.
      </summary><value>
        The owning relational schema where the schema collection for this XML instance is located as a <see cref="T:System.String" />.
      </value><remarks>
        <para>
          The default value is <see langword="null" />.
        </para>
        <para>
          This value may be <see langword="null" /> if the collection is defined within the current database and default schema. It is also null if there is no schema collection, in which case <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionDatabase" /> and <see cref="P:Microsoft.Data.SqlClient.Server.SqlMetaData.XmlSchemaCollectionName" /> are also <see langword="null" />.
        </para>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Boolean)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Boolean" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Boolean" />.
      </returns><exception cref="T:System.ArgumentException">
        <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Byte)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Byte" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Byte" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Byte[])">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified array of <see cref="T:System.Byte" /> values against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as an array of <see cref="T:System.Byte" /> values.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Char)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Char" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Char" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Char[])">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified array of <see cref="T:System.Char" /> values against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as an array <see cref="T:System.Char" /> values.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlBinary)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlBinary" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlBinary" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlBoolean)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlBoolean" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlByte)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlByte" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlByte" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlBytes)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlBytes" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlBytes" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlChars)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlChars" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlChars" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlDateTime)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlDateTime" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlDecimal)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlDouble)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlDouble" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlDouble" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlGuid)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlGuid" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlGuid" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlInt16)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlInt16" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlInt16" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlInt32)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlInt32" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlInt32" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlInt64)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlInt64" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlInt64" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlMoney)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlMoney" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlMoney" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlSingle)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlSingle" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlSingle" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlString)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlString" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlString" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Data.SqlTypes.SqlXml)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Data.SqlTypes.SqlXml" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlXml" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.DateTime)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.DateTime" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.DateTime" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.DateTimeOffset)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.DateTimeOffset" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as an array of <see cref="T:System.DateTimeOffset" /> values.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Decimal)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Decimal" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Decimal" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Double)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Double" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Double" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Guid)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Guid" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Guid" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Int16)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Int16" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Int16" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Int32)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Int32" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Int32" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Int64)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Int64" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Int64" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Object)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Object" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Object" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.Single)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.Single" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.Single" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.String)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.String" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as a <see cref="T:System.String" />.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.Adjust(System.TimeSpan)">
            <param name="value">
        The value to validate against the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Validates the specified <see cref="T:System.TimeSpan" /> value against the metadata, and adjusts the value if necessary.
      </summary><returns>
        The adjusted value as an array of <see cref="T:System.TimeSpan" /> values.
      </returns><exception cref="T:System.ArgumentException"> <paramref name="value" /> does not match the <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> type, or <paramref name="value" /> could not be adjusted.</exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.Server.SqlMetaData.InferFromValue(System.Object,System.String)">
            <param name="value">
        The object used from which the metadata is inferred.
      </param><param name="name">
        The name assigned to the returned <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </param><summary>
        Infers the metadata from the specified object and returns it as a <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </summary><returns>
        The inferred metadata as a <see cref="T:Microsoft.Data.SqlClient.Server.SqlMetaData" /> instance.
      </returns><exception cref="T:System.ArgumentNullException">
        The <paramref name="value" /> is <see langword="null" />.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.DataClassification.ColumnSensitivity">
            <summary>
        Represents the Data Classification Sensitivity Information for columns as configured in Database.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.DataClassification.ColumnSensitivity.#ctor(System.Collections.Generic.IList{Microsoft.Data.SqlClient.DataClassification.SensitivityProperty})">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.DataClassification.ColumnSensitivity" /> class.
      </summary><param name="sensitivityProperties">
        List of sensitivity properties.
      </param>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.ColumnSensitivity.SensitivityProperties">
            <summary>
        Returns the list of sensitivity properties as received from Server for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.ColumnSensitivity" /> information.
      </summary><value>
        List of sensitivity properties.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.DataClassification.InformationType">
            <summary>
        Represents the Data Classification Information Types as received from SQL Server for the active <see cref="T:Microsoft.Data.SqlClient.DataClassification.InformationType" />
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.DataClassification.InformationType.#ctor(System.String,System.String)">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.DataClassification.InformationType" /> class.
      </summary><param name="name">
        Name of Information Type.
      </param><param name="id">
        ID of Information Type.
      </param>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.InformationType.Id">
            <summary>
        Gets the ID for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.InformationType" /> object
      </summary><value>
        ID of Information Type.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.InformationType.Name">
            <summary>
        Gets the name for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.InformationType" /> object
      </summary><value>
        Name of Information Type.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.DataClassification.Label">
            <summary>
        Represents the Data Classification Labels as received from SQL Server for the active <see cref="T:Microsoft.Data.SqlClient.DataClassification.InformationType" />
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.DataClassification.Label.#ctor(System.String,System.String)">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.DataClassification.Label" /> class.
      </summary><param name="name">
        Name of label.
      </param><param name="id">
        ID of label.
      </param>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.Label.Id">
            <summary>
        Gets the ID for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.Label" /> object
      </summary><value>
        ID of label.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.Label.Name">
            <summary>
        Gets the name for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.Label" /> object
      </summary><value>
        Name of label.
      </value>
        </member>
        <member name="T:Microsoft.Data.SqlClient.DataClassification.SensitivityRank">
            <summary>
        <para>
          A relative ranking of the sensitivity of a query or of a column that is part of per column data.
        </para>
        <para>
          It is an identifier based on a predefined set of values which define sensitivity rank. Used by other services like Advanced Threat Protection to detect anomalies based on their rank.
        </para>
      </summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.DataClassification.SensitivityRank.NOT_DEFINED">
            <summary>No sensitivity rank defined.</summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.DataClassification.SensitivityRank.NONE">
            <summary>Corresponds to rank value of 0.</summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.DataClassification.SensitivityRank.LOW">
            <summary>Corresponds to rank value of 10.</summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.DataClassification.SensitivityRank.MEDIUM">
            <summary>Corresponds to rank value 20.</summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.DataClassification.SensitivityRank.HIGH">
            <summary>Corresponds to rank value 30.</summary>
        </member>
        <member name="F:Microsoft.Data.SqlClient.DataClassification.SensitivityRank.CRITICAL">
            <summary>Corresponds to rank value 40.</summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification">
            <summary>
        Provides the functionality to retrieve Sensitivity Classification data as received from SQL Server for the active <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification.#ctor(System.Collections.Generic.IList{Microsoft.Data.SqlClient.DataClassification.Label},System.Collections.Generic.IList{Microsoft.Data.SqlClient.DataClassification.InformationType},System.Collections.Generic.IList{Microsoft.Data.SqlClient.DataClassification.ColumnSensitivity},Microsoft.Data.SqlClient.DataClassification.SensitivityRank)">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification" /> class.
      </summary><param name="labels">
        List of labels.
      </param><param name="informationTypes">
        List of information types.
      </param><param name="columnSensitivity">
        List of column sensitivities.
      </param><param name="sensitivityRank">
        Relative sensitivity rank for the query associated with the active <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </param>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification.ColumnSensitivities">
            <summary>
        Returns the column sensitivity for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification" /> Object
      </summary><value>
        List of column sensitivities.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification.InformationTypes">
            <summary>
        Returns the information types collection for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification" /> Object
      </summary><value>
        List of information types.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification.Labels">
            <summary>
        Returns the labels collection for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification" /> Object
      </summary><value>
        List of labels.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.SensitivityClassification.SensitivityRank">
            <summary>
        Returns the relative sensitivity rank for the query associated with the active <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><value>
        Relative sensitivity ranking for this query.
      </value><remarks>
        <para>
          A relative sensitivity ranking of the query. Available values are as below:
        </para>
        <list type="table">
          <listheader>
            <term>Sensitivity Rank</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>-1</term>
            <description>Not Defined (default)</description>
          </item>
          <item>
            <term>0</term>
            <description>None</description>
          </item>
          <item>
            <term>10</term>
            <description>Low</description>
          </item>
          <item>
            <term>20</term>
            <description>Medium</description>
          </item>
          <item>
            <term>30</term>
            <description>High</description>
          </item>
          <item>
            <term>40</term>
            <description>Critical</description>
          </item>
        </list>
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty">
            <summary>
        Represents the Data Classification Sensitivity Information for columns as configured in Database.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty.#ctor(Microsoft.Data.SqlClient.DataClassification.Label,Microsoft.Data.SqlClient.DataClassification.InformationType,Microsoft.Data.SqlClient.DataClassification.SensitivityRank)">
            <summary>
        Initializes a new instance of the <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" /> class.
      </summary><param name="label">
        Label for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" />.
      </param><param name="informationType">
        Information type for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" />.
      </param><param name="sensitivityRank">
        Sensitivity rank for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" />.
      </param>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty.InformationType">
            <summary>
        Returns the information type for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" /> Object
      </summary><value>
        Information type for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty.Label">
            <summary>
        Returns the label for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" /> Object
      </summary><value>
        Label for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty.SensitivityRank">
            <summary>
        Returns the sensitivity rank for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" /> Object
      </summary><value>
        Sensitivity rank for this <see cref="T:Microsoft.Data.SqlClient.DataClassification.SensitivityProperty" />.
      </value><remarks>
        <para>
          A relative sensitivity ranking of a column that is part of per column data. Available values are as below:
        </para>
        <list type="table">
          <listheader>
            <term>Sensitivity Rank</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>-1</term>
            <description>Not Defined (default)</description>
          </item>
          <item>
            <term>0</term>
            <description>None</description>
          </item>
          <item>
            <term>10</term>
            <description>Low</description>
          </item>
          <item>
            <term>20</term>
            <description>Medium</description>
          </item>
          <item>
            <term>30</term>
            <description>High</description>
          </item>
          <item>
            <term>40</term>
            <description>Critical</description>
          </item>
        </list>
      </remarks>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBatch">
            <example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />, then adds multiple <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> objects to the batch. It then executes the batch, creating a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the results of the batch commands, writing them to the console. Finally, the example closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and then the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> as the <c>using</c> blocks fall out of scope.
        </para>
        <code language="c#">
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI;Encrypt=False";
                  RunBatch(str);
              }
          
              static void RunBatch(string connString)
              {
                  using var connection = new SqlConnection(connString);
                  connection.Open();
          
                  using var batch = new SqlBatch(connection);
          
                  const int count = 10;
                  const string parameterName = "parameter";
                  for (int i = 0; i &lt; count; i++)
                  {
                      var batchCommand = new SqlBatchCommand($"SELECT @{parameterName} as value");
                      batchCommand.Parameters.Add(new SqlParameter(parameterName, i));
                      batch.BatchCommands.Add(batchCommand);
                  }
          
                  var results = new List&lt;int&gt;(count);
                  using (SqlDataReader reader = batch.ExecuteReader())
                  {
                      do
                      {
                          while (reader.Read())
                          {
                              results.Add(reader.GetFieldValue&lt;int&gt;(0));
                          }
                      } while (reader.NextResult());
                  }
                  Console.WriteLine(string.Join(", ", results));
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.#ctor">
            <summary>Initializes a new <see cref="T:SqlBatch" />.</summary><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />, then adds multiple <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> objects to the batch. It then executes the batch, creating a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the results of the batch commands, writing them to the console. Finally, the example closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and then the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> as the <c>using</c> blocks fall out of scope.
        </para>
        
        <code language="c#">
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI;Encrypt=False";
                  RunBatch(str);
              }
          
              static void RunBatch(string connString)
              {
                  using var connection = new SqlConnection(connString);
                  connection.Open();
          
                  using var batch = new SqlBatch(connection);
          
                  const int count = 10;
                  const string parameterName = "parameter";
                  for (int i = 0; i &lt; count; i++)
                  {
                      var batchCommand = new SqlBatchCommand($"SELECT @{parameterName} as value");
                      batchCommand.Parameters.Add(new SqlParameter(parameterName, i));
                      batch.BatchCommands.Add(batchCommand);
                  }
          
                  var results = new List&lt;lint&gt;(count);
                  using (SqlDataReader reader = batch.ExecuteReader())
                  {
                      do
                      {
                          while (reader.Read())
                          {
                              results.Add(reader.GetFieldValue&lt;int&gt;(0));
                          }
                      } while (reader.NextResult());
                  }
                  Console.WriteLine(string.Join(", ", results));
              }
          }
        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.#ctor(Microsoft.Data.SqlClient.SqlConnection,Microsoft.Data.SqlClient.SqlTransaction)">
            <summary>Initializes a new <see cref="T:SqlBatch" />.</summary><param name="connection">
        A <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> that represents the connection to an instance of SQL Server.
      </param><param name="transaction">
        The <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> in which the <see cref="T:Microsoft.Data.SqlClient.SqlCommand" /> executes.
      </param>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.Timeout">
            <summary>
        Gets or sets the wait time (in seconds) before terminating the attempt to execute the batch and generating an error.
      </summary><value>
        The time in seconds to wait for the batch to execute, which is in contract with the underlying <see cref="P:Microsoft.Data.SqlClient.SqlConnection.CommandTimeout" />
      </value><remarks>
        <para>
          An <see cref="T:System.ArgumentException" /> is generated if the assigned <see cref="P:Microsoft.Data.SqlClient.SqlBatch.Timeout" /> property value is less than 0.
        </para>
        <para>
          Note to implementers: it's recommended that 0 mean no timeout.
        </para>
      </remarks>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.Commands">
            <summary>
        The list of commands contained in the batch in a <see cref="T:System.Collections.Generic.List{Microsoft.Data.SqlClient.SqlBatchCommand}" />.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.Connection">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> used by this instance of the <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.Transaction">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> within which the <see cref="T:Microsoft.Data.SqlClient.SqlBatch" /> commands execute.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.BatchCommands">
            <summary>
        The list of commands contained in the batch in a <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" />.
      </summary><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />, then adds multiple <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> objects to the batch. It then executes the batch, creating a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the results of the batch commands, writing them to the console. Finally, the example closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and then the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> as the <c>using</c> blocks fall out of scope.
        </para>
        <code language="c#">
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI;Encrypt=False";
                  RunBatch(str);
              }
          
              static void RunBatch(string connString)
              {
                  using var connection = new SqlConnection(connString);
                  connection.Open();
          
                  using var batch = new SqlBatch(connection);
          
                  const int count = 10;
                  const string parameterName = "parameter";
                  for (int i = 0; i &lt; count; i++)
                  {
                      var batchCommand = new SqlBatchCommand($"SELECT @{parameterName} as value");
                      batchCommand.Parameters.Add(new SqlParameter(parameterName, i));
                      batch.BatchCommands.Add(batchCommand);
                  }
          
                  var results = new List&lt;int&gt;(count);
                  using (SqlDataReader reader = batch.ExecuteReader())
                  {
                      do
                      {
                          while (reader.Read())
                          {
                              results.Add(reader.GetFieldValue&lt;int&gt;(0));
                          }
                      } while (reader.NextResult());
                  }
                  Console.WriteLine(string.Join(", ", results));
              }
          }
        </code>
      </example>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.DbBatchCommands">
            <summary>Gets the collection of <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> objects.</summary><value>The commands contained within the batch.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.DbConnection">
            <summary>
        Gets or sets the <see cref="T:System.Data.Common.DbConnection" /> used by this <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />.
      </summary><value>The connection to the data source.</value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatch.DbTransaction">
            <summary>
        Gets or sets the <see cref="T:Microsoft.Data.SqlClient.SqlTransaction" /> within which this <see cref="T:Microsoft.Data.SqlClient.SqlBatch" /> object executes.
      </summary><value>
        The transaction within which a batch of a ADO.NET data provider executes. The default value is a null reference (<see langword="Nothing" /> in Visual Basic).
      </value>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.Cancel">
            <summary>
        Attempts to cancel the execution of a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />.
      </summary><remarks>
        If there is nothing to cancel, nothing happens. However, if there is a batch in process, and the attempt to cancel fails, no exception is generated.
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.CreateDbBatchCommand">
            <summary>Creates a new instance of a <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object.</summary><returns>A <see cref="T:System.Data.Common.DbBatchCommand" /> object.</returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.Dispose">
            <summary>
        Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteDbDataReader(System.Data.CommandBehavior)">
            <param name="behavior">
        An instance of <see cref="T:System.Data.CommandBehavior" />, specifying options for batch execution and data retrieval.
      </param><summary>
        Executes the batch against its connection, returning a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> which can be used to access the results.
      </summary><returns>A <see cref="T:System.Data.Common.DbDataReader" /> object.</returns><remarks>
        When the batch returns multiple result sets from different commands, <see cref="P:Microsoft.Data.SqlClient.SqlDataReader.NextResult" /> can be used to advance the reader to the next result set.
        <note type="note">
          This method benefits from <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior)" />, and all the expected exceptions of that method also apply here.
        </note>
      </remarks><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        An error occurred while executing the batch.
      </exception><exception cref="T:System.ArgumentException">
        The <see cref="T:System.Data.CommandBehavior" /> value is invalid.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)">
            <param name="behavior">One of the enumeration values that specifies options for batch execution and data retrieval.</param><param name="cancellationToken">A token to cancel the asynchronous operation.</param><summary>
        This implementation invokes the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync" /> method and returns a completed task. The default implementation will return a cancelled task if passed an already cancelled cancellation token. This method accepts a cancellation token that can be used to request the operation to be cancelled early.
      </summary><returns>A task representing the asynchronous operation.</returns><remarks>
        <para>
          For more information about asynchronous programming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
        <para>
          This method stores in the task it returns all non-usage exceptions that the method's synchronous counterpart can throw. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as <see cref="T:System.ArgumentException" />, are still thrown synchronously. For the stored exceptions, see the exceptions thrown by <see cref="M:System.Data.Common.DbBatch.ExecuteDbDataReader(System.Data.CommandBehavior)" />.
        </para>
        <note type="note">
          This method benefits from <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Threading.CancellationToken)" />, and all the expected exceptions of that method also apply here.
        </note>
      </remarks><exception cref="T:System.OperationCanceledException">
        The cancellation token was canceled. This exception is stored into the returned task.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteNonQuery">
            <summary>
        Executes the batch against its connection object, returning the total number of rows affected across all the batch commands.
      </summary><returns>The total number of rows affected across all the batch commands.</returns><remarks>
        You can use <see cref="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteNonQuery" /> to perform catalog operations (for example, querying the structure of a database or creating database objects such as tables), or to change the data in a database by executing UPDATE, INSERT, or DELETE statements. Although <see cref="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteNonQuery" /> does not return any rows, any output parameters or return values mapped to parameters are populated with data. For UPDATE, INSERT, and DELETE statements, the return value is the total number of rows affected by the batch. If no UPDATE, INSERT, or DELETE statements are included in the batch, the return value is -1.
        <note type="note">
          This method benefits from <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQuery" />, and all the expected exceptions of that method also apply here.
        </note>
      </remarks>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteNonQueryAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">A token to cancel the asynchronous operation.</param><summary>
        This is the asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteNonQuery" />.
        The implementation invokes the <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" /> method and returns a completed task. The default implementation will return a cancelled task if passed an already cancelled cancellation token.
        Do not invoke other methods and properties of the <see langword="DbCommand" /> object until the returned Task is complete.
      </summary><returns>A task representing the asynchronous operation.</returns><remarks>
        <para>
          For more information about asynchronous programming, see <see href="https://learn.microsoft.com/sql/connect/ado-net/asynchronous-programming">Asynchronous Programming</see>.
        </para>
        <para>
          If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as <see cref="T:System.ArgumentException" />, are still thrown synchronously.
        </para>
        <note type="note">
          This method benefits from <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" />, and all the expected exceptions of that method also apply here.
        </note>
      </remarks><exception cref="T:Microsoft.Data.SqlClient.SqlException">An error occurred while executing the batch.</exception><related type="Article" href="https://learn.microsoft.com/sql/connect/ado-net/overview-sqlclient-driver">Overview of the SqlClient driver</related><exception cref="T:System.OperationCanceledException">
        The cancellation token was canceled. This exception is stored into the returned task.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteReader">
            <summary>
        Sends the <see cref="P:Microsoft.Data.SqlClient.SqlBatch.Commands" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlCommand.Connection" /> and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
      </summary><example>
        <para>
          The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />, then adds multiple <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> objects to the batch. It then executes the batch, creating a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />. The example reads through the results of the batch commands, writing them to the console. Finally, the example closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and then the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> as the <c>using</c> blocks fall out of scope.
        </para>
        <code language="c#">
          using Microsoft.Data.SqlClient;
          
          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI;Encrypt=False";
                  RunBatch(str);
              }
          
              static void RunBatch(string connString)
              {
                  using var connection = new SqlConnection(connString);
                  connection.Open();
          
                  using var batch = new SqlBatch(connection);
          
                  const int count = 10;
                  const string parameterName = "parameter";
                  for (int i = 0; i &lt; count; i++)
                  {
                      var batchCommand = new SqlBatchCommand($"SELECT @{parameterName} as value");
                      batchCommand.Parameters.Add(new SqlParameter(parameterName, i));
                      batch.BatchCommands.Add(batchCommand);
                  }
          
                  var results = new List&lt;int&gt;(count);
                  using (SqlDataReader reader = batch.ExecuteReader())
                  {
                      do
                      {
                          while (reader.Read())
                          {
                              results.Add(reader.GetFieldValue&lt;int&gt;(0));
                          }
                      } while (reader.NextResult());
                  }
                  Console.WriteLine(string.Join(", ", results));
              }
          }
          </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteReaderAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">A token to cancel the asynchronous operation.</param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteReader" />, which sends the <see cref="P:Microsoft.Data.SqlClient.SqlBatch.Commands" /> to the <see cref="P:Microsoft.Data.SqlClient.SqlBatch.Connection" /> and builds a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" />.
        Exceptions will be reported via the returned Task object.
      </summary><returns>A task representing the asynchronous operation.</returns><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        An error occurred while executing the batch.
      </exception><exception cref="T:System.ArgumentException">
        The <see cref="T:System.Data.CommandBehavior" /> value is invalid.
      </exception><exception cref="T:System.OperationCanceledException">
        The cancellation token was canceled. This exception is stored into the returned task.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteScalar">
            <summary>
        Executes the batch and returns the first column of the first row in the first returned result set. All other columns, rows and resultsets are ignored.
      </summary><returns>The first column of the first row in the first result set.</returns><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        An error occurred while executing the batch.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteScalarAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">A token to cancel the asynchronous operation.</param><summary>
        An asynchronous version of <see cref="M:Microsoft.Data.SqlClient.SqlBatch.ExecuteScalar" />, which executes the batch and returns the first column of the first row in the first returned result set. All other columns, rows and result sets are ignored.
      </summary><returns>The first column of the first row in the first result set.</returns><remarks>
        This method benefits from <see cref="M:Microsoft.Data.SqlClient.SqlCommand.ExecuteScalarAsync" />, and all the expected exceptions of that method also apply here. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as <see cref="T:System.ArgumentException" />, are still thrown synchronously.
      </remarks><exception cref="T:Microsoft.Data.SqlClient.SqlException">
        An error occurred while executing the batch.
      </exception><exception cref="T:System.OperationCanceledException">
        The cancellation token was canceled. This exception is stored into the returned task.
      </exception>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.Prepare">
            <summary>
        Creates a prepared (or compiled) version of the batch, or of each of its commands, on the data source.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatch.PrepareAsync(System.Threading.CancellationToken)">
            <param name="cancellationToken">
        An optional token to cancel the asynchronous operation. The default value is <see cref="P:System.Threading.CancellationToken.None" />.
      </param><summary>
        Asynchronously creates a prepared (or compiled) version of the batch, or of each of its commands, on the data source.
      </summary><returns>A <see cref="T:System.Threading.Tasks.Task" /> representing the asynchronous operation.</returns><remarks>
        This method stores in the task it returns all non-usage exceptions that the method's synchronous counterpart can throw. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as <see cref="T:System.ArgumentException" />, are still thrown synchronously. For the stored exceptions, see the exceptions thrown by <see cref="M:Microsoft.Data.SqlClient.SqlBatch.Prepare" />.
      </remarks><exception cref="T:System.OperationCanceledException">
        The cancellation token was canceled. This exception is stored into the returned task.
      </exception>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBatchCommand">
            <summary>
        SqlBatchCommand allows for the execution of multiple SQL commands in a SqlBatch.
      </summary>
            <summary>
        SqlBatchCommand allows for the execution of multiple SQL commands in a SqlBatch.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommand.#ctor">
            <summary>
        Initializes a new <see cref="T:SqlBatchCommand" />.
      </summary><example>
        The following example creates a <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> and a SqlBatch, then adds multiple <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> objects to the batch. It then executes the batch, creating a <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> . The example reads through the results of the batch commands, writing them to the console. Finally, the example closes the <see cref="T:Microsoft.Data.SqlClient.SqlDataReader" /> and then the <see cref="T:Microsoft.Data.SqlClient.SqlConnection" /> as the <c>using</c> blocks fall out of scope.
        <code language="c#">
          using Microsoft.Data.SqlClient;

          class Program
          {
              static void Main()
              {
                  string str = "Data Source=(local);Initial Catalog=Northwind;"
                             + "Integrated Security=SSPI;Encrypt=False";
                  RunBatch(str);
              }

              static void RunBatch(string connString)
              {
                  using var connection = new SqlConnection(connString);
                  connection.Open();

                  var batch = new SqlBatch(connection);

                  const int count = 10;
                  const string parameterName = "parameter";
                  for (int i = 0; i &lt; count; i++)
                  {
                      var batchCommand = new SqlBatchCommand($"SELECT @{parameterName} as value");
                      batchCommand.Parameters.Add(new SqlParameter(parameterName, i));
                      batch.BatchCommands.Add(batchCommand);
                  }

                  // Optionally Prepare
                  batch.Prepare();

                  var results = new List&lt;int&gt;(count);
                  using (SqlDataReader reader = batch.ExecuteReader())
                  {
                      do
                      {
                          while (reader.Read())
                          {
                              results.Add(reader.GetFieldValue&lt;int&gt;(0));
                          }
                      } while (reader.NextResult());
                  }
                  Console.WriteLine(string.Join(", ", results));
              }
          }

        </code>
      </example>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommand.#ctor(System.String,System.Data.CommandType,System.Collections.Generic.IEnumerable{Microsoft.Data.SqlClient.SqlParameter},Microsoft.Data.SqlClient.SqlCommandColumnEncryptionSetting)">
            <summary>
        Initializes a new <see cref="T:SqlBatchCommand" />.
      </summary><param name="commandText">
        The text of the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" />.
      </param><param name="commandType">
        Indicates how the <see cref="P:Microsoft.Data.SqlClient.SqlBatchCommand.CommandText" /> property is to be interpreted.
      </param><param name="parameters">
        A collection of <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> objects is used to create the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </param><param name="columnEncryptionSetting">
        The encryption setting. For more information, see <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
      </param>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommand.Parameters">
            <summary>
        Gets the <see cref="T:Microsoft.Data.SqlClient.SqlParameterCollection" />.
      </summary><value>
        The parameters of the Transact-SQL statement or stored procedure. The default is an empty collection.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommand.CommandText">
            <summary>
        Gets or sets the text command to run against the data source.
      </summary><value>
        The text command to execute. The default value is an empty string ("").
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommand.CommandType">
            <summary>
        Gets or sets how the <see cref="P:Microsoft.Data.SqlClient.SqlBatchCommand.CommandText" /> property is interpreted.
      </summary><value>
        One of the enumeration values that specifies how a command string is interpreted. The default is <see cref="F:System.Data.CommandType.Text" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommand.CommandBehavior">
            <summary>
        One of the <see cref="T:System.Data.CommandBehavior" /> values, indicating options for statement execution and data retrieval.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommand.RecordsAffected">
            <summary>
        Gets the number of rows changed, inserted, or deleted by execution of this specific <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" />.
      </summary><value>
        The number of rows changed, inserted, or deleted. -1 for SELECT statements; 0 if no rows were affected or the statement failed.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommand.DbParameterCollection">
            <summary>
        Gets the collection of <see cref="T:Microsoft.Data.SqlClient.SqlParameter" /> objects.
      </summary><value>
        The parameters of the SQL statement or stored procedure.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommand.ColumnEncryptionSetting">
            <summary>
        Not currently implemented.
        The encryption setting. For more information, see <see href="https://learn.microsoft.com/sql/relational-databases/security/encryption/always-encrypted-database-engine">Always Encrypted</see>.
      </summary>
        </member>
        <member name="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection">
            <summary>
        A collection of instances of <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" />, contained within a <see cref="T:Microsoft.Data.SqlClient.SqlBatch" />.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Count">
            <summary>
        Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
      </summary><value>
        The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
      </value>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommandCollection.IsReadOnly">
            <summary>
        Specifies whether the collection is read-only.
      </summary><value>
        <see langword="true" /> if the collection is read-only; otherwise <see langword="false" />.
      </value>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.GetEnumerator">
            <summary>
        Returns the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object at the specified index in the collection.
      </summary><returns>
        The <see cref="T:System.Data.Common.DbBatchCommand" /> object at the specified index in the collection.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Add(Microsoft.Data.SqlClient.SqlBatchCommand)">
            <summary>
        Add a <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> to the end of the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Add(System.Data.Common.DbBatchCommand)">
            <param name="item">
        The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.
      </param><summary>
        Adds the specified <see cref="T:System.Data.Common.DbBatchCommand" /> object to the <see cref="T:System.Collections.Generic.ICollection`1" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Clear">
            <summary>
        Removes all <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> values from the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Contains(Microsoft.Data.SqlClient.SqlBatchCommand)">
            <summary>
        Determines whether a <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> is in the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" />.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Contains(System.Data.Common.DbBatchCommand)">
            <param name="item">
        The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.
      </param><summary>
        Indicates whether a <see cref="T:System.Data.Common.DbBatchCommand" /> is contained in the collection.
      </summary><returns>
        <see langword="true" /> if the <see cref="T:System.Data.Common.DbBatchCommand" /> is in the collection; otherwise <see langword="false" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.CopyTo(Microsoft.Data.SqlClient.SqlBatchCommand[],System.Int32)">
            <summary>
        Copies the entire <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" /> to a one dimensional array, starting at the target index of the target array.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.CopyTo(System.Data.Common.DbBatchCommand[],System.Int32)">
            <param name="array">
        The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.
      </param><param name="arrayIndex">
        The zero-based index in <paramref name="array" /> at which copying begins.
      </param><summary>
        Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.IndexOf(Microsoft.Data.SqlClient.SqlBatchCommand)">
            <summary>
        Searches for the specified <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> within the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" /> and returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" />.
      </summary><returns>
        Returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.IndexOf(System.Data.Common.DbBatchCommand)">
            <param name="item">
        The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.
      </param><summary>
        Returns the index of the specified <see cref="T:System.Data.Common.DbBatchCommand" /> object.
      </summary><returns>
        The index of the specified <see cref="T:System.Data.Common.DbBatchCommand" /> object.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Insert(System.Int32,Microsoft.Data.SqlClient.SqlBatchCommand)">
            <summary>
        Inserts an item into the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommandCollection" /> at the specified index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Insert(System.Int32,System.Data.Common.DbBatchCommand)">
            <param name="index">
        The index at which to insert the <see cref="T:System.Data.Common.DbBatchCommand" /> object.
      </param><param name="item">
        The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.
      </param><summary>
        Inserts the specified index of the <see cref="T:System.Data.Common.DbBatchCommand" /> object with the specified name into the collection at the specified index.
      </summary>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Remove(Microsoft.Data.SqlClient.SqlBatchCommand)">
            <summary>
        Removes the first occurrence of a specific <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object from the collection.
      </summary><returns>
        Returns <see langword="true" /> if an item is successfully removed. Returns false if an item could not be removed or no item was not found.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Remove(System.Data.Common.DbBatchCommand)">
            <param name="item">
        The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.
      </param><summary>
        Removes the specified <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object from the collection.
      </summary><returns>
        <see langword="true" /> if <paramref name="item" /> was successfully removed; otherwise, <see langword="false" />. This method also returns <see langword="false" /> if <paramref name="item" /> was not found in the <see cref="T:System.Collections.Generic.ICollection`1" />.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.RemoveAt(System.Int32)">
            <param name="index">
        The index where the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object is located.
      </param><summary>
        Removes the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object at the specified index from the collection.
      </summary>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommandCollection.System#Collections#Generic#IList{Microsoft#Data#SqlClient#SqlBatchCommand}#Item(System.Int32)">
            <summary>
        Gets or Sets the element at the specified index.
      </summary><returns>
        The element at the specified index.
      </returns>
        </member>
        <member name="P:Microsoft.Data.SqlClient.SqlBatchCommandCollection.Item(System.Int32)">
            <summary>
        Gets or Sets the element at the specified index.
      </summary><returns>
        The element at the specified index.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.GetBatchCommand(System.Int32)">
            <param name="index">
        The index where the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object is located.
      </param><summary>
        Returns the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object at the specified index in the list.
      </summary><returns>
        The <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object at the specified index in the list.
      </returns>
        </member>
        <member name="M:Microsoft.Data.SqlClient.SqlBatchCommandCollection.SetBatchCommand(System.Int32,System.Data.Common.DbBatchCommand)">
            <param name="index">
        The index where the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object should be located.
      </param><param name="batchCommand">
        The <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object to add to the collection.
      </param><summary>
        Sets the <see cref="T:Microsoft.Data.SqlClient.SqlBatchCommand" /> object at the specified index to a new value.
      </summary>
        </member>
    </members>
</doc>
